!> \file
!> \author Chris Bradley
!> \brief This module handles all constraint matrix and rhs routines.
!>
!> \section LICENSE
!>
!> Version: MPL 1.1/GPL 2.0/LGPL 2.1
!>
!> The contents of this file are subject to the Mozilla Public License
!> Version 1.1 (the "License"); you may not use this file except in
!> compliance with the License. You may obtain a copy of the License at
!> http://www.mozilla.org/MPL/
!>
!> Software distributed under the License is distributed on an "AS IS"
!> basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
!> License for the specific language governing rights and limitations
!> under the License.
!>
!> The Original Code is OpenCMISS
!>
!> The Initial Developer of the Original Code is University of Auckland,
!> Auckland, New Zealand, the University of Oxford, Oxford, United
!> Kingdom and King's College, London, United Kingdom. Portions created
!> by the University of Auckland, the University of Oxford and King's
!> College, London are Copyright (C) 2007-2010 by the University of
!> Auckland, the University of Oxford and King's College, London.
!> All Rights Reserved.
!>
!> Contributor(s): Sander Arens 
!>
!> Alternatively, the contents of this file may be used under the terms of
!> either the GNU General Public License Version 2 or later (the "GPL"), or
!> the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
!> in which case the provisions of the GPL or the LGPL are applicable instead
!> of those above. If you wish to allow use of your version of this file only
!> under the terms of either the GPL or the LGPL, and not to allow others to
!> use your version of this file under the terms of the MPL, indicate your
!> decision by deleting the provisions above and replace them with the notice
!> and other provisions required by the GPL or the LGPL. If you do not delete
!> the provisions above, a recipient may use your version of this file under
!> the terms of any one of the MPL, the GPL or the LGPL.
!>

!> This module handles all constraint matrix and rhs routines.
MODULE CONSTRAINT_MATRICES_ROUTINES

  USE BASE_ROUTINES
  USE DISTRIBUTED_MATRIX_VECTOR
  USE CONSTRAINT_CONDITIONS_CONSTANTS
  USE FIELD_ROUTINES
  USE ISO_VARYING_STRING
  USE KINDS
  USE LISTS
  USE MATRIX_VECTOR
  USE STRINGS
  USE TYPES
  USE LINKEDLIST_ROUTINES
  IMPLICIT NONE

  PRIVATE

  !Module parameters

  !> \addtogroup CONSTRAINT_MATRICES_ROUTINES_ConstraintMatrixStructureTypes CONSTRAINT_MATRICES_ROUTINES::ConstraintMatrixStructureTypes
  !> \brief Constraint matrices structure (sparsity) types
  !> \see CONSTRAINT_MATRICES_ROUTINES
  !>@{
  INTEGER(INTG), PARAMETER :: CONSTRAINT_MATRIX_NO_STRUCTURE=1 !<No matrix structure - all elements can contain a value. \see CONSTRAINT_MATRICES_ROUTINES_ConstraintMatrixStructureTypes,CONSTRAINT_MATRICES_ROUTINES
  INTEGER(INTG), PARAMETER :: CONSTRAINT_MATRIX_FEM_STRUCTURE=2 !<Finite element matrix structure. \see CONSTRAINT_MATRICES_ROUTINES_ConstraintMatrixStructureTypes,CONSTRAINT_MATRICES_ROUTINES
  INTEGER(INTG), PARAMETER :: CONSTRAINT_MATRIX_DIAGONAL_STRUCTURE=3 !<Diagonal matrix structure. \see CONSTRAINT_MATRICES_ROUTINES_ConstraintMatrixStructureTypes,CONSTRAINT_MATRICES_ROUTINES
  !>@}

  !> \addtogroup CONSTRAINT_MATRICES_ROUTINES_ConstraintMatricesSparsityTypes CONSTRAINT_MATRICES_ROUTINES::ConstraintMatricesSparsityTypes
  !> \brief Constraint matrices sparsity types
  !> \see CONSTRAINT_MATRICES_ROUTINES
  !>@{
  INTEGER(INTG), PARAMETER :: CONSTRAINT_MATRICES_SPARSE_MATRICES=1 !<Use sparse constraint matrices \see CONSTRAINT_MATRICES_ROUTINES_ConstraintMatricesSparsityTypes,CONSTRAINT_MATRICES_ROUTINES
  INTEGER(INTG), PARAMETER :: CONSTRAINT_MATRICES_FULL_MATRICES=2 !<Use fully populated constraint matrices \see CONSTRAINT_MATRICES_ROUTINES_ConstraintMatricesSparsityTypes,CONSTRAINT_MATRICES_ROUTINES
  !>@}

  !> \addtogroup CONSTRAINT_MATRICES_ROUTINES_SelectMatricesTypes CONSTRAINT_MATRICES_ROUTINES::SelectMatricesTypes
  !> \brief The types of selection available for the constraint matrices
  !> \see SOLVER_ROUTINES
  !>@{
  INTEGER(INTG), PARAMETER :: CONSTRAINT_MATRICES_ALL=1 !<Select all the constraint matrices and vectors \see CONSTRAINT_MATRICES_ROUTINES::SelectMatricesTypes,CONSTRAINT_MATRICES_ROUTINES
  INTEGER(INTG), PARAMETER :: CONSTRAINT_MATRICES_DYNAMIC_ONLY=2 !<Select only the dynamic constraint matrices and vectors \see CONSTRAINT_MATRICES_ROUTINES::SelectMatricesTypes,CONSTRAINT_MATRICES_ROUTINES
  INTEGER(INTG), PARAMETER :: CONSTRAINT_MATRICES_LINEAR_ONLY=3 !<Select only the linear constraint matrices and vectors \see CONSTRAINT_MATRICES_ROUTINES::SelectMatricesTypes,CONSTRAINT_MATRICES_ROUTINES
  INTEGER(INTG), PARAMETER :: CONSTRAINT_MATRICES_NONLINEAR_ONLY=4 !<Select only the nonlinear constraint matrices and vectors \see CONSTRAINT_MATRICES_ROUTINES::SelectMatricesTypes,CONSTRAINT_MATRICES_ROUTINES
  INTEGER(INTG), PARAMETER :: CONSTRAINT_MATRICES_JACOBIAN_ONLY=5 !<Select only the Jacobian constraint matrix \see CONSTRAINT_MATRICES_ROUTINES::SelectMatricesTypes,CONSTRAINT_MATRICES_ROUTINES
  INTEGER(INTG), PARAMETER :: CONSTRAINT_MATRICES_RESIDUAL_ONLY=6 !<Select only the residual constraint vector \see CONSTRAINT_MATRICES_ROUTINES::SelectMatricesTypes,CONSTRAINT_MATRICES_ROUTINES
  INTEGER(INTG), PARAMETER :: CONSTRAINT_MATRICES_RHS_ONLY=7 !<Select only the RHS constraint vector \see CONSTRAINT_MATRICES_ROUTINES::SelectMatricesTypes,CONSTRAINT_MATRICES_ROUTINES
  INTEGER(INTG), PARAMETER :: CONSTRAINT_MATRICES_RHS_RESIDUAL_ONLY=9 !<Select only the RHS and residual constraint vectors \see CONSTRAINT_MATRICES_ROUTINES::SelectMatricesTypes,CONSTRAINT_MATRICES_ROUTINES
  INTEGER(INTG), PARAMETER :: CONSTRAINT_MATRICES_VECTORS_ONLY=12 !<Assemble only the constraint vectors \see CONSTRAINT_MATRICES_ROUTINES::SelectMatricesTypes,CONSTRAINT_MATRICES_ROUTINES
  !>@}

  !Module types

  !Module variables

  !Interfaces

  INTERFACE CONSTRAINT_MATRICES_NONLINEAR_STORAGE_TYPE_SET
    MODULE PROCEDURE CONSTRAINT_MATRICES_NONLINEAR_STORAGE_TYPE_SET_0
    MODULE PROCEDURE CONSTRAINT_MATRICES_NONLINEAR_STORAGE_TYPE_SET_1
  END INTERFACE !CONSTRAINT_MATRICES_NONLINEAR_STORAGE_TYPE_SET

  INTERFACE CONSTRAINT_MATRICES_NONLINEAR_STRUCTURE_TYPE_SET
    MODULE PROCEDURE CONSTRAINT_MATRICES_NONLINEAR_STRUCTURE_TYPE_SET_0
    MODULE PROCEDURE CONSTRAINT_MATRICES_NONLINEAR_STRUCTURE_TYPE_SET_1
  END INTERFACE !CONSTRAINT_MATRICES_NONLINEAR_STRUCTURE_TYPE_SET

  PUBLIC CONSTRAINT_MATRIX_NO_STRUCTURE,CONSTRAINT_MATRIX_FEM_STRUCTURE,CONSTRAINT_MATRIX_DIAGONAL_STRUCTURE

  PUBLIC CONSTRAINT_MATRICES_SPARSE_MATRICES,CONSTRAINT_MATRICES_FULL_MATRICES

  PUBLIC CONSTRAINT_MATRICES_CREATE_FINISH,CONSTRAINT_MATRICES_CREATE_START,CONSTRAINT_MATRICES_DESTROY

  !!TODO check if the elements should be create/destroy rather than initialise/finalise
  PUBLIC CONSTRAINT_MATRICES_ELEMENT_ADD,CONSTRAINT_MATRICES_JACOBIAN_ELEMENT_ADD,CONSTRAINT_MATRICES_ELEMENT_CALCULATE, &
    & CONSTRAINT_MATRICES_ELEMENT_INITIALISE,CONSTRAINT_MATRICES_ELEMENT_FINALISE,CONSTRAINT_MATRICES_VALUES_INITIALISE

  PUBLIC CONSTRAINT_MATRICES_ELEMENT_MATRIX_CALCULATE,CONSTRAINT_MATRICES_ELEMENT_MATRIX_FINALISE, &
    & CONSTRAINT_MATRICES_ELEMENT_MATRIX_INITIALISE,CONSTRAINT_MATRICES_ELEMENT_MATRIX_SETUP

  PUBLIC CONSTRAINT_MATRICES_ELEMENT_VECTOR_CALCULATE,CONSTRAINT_MATRICES_ELEMENT_VECTOR_FINALISE, &
    & CONSTRAINT_MATRICES_ELEMENT_VECTOR_INITIALISE,CONSTRAINT_MATRICES_ELEMENT_VECTOR_SETUP

  PUBLIC CONSTRAINT_MATRICES_ALL,CONSTRAINT_MATRICES_LINEAR_ONLY,CONSTRAINT_MATRICES_NONLINEAR_ONLY, &
    & CONSTRAINT_MATRICES_JACOBIAN_ONLY,CONSTRAINT_MATRICES_RESIDUAL_ONLY,CONSTRAINT_MATRICES_RHS_ONLY, &
    & CONSTRAINT_MATRICES_RHS_RESIDUAL_ONLY,CONSTRAINT_MATRICES_VECTORS_ONLY
  
  PUBLIC CONSTRAINT_MATRICES_OUTPUT,CONSTRAINT_MATRICES_JACOBIAN_OUTPUT

  PUBLIC CONSTRAINT_MATRICES_DYNAMIC_STORAGE_TYPE_SET,CONSTRAINT_MATRICES_DYNAMIC_STRUCTURE_TYPE_SET

  PUBLIC CONSTRAINT_MATRICES_LINEAR_STORAGE_TYPE_SET,CONSTRAINT_MATRICES_LINEAR_STRUCTURE_TYPE_SET

  PUBLIC CONSTRAINT_MATRICES_NONLINEAR_STORAGE_TYPE_SET,CONSTRAINT_MATRICES_NONLINEAR_STRUCTURE_TYPE_SET

CONTAINS

  !
  !================================================================================================================================
  !

  !>Finalise the constraint Jacobian and deallocate all memory
  SUBROUTINE CONSTRAINT_JACOBIAN_FINALISE(CONSTRAINT_JACOBIAN,ERR,ERROR,*)

    !Argument variables
    TYPE(CONSTRAINT_JACOBIAN_TYPE), POINTER :: CONSTRAINT_JACOBIAN !<A pointer to the constraint Jacobian to finalise
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    
    CALL ENTERS("CONSTRAINT_JACOBIAN_FINALISE",ERR,ERROR,*999)

    IF(ASSOCIATED(CONSTRAINT_JACOBIAN)) THEN
      IF(ASSOCIATED(CONSTRAINT_JACOBIAN%JACOBIAN)) CALL DISTRIBUTED_MATRIX_DESTROY(CONSTRAINT_JACOBIAN%JACOBIAN,ERR,ERROR,*999)
      IF(ASSOCIATED(CONSTRAINT_JACOBIAN%JACOBIAN_TRANSPOSE))  &
        & CALL DISTRIBUTED_MATRIX_DESTROY(CONSTRAINT_JACOBIAN%JACOBIAN_TRANSPOSE,ERR,ERROR,*999)
      IF(ASSOCIATED(CONSTRAINT_JACOBIAN%TEMP_VECTOR)) &
        & CALL DISTRIBUTED_VECTOR_DESTROY(CONSTRAINT_JACOBIAN%TEMP_VECTOR,ERR,ERROR,*999)
      IF(ASSOCIATED(CONSTRAINT_JACOBIAN%TEMP_TRANSPOSE_VECTOR)) &
        & CALL DISTRIBUTED_VECTOR_DESTROY(CONSTRAINT_JACOBIAN%TEMP_TRANSPOSE_VECTOR,ERR,ERROR,*999)
      CALL CONSTRAINT_MATRICES_ELEMENT_MATRIX_FINALISE(CONSTRAINT_JACOBIAN%ELEMENT_JACOBIAN,ERR,ERROR,*999)
    ENDIF
    
    CALL EXITS("CONSTRAINT_JACOBIAN_FINALISE")
    RETURN
999 CALL ERRORS("CONSTRAINT_JACOBIAN_FINALISE",ERR,ERROR)
    CALL EXITS("CONSTRAINT_JACOBIAN_FINALISE")
    RETURN 1
  END SUBROUTINE CONSTRAINT_JACOBIAN_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialise the constraint Jacobian.
  SUBROUTINE CONSTRAINT_JACOBIAN_INITIALISE(NONLINEAR_MATRICES,MATRIX_NUMBER,ERR,ERROR,*)

    !Argument variables
    TYPE(CONSTRAINT_MATRICES_NONLINEAR_TYPE), POINTER :: NONLINEAR_MATRICES !<A pointer to the constraint matrices nonlinear matrices to initialise the Jacobian for
    INTEGER(INTG), INTENT(IN) :: MATRIX_NUMBER !<The index of the Jacobian matrix to initialise for the nonlinear matrices
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DUMMY_ERR
    TYPE(CONSTRAINT_MAPPING_TYPE), POINTER :: CONSTRAINT_MAPPING
    TYPE(CONSTRAINT_MATRICES_TYPE), POINTER :: CONSTRAINT_MATRICES
    TYPE(CONSTRAINT_MAPPING_NONLINEAR_TYPE), POINTER :: NONLINEAR_MAPPING
    TYPE(VARYING_STRING) :: DUMMY_ERROR

    CALL ENTERS("CONSTRAINT_JACOBIAN_INITIALISE",ERR,ERROR,*998)
 
    IF(ASSOCIATED(NONLINEAR_MATRICES)) THEN
      CONSTRAINT_MATRICES=>NONLINEAR_MATRICES%CONSTRAINT_MATRICES
      IF(ASSOCIATED(CONSTRAINT_MATRICES)) THEN
        CONSTRAINT_MAPPING=>CONSTRAINT_MATRICES%CONSTRAINT_MAPPING
        IF(ASSOCIATED(CONSTRAINT_MAPPING)) THEN
          NONLINEAR_MAPPING=>CONSTRAINT_MAPPING%NONLINEAR_MAPPING
          IF(ASSOCIATED(NONLINEAR_MAPPING)) THEN
            IF(ALLOCATED(NONLINEAR_MATRICES%JACOBIANS)) THEN
              IF(ASSOCIATED(NONLINEAR_MATRICES%JACOBIANS(MATRIX_NUMBER)%PTR)) THEN
                CALL FLAG_ERROR("Nonlinear matrices Jacobian is already associated.",ERR,ERROR,*998)
              ELSE
                ALLOCATE(NONLINEAR_MATRICES%JACOBIANS(MATRIX_NUMBER)%PTR,STAT=ERR)
                IF(ERR/=0) CALL FLAG_ERROR("Could not allocate constraint Jacobian.",ERR,ERROR,*999)
                NONLINEAR_MATRICES%JACOBIANS(MATRIX_NUMBER)%PTR%JACOBIAN_NUMBER=MATRIX_NUMBER
                NONLINEAR_MATRICES%JACOBIANS(MATRIX_NUMBER)%PTR%NONLINEAR_MATRICES=>NONLINEAR_MATRICES
                NONLINEAR_MATRICES%JACOBIANS(MATRIX_NUMBER)%PTR%STORAGE_TYPE=MATRIX_BLOCK_STORAGE_TYPE
                NONLINEAR_MATRICES%JACOBIANS(MATRIX_NUMBER)%PTR%STRUCTURE_TYPE=CONSTRAINT_MATRIX_NO_STRUCTURE
                NONLINEAR_MATRICES%JACOBIANS(MATRIX_NUMBER)%PTR%UPDATE_JACOBIAN=.TRUE.
                NONLINEAR_MATRICES%JACOBIANS(MATRIX_NUMBER)%PTR%FIRST_ASSEMBLY=.TRUE.
                NONLINEAR_MATRICES%JACOBIANS(MATRIX_NUMBER)%PTR%HAS_TRANSPOSE=NONLINEAR_MAPPING% &
                  & CONSTRAINT_JACOBIAN_ROWS_TO_VAR_MAP(MATRIX_NUMBER)%HAS_TRANSPOSE
                NONLINEAR_MATRICES%JACOBIANS(MATRIX_NUMBER)%PTR%NUMBER_OF_ROWS=NONLINEAR_MAPPING% &
                  & CONSTRAINT_JACOBIAN_ROWS_TO_VAR_MAP(MATRIX_NUMBER)%NUMBER_OF_ROWS
                NONLINEAR_MATRICES%JACOBIANS(MATRIX_NUMBER)%PTR%TOTAL_NUMBER_OF_ROWS=NONLINEAR_MAPPING% &
                  & CONSTRAINT_JACOBIAN_ROWS_TO_VAR_MAP(MATRIX_NUMBER)%TOTAL_NUMBER_OF_ROWS
                NONLINEAR_MAPPING%CONSTRAINT_JACOBIAN_ROWS_TO_VAR_MAP(MATRIX_NUMBER)%CONSTRAINT_JACOBIAN=> &
                  & NONLINEAR_MATRICES%JACOBIANS(MATRIX_NUMBER)%PTR
                NULLIFY(NONLINEAR_MATRICES%JACOBIANS(MATRIX_NUMBER)%PTR%JACOBIAN)
                NULLIFY(NONLINEAR_MATRICES%JACOBIANS(MATRIX_NUMBER)%PTR%JACOBIAN_TRANSPOSE)
                CALL CONSTRAINT_MATRICES_ELEMENT_MATRIX_INITIALISE(NONLINEAR_MATRICES%JACOBIANS(MATRIX_NUMBER)%PTR% &
                    & ELEMENT_JACOBIAN,ERR,ERROR,*999)
              ENDIF
            ELSE
              CALL FLAG_ERROR("Constraint matrices nonlinear matrieces Jacobian is not allocated.",ERR,ERROR,*999)
            ENDIF
          ELSE
            CALL FLAG_ERROR("Constraint mapping nonlinear mapping is not associated.",ERR,ERROR,*999)
          ENDIF
        ELSE
          CALL FLAG_ERROR("Constraint mapping is not associated.",ERR,ERROR,*998)
        ENDIF
      ELSE
        CALL FLAG_ERROR("Nonlinear matrices constraint matrices is not associated.",ERR,ERROR,*998)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Nonlinear matrices is not associated.",ERR,ERROR,*998)
    ENDIF
    
    CALL EXITS("CONSTRAINT_JACOBIAN_INITIALISE")
    RETURN
999 CALL CONSTRAINT_JACOBIAN_FINALISE(NONLINEAR_MATRICES%JACOBIANS(MATRIX_NUMBER)%PTR,DUMMY_ERR,DUMMY_ERROR,*998)
998 CALL ERRORS("CONSTRAINT_JACOBIAN_INITIALISE",ERR,ERROR)
    CALL EXITS("CONSTRAINT_JACOBIAN_INITIALISE")
    RETURN 1
  END SUBROUTINE CONSTRAINT_JACOBIAN_INITIALISE

  !
  !================================================================================================================================
  !

  !>Finishes the creation of the constraint matrices and RHS for the the equations
  SUBROUTINE CONSTRAINT_MATRICES_CREATE_FINISH(CONSTRAINT_MATRICES,ERR,ERROR,*)

    !Argument variables
    TYPE(CONSTRAINT_MATRICES_TYPE), POINTER :: CONSTRAINT_MATRICES !<The pointer to the constraint matrices
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string  
    !Local Variables
    INTEGER(INTG) :: DUMMY_ERR,matrix_idx,NUMBER_OF_NON_ZEROS
    INTEGER(INTG), POINTER :: ROW_INDICES(:),COLUMN_INDICES(:),TRANSPOSE_ROW_INDICES(:),TRANSPOSE_COLUMN_INDICES(:)
    TYPE(DOMAIN_MAPPING_TYPE), POINTER :: ROW_DOMAIN_MAP,COLUMN_DOMAIN_MAP
    TYPE(CONSTRAINT_JACOBIAN_TYPE), POINTER :: JACOBIAN_MATRIX
    TYPE(CONSTRAINT_MAPPING_DYNAMIC_TYPE), POINTER :: DYNAMIC_MAPPING
    TYPE(CONSTRAINT_MAPPING_LINEAR_TYPE), POINTER :: LINEAR_MAPPING
    TYPE(CONSTRAINT_MAPPING_TYPE), POINTER :: CONSTRAINT_MAPPING
    TYPE(CONSTRAINT_MATRICES_DYNAMIC_TYPE), POINTER :: DYNAMIC_MATRICES
    TYPE(CONSTRAINT_MATRICES_LINEAR_TYPE), POINTER :: LINEAR_MATRICES
    TYPE(CONSTRAINT_MATRICES_NONLINEAR_TYPE), POINTER :: NONLINEAR_MATRICES
    TYPE(CONSTRAINT_RHS_TYPE), POINTER :: RHS_VECTOR
    TYPE(CONSTRAINT_MATRIX_TYPE), POINTER :: CONSTRAINT_MATRIX
    TYPE(CONSTRAINT_MAPPING_NONLINEAR_TYPE), POINTER :: NONLINEAR_MAPPING
    TYPE(VARYING_STRING) :: DUMMY_ERROR,LOCAL_ERROR
    NULLIFY(ROW_INDICES,COLUMN_INDICES,TRANSPOSE_ROW_INDICES,TRANSPOSE_COLUMN_INDICES)

    CALL ENTERS("CONSTRAINT_MATRICES_CREATE_FINISH",ERR,ERROR,*998)

    IF(ASSOCIATED(CONSTRAINT_MATRICES)) THEN
      IF(CONSTRAINT_MATRICES%CONSTRAINT_MATRICES_FINISHED) THEN
        CALL FLAG_ERROR("Constraint matrices have already been finished.",ERR,ERROR,*998)
      ELSE
        CONSTRAINT_MAPPING=>CONSTRAINT_MATRICES%CONSTRAINT_MAPPING
        IF(ASSOCIATED(CONSTRAINT_MAPPING)) THEN
          COLUMN_DOMAIN_MAP=>CONSTRAINT_MAPPING%COLUMN_DOFS_MAPPING
          IF(ASSOCIATED(COLUMN_DOMAIN_MAP)) THEN
            DYNAMIC_MATRICES=>CONSTRAINT_MATRICES%DYNAMIC_MATRICES
            IF(ASSOCIATED(DYNAMIC_MATRICES)) THEN
              !Dynamic matrices
              DYNAMIC_MAPPING=>CONSTRAINT_MAPPING%DYNAMIC_MAPPING
              IF(ASSOCIATED(DYNAMIC_MAPPING)) THEN
                !Now create the individual dynamic constraint matrices
                DO matrix_idx=1,DYNAMIC_MATRICES%NUMBER_OF_DYNAMIC_MATRICES
                  CONSTRAINT_MATRIX=>DYNAMIC_MATRICES%MATRICES(matrix_idx)%PTR
                  IF(ASSOCIATED(CONSTRAINT_MATRIX)) THEN
                    ROW_DOMAIN_MAP=>DYNAMIC_MAPPING%CONSTRAINT_MATRIX_ROWS_TO_VAR_MAP(matrix_idx)%ROW_DOFS_MAPPING
                    IF(ASSOCIATED(ROW_DOMAIN_MAP)) THEN
                      !Create the distributed constraint matrix
                      CALL DISTRIBUTED_MATRIX_CREATE_START(ROW_DOMAIN_MAP,COLUMN_DOMAIN_MAP, &
                        & CONSTRAINT_MATRIX%MATRIX,ERR,ERROR,*999)
                      CALL DISTRIBUTED_MATRIX_DATA_TYPE_SET(CONSTRAINT_MATRIX%MATRIX,MATRIX_VECTOR_DP_TYPE,ERR,ERROR,*999)
                      CALL DISTRIBUTED_MATRIX_STORAGE_TYPE_SET(CONSTRAINT_MATRIX%MATRIX, &
                        & CONSTRAINT_MATRIX%STORAGE_TYPE,ERR,ERROR,*999)
                      IF(CONSTRAINT_MATRIX%HAS_TRANSPOSE) THEN
                        CALL DISTRIBUTED_MATRIX_CREATE_START(COLUMN_DOMAIN_MAP,ROW_DOMAIN_MAP, &
                          & CONSTRAINT_MATRIX%MATRIX_TRANSPOSE,ERR,ERROR,*999)
                        CALL DISTRIBUTED_MATRIX_DATA_TYPE_SET(CONSTRAINT_MATRIX%MATRIX_TRANSPOSE, &
                          & DISTRIBUTED_MATRIX_VECTOR_DP_TYPE,ERR,ERROR,*999)
                        CALL DISTRIBUTED_MATRIX_STORAGE_TYPE_SET(CONSTRAINT_MATRIX%MATRIX_TRANSPOSE, &
                          & CONSTRAINT_MATRIX%STORAGE_TYPE,ERR,ERROR,*999)
                      ENDIF

                      !Calculate and set the matrix structure/sparsity pattern
                      IF(CONSTRAINT_MATRIX%STORAGE_TYPE/=DISTRIBUTED_MATRIX_BLOCK_STORAGE_TYPE.AND. &
                        & CONSTRAINT_MATRIX%STORAGE_TYPE/=DISTRIBUTED_MATRIX_DIAGONAL_STORAGE_TYPE) THEN
                        CALL CONSTRAINT_MATRIX_STRUCTURE_CALCULATE(CONSTRAINT_MATRIX,NUMBER_OF_NON_ZEROS, &
                          & ROW_INDICES,COLUMN_INDICES,TRANSPOSE_ROW_INDICES,TRANSPOSE_COLUMN_INDICES,ERR,ERROR,*999)
                        CALL DISTRIBUTED_MATRIX_NUMBER_NON_ZEROS_SET(CONSTRAINT_MATRIX%MATRIX,NUMBER_OF_NON_ZEROS,ERR,ERROR,*999)
                        CALL DISTRIBUTED_MATRIX_STORAGE_LOCATIONS_SET(CONSTRAINT_MATRIX%MATRIX,ROW_INDICES,COLUMN_INDICES, &
                          & ERR,ERROR,*999)
                        IF(CONSTRAINT_MATRIX%HAS_TRANSPOSE) THEN
                          CALL DISTRIBUTED_MATRIX_NUMBER_NON_ZEROS_SET(CONSTRAINT_MATRIX%MATRIX_TRANSPOSE,NUMBER_OF_NON_ZEROS, &
                            & ERR,ERROR,*999)
                          CALL DISTRIBUTED_MATRIX_STORAGE_LOCATIONS_SET(CONSTRAINT_MATRIX%MATRIX_TRANSPOSE,TRANSPOSE_ROW_INDICES, &
                            & TRANSPOSE_COLUMN_INDICES,ERR,ERROR,*999)
                        ENDIF
                        IF(ASSOCIATED(ROW_INDICES)) DEALLOCATE(ROW_INDICES)
                        IF(ASSOCIATED(COLUMN_INDICES)) DEALLOCATE(COLUMN_INDICES)
                        IF(ASSOCIATED(TRANSPOSE_ROW_INDICES)) DEALLOCATE(TRANSPOSE_ROW_INDICES)
                        IF(ASSOCIATED(TRANSPOSE_COLUMN_INDICES)) DEALLOCATE(TRANSPOSE_COLUMN_INDICES)
                      ENDIF
                      CALL DISTRIBUTED_MATRIX_CREATE_FINISH(CONSTRAINT_MATRIX%MATRIX,ERR,ERROR,*999)
                      IF(CONSTRAINT_MATRIX%HAS_TRANSPOSE) THEN
                        CALL DISTRIBUTED_MATRIX_CREATE_FINISH(CONSTRAINT_MATRIX%MATRIX_TRANSPOSE,ERR,ERROR,*999)
                      ENDIF
                    ELSE
                      LOCAL_ERROR="Row domain map for dynamic matrix number "// &
                        & TRIM(NUMBER_TO_VSTRING(matrix_idx,"*",ERR,ERROR))//" is not associated."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    ENDIF
                  ELSE
                    LOCAL_ERROR="Constraint matrix for dynamic matrix number "// &
                      & TRIM(NUMBER_TO_VSTRING(matrix_idx,"*",ERR,ERROR))//" is not associated."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ENDDO !matrix_idx                
              ELSE
                CALL FLAG_ERROR("Constraint mapping dynamic mapping is not associated.",ERR,ERROR,*999)                
              ENDIF
            ENDIF
            LINEAR_MATRICES=>CONSTRAINT_MATRICES%LINEAR_MATRICES
            IF(ASSOCIATED(LINEAR_MATRICES)) THEN
              !Linear matrices
              LINEAR_MAPPING=>CONSTRAINT_MAPPING%LINEAR_MAPPING
              IF(ASSOCIATED(LINEAR_MAPPING)) THEN
                !Now create the individual linear constraint matrices
                DO matrix_idx=1,LINEAR_MATRICES%NUMBER_OF_LINEAR_MATRICES
                  CONSTRAINT_MATRIX=>LINEAR_MATRICES%MATRICES(matrix_idx)%PTR
                  IF(ASSOCIATED(CONSTRAINT_MATRIX)) THEN
                    ROW_DOMAIN_MAP=>LINEAR_MAPPING%CONSTRAINT_MATRIX_ROWS_TO_VAR_MAP(matrix_idx)%ROW_DOFS_MAPPING
                    IF(ASSOCIATED(ROW_DOMAIN_MAP)) THEN
                      !Create the distributed constraint matrix
                      CALL DISTRIBUTED_MATRIX_CREATE_START(ROW_DOMAIN_MAP,COLUMN_DOMAIN_MAP, &
                        & CONSTRAINT_MATRIX%MATRIX,ERR,ERROR,*999)
                      CALL DISTRIBUTED_MATRIX_DATA_TYPE_SET(CONSTRAINT_MATRIX%MATRIX,MATRIX_VECTOR_DP_TYPE,ERR,ERROR,*999)
                      CALL DISTRIBUTED_MATRIX_STORAGE_TYPE_SET(CONSTRAINT_MATRIX%MATRIX, &
                        & CONSTRAINT_MATRIX%STORAGE_TYPE,ERR,ERROR,*999)
                      IF(CONSTRAINT_MATRIX%HAS_TRANSPOSE) THEN
                        CALL DISTRIBUTED_MATRIX_CREATE_START(COLUMN_DOMAIN_MAP,ROW_DOMAIN_MAP, &
                          & CONSTRAINT_MATRIX%MATRIX_TRANSPOSE,ERR,ERROR,*999)
                        CALL DISTRIBUTED_MATRIX_DATA_TYPE_SET(CONSTRAINT_MATRIX%MATRIX_TRANSPOSE, &
                          & DISTRIBUTED_MATRIX_VECTOR_DP_TYPE,ERR,ERROR,*999)
                        CALL DISTRIBUTED_MATRIX_STORAGE_TYPE_SET(CONSTRAINT_MATRIX%MATRIX_TRANSPOSE, &
                          & CONSTRAINT_MATRIX%STORAGE_TYPE,ERR,ERROR,*999)
                      ENDIF

                      !Calculate and set the matrix structure/sparsity pattern
                      IF(CONSTRAINT_MATRIX%STORAGE_TYPE/=DISTRIBUTED_MATRIX_BLOCK_STORAGE_TYPE.AND. &
                        & CONSTRAINT_MATRIX%STORAGE_TYPE/=DISTRIBUTED_MATRIX_DIAGONAL_STORAGE_TYPE) THEN
                        CALL CONSTRAINT_MATRIX_STRUCTURE_CALCULATE(CONSTRAINT_MATRIX,NUMBER_OF_NON_ZEROS, &
                          & ROW_INDICES,COLUMN_INDICES,TRANSPOSE_ROW_INDICES,TRANSPOSE_COLUMN_INDICES,ERR,ERROR,*999)
                        CALL DISTRIBUTED_MATRIX_NUMBER_NON_ZEROS_SET(CONSTRAINT_MATRIX%MATRIX,NUMBER_OF_NON_ZEROS,ERR,ERROR,*999)
                        CALL DISTRIBUTED_MATRIX_STORAGE_LOCATIONS_SET(CONSTRAINT_MATRIX%MATRIX,ROW_INDICES,COLUMN_INDICES, &
                          & ERR,ERROR,*999)
                        IF(CONSTRAINT_MATRIX%HAS_TRANSPOSE) THEN
                          CALL DISTRIBUTED_MATRIX_NUMBER_NON_ZEROS_SET(CONSTRAINT_MATRIX%MATRIX_TRANSPOSE,NUMBER_OF_NON_ZEROS, &
                            & ERR,ERROR,*999)
                          CALL DISTRIBUTED_MATRIX_STORAGE_LOCATIONS_SET(CONSTRAINT_MATRIX%MATRIX_TRANSPOSE,TRANSPOSE_ROW_INDICES, &
                            & TRANSPOSE_COLUMN_INDICES,ERR,ERROR,*999)
                        ENDIF

                        IF(ASSOCIATED(ROW_INDICES)) DEALLOCATE(ROW_INDICES)
                        IF(ASSOCIATED(COLUMN_INDICES)) DEALLOCATE(COLUMN_INDICES)
                        IF(ASSOCIATED(TRANSPOSE_ROW_INDICES)) DEALLOCATE(TRANSPOSE_ROW_INDICES)
                        IF(ASSOCIATED(TRANSPOSE_COLUMN_INDICES)) DEALLOCATE(TRANSPOSE_COLUMN_INDICES)
                      ENDIF
                      CALL DISTRIBUTED_MATRIX_CREATE_FINISH(CONSTRAINT_MATRIX%MATRIX,ERR,ERROR,*999)
                      IF(CONSTRAINT_MATRIX%HAS_TRANSPOSE) THEN
                        CALL DISTRIBUTED_MATRIX_CREATE_FINISH(CONSTRAINT_MATRIX%MATRIX_TRANSPOSE,ERR,ERROR,*999)
                      ENDIF
                    ELSE
                      LOCAL_ERROR="Row domain map for linear matrix number "// &
                        & TRIM(NUMBER_TO_VSTRING(matrix_idx,"*",ERR,ERROR))//" is not associated."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    ENDIF
                  ELSE
                    LOCAL_ERROR="Constraint matrix for linear matrix number "//TRIM(NUMBER_TO_VSTRING(matrix_idx,"*",ERR,ERROR))// &
                      & " is not associated."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ENDDO !matrix_idx
              ELSE
                CALL FLAG_ERROR("Constraint mapping linear mapping is not associated.",ERR,ERROR,*999)                
              ENDIF
            ENDIF
            NONLINEAR_MATRICES=>CONSTRAINT_MATRICES%NONLINEAR_MATRICES
            IF(ASSOCIATED(NONLINEAR_MATRICES)) THEN
              !Nonlinear matrices
              NONLINEAR_MAPPING=>CONSTRAINT_MAPPING%NONLINEAR_MAPPING
              IF(ASSOCIATED(NONLINEAR_MAPPING)) THEN
                !Set up the Jacobian matrices
                DO matrix_idx=1,NONLINEAR_MATRICES%NUMBER_OF_JACOBIANS
                  JACOBIAN_MATRIX=>NONLINEAR_MATRICES%JACOBIANS(matrix_idx)%PTR
                  IF(ASSOCIATED(JACOBIAN_MATRIX)) THEN
                    ROW_DOMAIN_MAP=>NONLINEAR_MAPPING%CONSTRAINT_JACOBIAN_ROWS_TO_VAR_MAP(matrix_idx)%ROW_DOFS_MAPPING
                    IF(ASSOCIATED(ROW_DOMAIN_MAP)) THEN
  !!TODO: Set the distributed matrix not to allocate the data if the Jacobian is not calculated.
                      !Create the distributed constraint matrix
                      CALL DISTRIBUTED_MATRIX_CREATE_START(ROW_DOMAIN_MAP,COLUMN_DOMAIN_MAP, &
                        & JACOBIAN_MATRIX%JACOBIAN,ERR,ERROR,*999)
                      CALL DISTRIBUTED_MATRIX_DATA_TYPE_SET(JACOBIAN_MATRIX%JACOBIAN,MATRIX_VECTOR_DP_TYPE,ERR,ERROR,*999)
                      CALL DISTRIBUTED_MATRIX_STORAGE_TYPE_SET(JACOBIAN_MATRIX%JACOBIAN, &
                        & JACOBIAN_MATRIX%STORAGE_TYPE,ERR,ERROR,*999)
                      IF(JACOBIAN_MATRIX%HAS_TRANSPOSE) THEN
                        CALL DISTRIBUTED_MATRIX_CREATE_START(COLUMN_DOMAIN_MAP,ROW_DOMAIN_MAP, &
                          & JACOBIAN_MATRIX%JACOBIAN_TRANSPOSE,ERR,ERROR,*999)
                        CALL DISTRIBUTED_MATRIX_DATA_TYPE_SET(JACOBIAN_MATRIX%JACOBIAN_TRANSPOSE, &
                          & DISTRIBUTED_MATRIX_VECTOR_DP_TYPE,ERR,ERROR,*999)
                        CALL DISTRIBUTED_MATRIX_STORAGE_TYPE_SET(JACOBIAN_MATRIX%JACOBIAN_TRANSPOSE, &
                          & JACOBIAN_MATRIX%STORAGE_TYPE,ERR,ERROR,*999)
                      ENDIF

                      !Calculate and set the matrix structure/sparsity pattern
                      IF(JACOBIAN_MATRIX%STORAGE_TYPE/=DISTRIBUTED_MATRIX_BLOCK_STORAGE_TYPE.AND. &
                        & JACOBIAN_MATRIX%STORAGE_TYPE/=DISTRIBUTED_MATRIX_DIAGONAL_STORAGE_TYPE) THEN
                        CALL CONSTRAINT_JACOBIAN_STRUCTURE_CALCULATE(JACOBIAN_MATRIX,NUMBER_OF_NON_ZEROS, &
                          & ROW_INDICES,COLUMN_INDICES,TRANSPOSE_ROW_INDICES,TRANSPOSE_COLUMN_INDICES,ERR,ERROR,*999)
                        CALL DISTRIBUTED_MATRIX_NUMBER_NON_ZEROS_SET(JACOBIAN_MATRIX%JACOBIAN,NUMBER_OF_NON_ZEROS,ERR,ERROR,*999)
                        CALL DISTRIBUTED_MATRIX_STORAGE_LOCATIONS_SET(JACOBIAN_MATRIX%JACOBIAN,ROW_INDICES,COLUMN_INDICES, &
                          & ERR,ERROR,*999)
                        IF(JACOBIAN_MATRIX%HAS_TRANSPOSE) THEN
                          CALL DISTRIBUTED_MATRIX_NUMBER_NON_ZEROS_SET(JACOBIAN_MATRIX%JACOBIAN_TRANSPOSE,NUMBER_OF_NON_ZEROS, &
                            & ERR,ERROR,*999)
                          CALL DISTRIBUTED_MATRIX_STORAGE_LOCATIONS_SET(JACOBIAN_MATRIX%JACOBIAN_TRANSPOSE,TRANSPOSE_ROW_INDICES, &
                            & TRANSPOSE_COLUMN_INDICES,ERR,ERROR,*999)
                        ENDIF
                        IF(ASSOCIATED(ROW_INDICES)) DEALLOCATE(ROW_INDICES)
                        IF(ASSOCIATED(COLUMN_INDICES)) DEALLOCATE(COLUMN_INDICES)
                        IF(ASSOCIATED(TRANSPOSE_ROW_INDICES)) DEALLOCATE(TRANSPOSE_ROW_INDICES)
                        IF(ASSOCIATED(TRANSPOSE_COLUMN_INDICES)) DEALLOCATE(TRANSPOSE_COLUMN_INDICES)
                      ENDIF
                      CALL DISTRIBUTED_MATRIX_CREATE_FINISH(JACOBIAN_MATRIX%JACOBIAN,ERR,ERROR,*999)
                      IF(JACOBIAN_MATRIX%HAS_TRANSPOSE) THEN
                        CALL DISTRIBUTED_MATRIX_CREATE_FINISH(JACOBIAN_MATRIX%JACOBIAN_TRANSPOSE,ERR,ERROR,*999)
                      ENDIF
                    ELSE
                      CALL FLAG_ERROR("Row domain map is not associated.",ERR,ERROR,*999)
                    ENDIF
                  ELSE
                    LOCAL_ERROR="Jacobian matrix number "//TRIM(NUMBER_TO_VSTRING(matrix_idx,"*",ERR,ERROR))//" is not associated."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ENDDO
                !Set up the residual vector                
                CALL DISTRIBUTED_VECTOR_CREATE_START(COLUMN_DOMAIN_MAP,CONSTRAINT_MATRICES% &
                  & NONLINEAR_MATRICES%RESIDUAL,ERR,ERROR,*999)
                CALL DISTRIBUTED_VECTOR_DATA_TYPE_SET(NONLINEAR_MATRICES%RESIDUAL,MATRIX_VECTOR_DP_TYPE,ERR,ERROR,*999)
                CALL DISTRIBUTED_VECTOR_CREATE_FINISH(NONLINEAR_MATRICES%RESIDUAL,ERR,ERROR,*999)
                !Initialise the residual vector to zero for time dependent problems so that the previous residual is set to zero
                CALL DISTRIBUTED_VECTOR_ALL_VALUES_SET(NONLINEAR_MATRICES%RESIDUAL,0.0_DP,ERR,ERROR,*999)
              ELSE
                CALL FLAG_ERROR("Constraint mapping nonlinear mapping is not associated.",ERR,ERROR,*999)
              ENDIF
            ENDIF
            RHS_VECTOR=>CONSTRAINT_MATRICES%RHS_VECTOR
            IF(ASSOCIATED(RHS_VECTOR)) THEN
              !Set up the equations RHS vector          
              CALL DISTRIBUTED_VECTOR_CREATE_START(COLUMN_DOMAIN_MAP,CONSTRAINT_MATRICES%RHS_VECTOR%RHS_VECTOR,ERR,ERROR,*999)
              CALL DISTRIBUTED_VECTOR_DATA_TYPE_SET(RHS_VECTOR%RHS_VECTOR,MATRIX_VECTOR_DP_TYPE,ERR,ERROR,*999)
              CALL DISTRIBUTED_VECTOR_CREATE_FINISH(RHS_VECTOR%RHS_VECTOR,ERR,ERROR,*999)
            ENDIF
            !Finish up
            CONSTRAINT_MATRICES%CONSTRAINT_MATRICES_FINISHED=.TRUE.
          ELSE
            CALL FLAG_ERROR("Row domain map is not associated.",ERR,ERROR,*999)
          ENDIF
        ELSE
          CALL FLAG_ERROR("Constraint mapping is not associated.",ERR,ERROR,*998)
        ENDIF
      ENDIF
    ELSE
      CALL FLAG_ERROR("Constraint matrices is not associated.",ERR,ERROR,*998)
    ENDIF
       
    CALL EXITS("CONSTRAINT_MATRICES_CREATE_FINISH")
    RETURN
999 IF(ASSOCIATED(ROW_INDICES)) DEALLOCATE(ROW_INDICES)
    IF(ASSOCIATED(COLUMN_INDICES)) DEALLOCATE(COLUMN_INDICES)
    IF(ASSOCIATED(TRANSPOSE_ROW_INDICES)) DEALLOCATE(TRANSPOSE_ROW_INDICES)
    IF(ASSOCIATED(TRANSPOSE_COLUMN_INDICES)) DEALLOCATE(TRANSPOSE_COLUMN_INDICES)
    CALL CONSTRAINT_MATRICES_FINALISE(CONSTRAINT_MATRICES,DUMMY_ERR,DUMMY_ERROR,*998)
998 CALL ERRORS("CONSTRAINT_MATRICES_CREATE_FINISH",ERR,ERROR)
    CALL EXITS("CONSTRAINT_MATRICES_CREATE_FINISH")
    RETURN 1
  END SUBROUTINE CONSTRAINT_MATRICES_CREATE_FINISH

  !
  !================================================================================================================================
  !

  !>Starts the creation of the constraint matrices and rhs for the constraint equations.
  SUBROUTINE CONSTRAINT_MATRICES_CREATE_START(CONSTRAINT_EQUATIONS,CONSTRAINT_MATRICES,ERR,ERROR,*)

    !Argument variables
    TYPE(CONSTRAINT_EQUATIONS_TYPE), POINTER :: CONSTRAINT_EQUATIONS !<The pointer to the constraint equations to create the constraint matrices for
    TYPE(CONSTRAINT_MATRICES_TYPE), POINTER :: CONSTRAINT_MATRICES !<On return, a pointer to the constraint matrices being created.
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string  
    !Local Variables
    INTEGER(INTG) :: DUMMY_ERR
    TYPE(VARYING_STRING) :: DUMMY_ERROR    

    CALL ENTERS("CONSTRAINT_MATRICES_CREATE_START",ERR,ERROR,*998)

    IF(ASSOCIATED(CONSTRAINT_EQUATIONS)) THEN      
      IF(CONSTRAINT_EQUATIONS%CONSTRAINT_EQUATIONS_FINISHED) THEN
        IF(ASSOCIATED(CONSTRAINT_MATRICES)) THEN
          CALL FLAG_ERROR("Constraint matrices is already associated.",ERR,ERROR,*998)
        ELSE
          NULLIFY(CONSTRAINT_MATRICES)
          !Initialise the constraint matrices
          CALL CONSTRAINT_MATRICES_INITIALISE(CONSTRAINT_EQUATIONS,ERR,ERROR,*999)
          CONSTRAINT_MATRICES=>CONSTRAINT_EQUATIONS%CONSTRAINT_MATRICES
        ENDIF
      ELSE
        CALL FLAG_ERROR("Equations has not been finished.",ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Equations is not associated.",ERR,ERROR,*998)
    ENDIF
    
    CALL EXITS("CONSTRAINT_MATRICES_CREATE_START")
    RETURN
999 CALL CONSTRAINT_MATRICES_FINALISE(CONSTRAINT_EQUATIONS%CONSTRAINT_MATRICES,DUMMY_ERR,DUMMY_ERROR,*998)
998 CALL ERRORS("CONSTRAINT_MATRICES_CREATE_START",ERR,ERROR)
    CALL EXITS("CONSTRAINT_MATRICES_CREATE_START")
    RETURN 1
  END SUBROUTINE CONSTRAINT_MATRICES_CREATE_START

  !
  !================================================================================================================================
  !

  !>Destroy the constraint matrices
  SUBROUTINE CONSTRAINT_MATRICES_DESTROY(CONSTRAINT_MATRICES,ERR,ERROR,*)

    !Argument variables
    TYPE(CONSTRAINT_MATRICES_TYPE), POINTER :: CONSTRAINT_MATRICES !<A pointer the constraint matrices to destroy
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables

    CALL ENTERS("CONSTRAINT_MATRICES_DESTROY",ERR,ERROR,*999)

    IF(ASSOCIATED(CONSTRAINT_MATRICES)) THEN
      CALL CONSTRAINT_MATRICES_FINALISE(CONSTRAINT_MATRICES,ERR,ERROR,*999)
    ELSE
      CALL FLAG_ERROR("Constraint matrices is not associated",ERR,ERROR,*999)
    ENDIF
        
    CALL EXITS("CONSTRAINT_MATRICES_DESTROY")
    RETURN
999 CALL ERRORS("CONSTRAINT_MATRICES_DESTROY",ERR,ERROR)    
    CALL EXITS("CONSTRAINT_MATRICES_DESTROY")
    RETURN 1
   
  END SUBROUTINE CONSTRAINT_MATRICES_DESTROY

  !
  !================================================================================================================================
  !

  !>Calculate the positions in the constraint matrices of the element matrix. Old CMISS name MELGE.
  SUBROUTINE CONSTRAINT_MATRICES_ELEMENT_MATRIX_CALCULATE(ELEMENT_MATRIX,UPDATE_MATRIX,hasTranspose, &
      & ROW_ELEMENT_NUMBERS,COLUMN_ELEMENT_NUMBERS,ROWS_FIELD_VARIABLE,COLS_FIELD_VARIABLE,ERR,ERROR,*)

    !Argument variables
    TYPE(ELEMENT_MATRIX_TYPE) :: ELEMENT_MATRIX !<The element matrix to calculate
    LOGICAL, INTENT(IN) :: UPDATE_MATRIX !<Is .TRUE. if the element matrix is to be updated, .FALSE. if not.
    LOGICAL, INTENT(IN) :: hasTranspose !<Is .TRUE. if the element matrix has a transpose, .FALSE. if not.
    INTEGER(INTG), INTENT(IN) :: ROW_ELEMENT_NUMBERS(:) !<The row element number to calculate
    INTEGER(INTG), INTENT(IN) :: COLUMN_ELEMENT_NUMBERS(:) !<The column element number to calculate
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: ROWS_FIELD_VARIABLE !<A pointer to the field variable associated with the rows
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: COLS_FIELD_VARIABLE !<A pointer to the field variable associated with the columns
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: component_idx,derivative,derivative_idx,global_ny,local_ny,node,node_idx,version,dataPointIdx, &
      & localDataPointNumber,elementIdx,rowElementNumber,colElementNumber
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(DOMAIN_ELEMENTS_TYPE), POINTER :: ELEMENTS_TOPOLOGY
    TYPE(DecompositionDataPointsType), POINTER :: decompositionData
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CONSTRAINT_MATRICES_ELEMENT_MATRIX_CALCULATE",ERR,ERROR,*999)

    IF(ASSOCIATED(ROWS_FIELD_VARIABLE)) THEN
      IF(ASSOCIATED(COLS_FIELD_VARIABLE)) THEN
        ELEMENT_MATRIX%NUMBER_OF_ROWS=0
        ELEMENT_MATRIX%NUMBER_OF_COLUMNS=0
        ELEMENT_MATRIX%NUMBER_OF_TRANSPOSE_ROWS=0
        ELEMENT_MATRIX%NUMBER_OF_TRANSPOSE_COLUMNS=0
        IF(UPDATE_MATRIX) THEN
          IF(ASSOCIATED(ROWS_FIELD_VARIABLE,COLS_FIELD_VARIABLE)) THEN
            !Row and columns variable is the same.
            DO component_idx=1,ROWS_FIELD_VARIABLE%NUMBER_OF_COMPONENTS
              ELEMENTS_TOPOLOGY=>ROWS_FIELD_VARIABLE%COMPONENTS(component_idx)%DOMAIN%TOPOLOGY%ELEMENTS
              DO elementIdx=1,SIZE(ROW_ELEMENT_NUMBERS)
                rowElementNumber=ROW_ELEMENT_NUMBERS(elementIdx)
                IF(rowElementNumber>=1.AND.rowElementNumber<=ELEMENTS_TOPOLOGY%TOTAL_NUMBER_OF_ELEMENTS) THEN
                  SELECT CASE(ROWS_FIELD_VARIABLE%COMPONENTS(component_idx)%INTERPOLATION_TYPE)
                  CASE(FIELD_CONSTANT_INTERPOLATION)
                    local_ny=ROWS_FIELD_VARIABLE%COMPONENTS(component_idx)%PARAM_TO_DOF_MAP%CONSTANT_PARAM2DOF_MAP
                    global_ny=ROWS_FIELD_VARIABLE%DOMAIN_MAPPING%LOCAL_TO_GLOBAL_MAP(local_ny)
                    ELEMENT_MATRIX%NUMBER_OF_ROWS=ELEMENT_MATRIX%NUMBER_OF_ROWS+1
                    ELEMENT_MATRIX%NUMBER_OF_COLUMNS=ELEMENT_MATRIX%NUMBER_OF_COLUMNS+1
                    ELEMENT_MATRIX%ROW_DOFS(ELEMENT_MATRIX%NUMBER_OF_ROWS)=local_ny
                    ELEMENT_MATRIX%COLUMN_DOFS(ELEMENT_MATRIX%NUMBER_OF_COLUMNS)=global_ny
                  CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                    local_ny=ROWS_FIELD_VARIABLE%COMPONENTS(component_idx)%PARAM_TO_DOF_MAP%ELEMENT_PARAM2DOF_MAP% &
                      & ELEMENTS(rowElementNumber)
                    global_ny=ROWS_FIELD_VARIABLE%DOMAIN_MAPPING%LOCAL_TO_GLOBAL_MAP(local_ny)
                    ELEMENT_MATRIX%NUMBER_OF_ROWS=ELEMENT_MATRIX%NUMBER_OF_ROWS+1
                    ELEMENT_MATRIX%NUMBER_OF_COLUMNS=ELEMENT_MATRIX%NUMBER_OF_COLUMNS+1
                    ELEMENT_MATRIX%ROW_DOFS(ELEMENT_MATRIX%NUMBER_OF_ROWS)=local_ny
                    ELEMENT_MATRIX%COLUMN_DOFS(ELEMENT_MATRIX%NUMBER_OF_COLUMNS)=global_ny
                  CASE(FIELD_NODE_BASED_INTERPOLATION)
                    BASIS=>ELEMENTS_TOPOLOGY%ELEMENTS(rowElementNumber)%BASIS
                    DO node_idx=1,BASIS%NUMBER_OF_NODES
                      node=ELEMENTS_TOPOLOGY%ELEMENTS(rowElementNumber)%ELEMENT_NODES(node_idx)
                      DO derivative_idx=1,BASIS%NUMBER_OF_DERIVATIVES(node_idx)
                        derivative=ELEMENTS_TOPOLOGY%ELEMENTS(rowElementNumber)%ELEMENT_DERIVATIVES(derivative_idx,node_idx)
                        version=ELEMENTS_TOPOLOGY%ELEMENTS(rowElementNumber)%elementVersions(derivative_idx,node_idx)
                        local_ny=ROWS_FIELD_VARIABLE%COMPONENTS(component_idx)%PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NODES(node)% &
                          & DERIVATIVES(derivative)%VERSIONS(version)
                        global_ny=ROWS_FIELD_VARIABLE%DOMAIN_MAPPING%LOCAL_TO_GLOBAL_MAP(local_ny)
                        ELEMENT_MATRIX%NUMBER_OF_ROWS=ELEMENT_MATRIX%NUMBER_OF_ROWS+1
                        ELEMENT_MATRIX%NUMBER_OF_COLUMNS=ELEMENT_MATRIX%NUMBER_OF_COLUMNS+1
                        ELEMENT_MATRIX%ROW_DOFS(ELEMENT_MATRIX%NUMBER_OF_ROWS)=local_ny
                        ELEMENT_MATRIX%COLUMN_DOFS(ELEMENT_MATRIX%NUMBER_OF_COLUMNS)=global_ny
                      ENDDO !derivative_idx
                    ENDDO !node_idx
                  CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                    CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
                  CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                    CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
                  CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                    decompositionData=>ROWS_FIELD_VARIABLE%COMPONENTS(component_idx)%DOMAIN%DECOMPOSITION%TOPOLOGY%dataPoints
                    DO dataPointIdx=1,decompositionData%elementDataPoint(rowElementNumber)%numberOfProjectedData
                      localDataPointNumber=decompositionData%elementDataPoint(rowElementNumber)% &
                        & dataIndices(dataPointIdx)%localNumber
                      local_ny=ROWS_FIELD_VARIABLE%COMPONENTS(component_idx)%PARAM_TO_DOF_MAP%DATA_POINT_PARAM2DOF_MAP% &
                        & DATA_POINTS(localDataPointNumber)
                      global_ny=ROWS_FIELD_VARIABLE%DOMAIN_MAPPING%LOCAL_TO_GLOBAL_MAP(local_ny)
                      ELEMENT_MATRIX%NUMBER_OF_ROWS=ELEMENT_MATRIX%NUMBER_OF_ROWS+1
                      ELEMENT_MATRIX%NUMBER_OF_COLUMNS=ELEMENT_MATRIX%NUMBER_OF_COLUMNS+1
                      ELEMENT_MATRIX%ROW_DOFS(ELEMENT_MATRIX%NUMBER_OF_ROWS)=local_ny
                      ELEMENT_MATRIX%COLUMN_DOFS(ELEMENT_MATRIX%NUMBER_OF_COLUMNS)=global_ny
                    ENDDO
                  CASE DEFAULT
                    LOCAL_ERROR="The interpolation type of "// &
                      & TRIM(NUMBER_TO_VSTRING(ROWS_FIELD_VARIABLE%COMPONENTS(component_idx)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                      & " is invalid for component number "// &
                      & TRIM(NUMBER_TO_VSTRING(component_idx,"*",ERR,ERROR))// &
                      & " of rows field variable type "// &
                      & TRIM(NUMBER_TO_VSTRING(ROWS_FIELD_VARIABLE%VARIABLE_TYPE,"*",ERR,ERROR))//"."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)          
                  END SELECT
                ELSE
                  LOCAL_ERROR="Element number "//TRIM(NUMBER_TO_VSTRING(rowElementNumber,"*",ERR,ERROR))// &
                    & " is invalid for component number "//TRIM(NUMBER_TO_VSTRING(component_idx,"*",ERR,ERROR))// &
                    & " of rows field variable type "// &
                    & TRIM(NUMBER_TO_VSTRING(ROWS_FIELD_VARIABLE%VARIABLE_TYPE,"*",ERR,ERROR))// &
                    & ". The element number must be between 1 and "// &
                    & TRIM(NUMBER_TO_VSTRING(ELEMENTS_TOPOLOGY%TOTAL_NUMBER_OF_ELEMENTS,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ENDDO !elementIdx
            ENDDO !component_idx
          ELSE
            !Row and column variables are different
            !Row mapping
            DO component_idx=1,ROWS_FIELD_VARIABLE%NUMBER_OF_COMPONENTS
              ELEMENTS_TOPOLOGY=>ROWS_FIELD_VARIABLE%COMPONENTS(component_idx)%DOMAIN%TOPOLOGY%ELEMENTS
              DO elementIdx=1,SIZE(ROW_ELEMENT_NUMBERS)
                rowElementNumber=ROW_ELEMENT_NUMBERS(elementIdx)
                IF(rowElementNumber>=1.AND.rowElementNumber<=ELEMENTS_TOPOLOGY%TOTAL_NUMBER_OF_ELEMENTS) THEN
                  SELECT CASE(ROWS_FIELD_VARIABLE%COMPONENTS(component_idx)%INTERPOLATION_TYPE)
                  CASE(FIELD_CONSTANT_INTERPOLATION)
                    local_ny=ROWS_FIELD_VARIABLE%COMPONENTS(component_idx)%PARAM_TO_DOF_MAP%CONSTANT_PARAM2DOF_MAP
                    ELEMENT_MATRIX%NUMBER_OF_ROWS=ELEMENT_MATRIX%NUMBER_OF_ROWS+1
                    ELEMENT_MATRIX%ROW_DOFS(ELEMENT_MATRIX%NUMBER_OF_ROWS)=local_ny
                    IF(hasTranspose) THEN
                      ELEMENT_MATRIX%NUMBER_OF_TRANSPOSE_COLUMNS=ELEMENT_MATRIX%NUMBER_OF_TRANSPOSE_COLUMNS+1
                      global_ny=ROWS_FIELD_VARIABLE%DOMAIN_MAPPING%LOCAL_TO_GLOBAL_MAP(local_ny)
                      ELEMENT_MATRIX%TRANSPOSE_COLUMN_DOFS(ELEMENT_MATRIX%NUMBER_OF_TRANSPOSE_COLUMNS)=global_ny
                    END IF
                  CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                    local_ny=ROWS_FIELD_VARIABLE%COMPONENTS(component_idx)%PARAM_TO_DOF_MAP%ELEMENT_PARAM2DOF_MAP% &
                      & ELEMENTS(rowElementNumber)
                    ELEMENT_MATRIX%NUMBER_OF_ROWS=ELEMENT_MATRIX%NUMBER_OF_ROWS+1
                    ELEMENT_MATRIX%ROW_DOFS(ELEMENT_MATRIX%NUMBER_OF_ROWS)=local_ny
                    IF(hasTranspose) THEN
                      ELEMENT_MATRIX%NUMBER_OF_TRANSPOSE_COLUMNS=ELEMENT_MATRIX%NUMBER_OF_TRANSPOSE_COLUMNS+1
                      global_ny=ROWS_FIELD_VARIABLE%DOMAIN_MAPPING%LOCAL_TO_GLOBAL_MAP(local_ny)
                      ELEMENT_MATRIX%TRANSPOSE_COLUMN_DOFS(ELEMENT_MATRIX%NUMBER_OF_TRANSPOSE_COLUMNS)=global_ny
                    END IF
                  CASE(FIELD_NODE_BASED_INTERPOLATION)
                    BASIS=>ELEMENTS_TOPOLOGY%ELEMENTS(rowElementNumber)%BASIS
                    DO node_idx=1,BASIS%NUMBER_OF_NODES
                      node=ELEMENTS_TOPOLOGY%ELEMENTS(rowElementNumber)%ELEMENT_NODES(node_idx)
                      DO derivative_idx=1,BASIS%NUMBER_OF_DERIVATIVES(node_idx)
                        derivative=ELEMENTS_TOPOLOGY%ELEMENTS(rowElementNumber)%ELEMENT_DERIVATIVES(derivative_idx,node_idx)
                        version=ELEMENTS_TOPOLOGY%ELEMENTS(rowElementNumber)%elementVersions(derivative_idx,node_idx)
                        local_ny=ROWS_FIELD_VARIABLE%COMPONENTS(component_idx)%PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NODES(node)% &
                          & DERIVATIVES(derivative)%VERSIONS(version)
                        ELEMENT_MATRIX%NUMBER_OF_ROWS=ELEMENT_MATRIX%NUMBER_OF_ROWS+1
                        ELEMENT_MATRIX%ROW_DOFS(ELEMENT_MATRIX%NUMBER_OF_ROWS)=local_ny
                        IF(hasTranspose) THEN
                          ELEMENT_MATRIX%NUMBER_OF_TRANSPOSE_COLUMNS=ELEMENT_MATRIX%NUMBER_OF_TRANSPOSE_COLUMNS+1
                          global_ny=ROWS_FIELD_VARIABLE%DOMAIN_MAPPING%LOCAL_TO_GLOBAL_MAP(local_ny)
                          ELEMENT_MATRIX%TRANSPOSE_COLUMN_DOFS(ELEMENT_MATRIX%NUMBER_OF_TRANSPOSE_COLUMNS)=global_ny
                        END IF
                      ENDDO !derivative_idx
                    ENDDO !node_idx
                  CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                    CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
                  CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                    CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
                  CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                    decompositionData=>ROWS_FIELD_VARIABLE%COMPONENTS(component_idx)%DOMAIN%DECOMPOSITION%TOPOLOGY%dataPoints
                    DO dataPointIdx=1,decompositionData%elementDataPoint(colElementNumber)%numberOfProjectedData
                      localDataPointNumber=decompositionData%elementDataPoint(colElementNumber)% &
                        & dataIndices(dataPointIdx)%localNumber
                      local_ny=ROWS_FIELD_VARIABLE%COMPONENTS(component_idx)%PARAM_TO_DOF_MAP%DATA_POINT_PARAM2DOF_MAP% &
                        & DATA_POINTS(localDataPointNumber)
                      ELEMENT_MATRIX%NUMBER_OF_ROWS=ELEMENT_MATRIX%NUMBER_OF_COLUMNS+1
                      ELEMENT_MATRIX%ROW_DOFS(ELEMENT_MATRIX%NUMBER_OF_COLUMNS)=local_ny
                      IF(hasTranspose) THEN
                        ELEMENT_MATRIX%NUMBER_OF_TRANSPOSE_COLUMNS=ELEMENT_MATRIX%NUMBER_OF_TRANSPOSE_COLUMNS+1
                        global_ny=ROWS_FIELD_VARIABLE%DOMAIN_MAPPING%LOCAL_TO_GLOBAL_MAP(local_ny)
                        ELEMENT_MATRIX%TRANSPOSE_COLUMN_DOFS(ELEMENT_MATRIX%NUMBER_OF_TRANSPOSE_COLUMNS)=global_ny
                      END IF
                    ENDDO
                  CASE DEFAULT
                    LOCAL_ERROR="The interpolation type of "// &
                      & TRIM(NUMBER_TO_VSTRING(ROWS_FIELD_VARIABLE%COMPONENTS(component_idx)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                      & " is invalid for component number "// &
                      & TRIM(NUMBER_TO_VSTRING(component_idx,"*",ERR,ERROR))// &
                      & " of rows field variable type "// &
                      & TRIM(NUMBER_TO_VSTRING(ROWS_FIELD_VARIABLE%VARIABLE_TYPE,"*",ERR,ERROR))//"."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)          
                  END SELECT
                ELSE
                  LOCAL_ERROR="Row element number "//TRIM(NUMBER_TO_VSTRING(rowElementNumber,"*",ERR,ERROR))// &
                    & " is invalid for component number "//TRIM(NUMBER_TO_VSTRING(component_idx,"*",ERR,ERROR))// &
                    & " of rows field variable type "// &
                    & TRIM(NUMBER_TO_VSTRING(ROWS_FIELD_VARIABLE%VARIABLE_TYPE,"*",ERR,ERROR))// &
                    & ". The element number must be between 1 and "// &
                    & TRIM(NUMBER_TO_VSTRING(ELEMENTS_TOPOLOGY%TOTAL_NUMBER_OF_ELEMENTS,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ENDDO !elementIdx
            ENDDO !component_idx
            !Column mapping
            DO component_idx=1,COLS_FIELD_VARIABLE%NUMBER_OF_COMPONENTS
              ELEMENTS_TOPOLOGY=>COLS_FIELD_VARIABLE%COMPONENTS(component_idx)%DOMAIN%TOPOLOGY%ELEMENTS
              DO elementIdx=1,SIZE(COLUMN_ELEMENT_NUMBERS)
                colElementNumber=COLUMN_ELEMENT_NUMBERS(elementIdx)
                IF(colElementNumber>=1.AND.colElementNumber<=ELEMENTS_TOPOLOGY%TOTAL_NUMBER_OF_ELEMENTS) THEN
                  SELECT CASE(COLS_FIELD_VARIABLE%COMPONENTS(component_idx)%INTERPOLATION_TYPE)
                  CASE(FIELD_CONSTANT_INTERPOLATION)
                    local_ny=COLS_FIELD_VARIABLE%COMPONENTS(component_idx)%PARAM_TO_DOF_MAP%CONSTANT_PARAM2DOF_MAP
                    global_ny=COLS_FIELD_VARIABLE%DOMAIN_MAPPING%LOCAL_TO_GLOBAL_MAP(local_ny)
                    ELEMENT_MATRIX%NUMBER_OF_COLUMNS=ELEMENT_MATRIX%NUMBER_OF_COLUMNS+1
                    ELEMENT_MATRIX%COLUMN_DOFS(ELEMENT_MATRIX%NUMBER_OF_COLUMNS)=global_ny
                    IF(hasTranspose) THEN
                      ELEMENT_MATRIX%NUMBER_OF_TRANSPOSE_ROWS=ELEMENT_MATRIX%NUMBER_OF_TRANSPOSE_ROWS+1
                      ELEMENT_MATRIX%TRANSPOSE_ROW_DOFS(ELEMENT_MATRIX%NUMBER_OF_TRANSPOSE_ROWS)=local_ny
                    END IF
                  CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                    local_ny=COLS_FIELD_VARIABLE%COMPONENTS(component_idx)%PARAM_TO_DOF_MAP%ELEMENT_PARAM2DOF_MAP% &
                      & ELEMENTS(colElementNumber)
                    global_ny=COLS_FIELD_VARIABLE%DOMAIN_MAPPING%LOCAL_TO_GLOBAL_MAP(local_ny)
                    ELEMENT_MATRIX%NUMBER_OF_COLUMNS=ELEMENT_MATRIX%NUMBER_OF_COLUMNS+1
                    ELEMENT_MATRIX%COLUMN_DOFS(ELEMENT_MATRIX%NUMBER_OF_COLUMNS)=global_ny
                    IF(hasTranspose) THEN
                      ELEMENT_MATRIX%NUMBER_OF_TRANSPOSE_ROWS=ELEMENT_MATRIX%NUMBER_OF_TRANSPOSE_ROWS+1
                      ELEMENT_MATRIX%TRANSPOSE_ROW_DOFS(ELEMENT_MATRIX%NUMBER_OF_TRANSPOSE_ROWS)=local_ny
                    END IF
                  CASE(FIELD_NODE_BASED_INTERPOLATION)
                    BASIS=>ELEMENTS_TOPOLOGY%ELEMENTS(colElementNumber)%BASIS
                    DO node_idx=1,BASIS%NUMBER_OF_NODES
                      node=ELEMENTS_TOPOLOGY%ELEMENTS(colElementNumber)%ELEMENT_NODES(node_idx)
                      DO derivative_idx=1,BASIS%NUMBER_OF_DERIVATIVES(node_idx)
                        derivative=ELEMENTS_TOPOLOGY%ELEMENTS(colElementNumber)%ELEMENT_DERIVATIVES(derivative_idx,node_idx)
                        version=ELEMENTS_TOPOLOGY%ELEMENTS(colElementNumber)%elementVersions(derivative_idx,node_idx)
                        local_ny=COLS_FIELD_VARIABLE%COMPONENTS(component_idx)%PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NODES(node)% &
                          & DERIVATIVES(derivative)%VERSIONS(version)
                        global_ny=COLS_FIELD_VARIABLE%DOMAIN_MAPPING%LOCAL_TO_GLOBAL_MAP(local_ny)
                        ELEMENT_MATRIX%NUMBER_OF_COLUMNS=ELEMENT_MATRIX%NUMBER_OF_COLUMNS+1
                        ELEMENT_MATRIX%COLUMN_DOFS(ELEMENT_MATRIX%NUMBER_OF_COLUMNS)=global_ny
                        IF(hasTranspose) THEN
                          ELEMENT_MATRIX%NUMBER_OF_TRANSPOSE_ROWS=ELEMENT_MATRIX%NUMBER_OF_TRANSPOSE_ROWS+1
                          ELEMENT_MATRIX%TRANSPOSE_ROW_DOFS(ELEMENT_MATRIX%NUMBER_OF_TRANSPOSE_ROWS)=local_ny
                        END IF
                      ENDDO !derivative_idx
                    ENDDO !node_idx
                  CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                    CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
                  CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                    CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
                  CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                    decompositionData=>COLS_FIELD_VARIABLE%COMPONENTS(component_idx)%DOMAIN%DECOMPOSITION%TOPOLOGY%dataPoints
                    DO dataPointIdx=1,decompositionData%elementDataPoint(colElementNumber)%numberOfProjectedData
                      localDataPointNumber=decompositionData%elementDataPoint(colElementNumber)% &
                        & dataIndices(dataPointIdx)%localNumber
                      local_ny=COLS_FIELD_VARIABLE%COMPONENTS(component_idx)%PARAM_TO_DOF_MAP%DATA_POINT_PARAM2DOF_MAP% &
                        & DATA_POINTS(localDataPointNumber)
                      global_ny=COLS_FIELD_VARIABLE%DOMAIN_MAPPING%LOCAL_TO_GLOBAL_MAP(local_ny)
                      ELEMENT_MATRIX%NUMBER_OF_COLUMNS=ELEMENT_MATRIX%NUMBER_OF_COLUMNS+1
                      ELEMENT_MATRIX%COLUMN_DOFS(ELEMENT_MATRIX%NUMBER_OF_COLUMNS)=global_ny
                      IF(hasTranspose) THEN
                        ELEMENT_MATRIX%NUMBER_OF_TRANSPOSE_ROWS=ELEMENT_MATRIX%NUMBER_OF_TRANSPOSE_ROWS+1
                        ELEMENT_MATRIX%TRANSPOSE_ROW_DOFS(ELEMENT_MATRIX%NUMBER_OF_TRANSPOSE_ROWS)=local_ny
                      END IF
                    ENDDO
                  CASE DEFAULT
                    LOCAL_ERROR="The interpolation type of "// &
                      & TRIM(NUMBER_TO_VSTRING(COLS_FIELD_VARIABLE%COMPONENTS(component_idx)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                      & " is invalid for component number "// &
                      & TRIM(NUMBER_TO_VSTRING(component_idx,"*",ERR,ERROR))// &
                      & " of column field variable type "// &
                      & TRIM(NUMBER_TO_VSTRING(COLS_FIELD_VARIABLE%VARIABLE_TYPE,"*",ERR,ERROR))//"."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)          
                  END SELECT
                ELSE
                  LOCAL_ERROR="Column element number "//TRIM(NUMBER_TO_VSTRING(colElementNumber,"*",ERR,ERROR))// &
                    & " is invalid for component number "//TRIM(NUMBER_TO_VSTRING(component_idx,"*",ERR,ERROR))// &
                    & " of column field variable type "// &
                    & TRIM(NUMBER_TO_VSTRING(COLS_FIELD_VARIABLE%VARIABLE_TYPE,"*",ERR,ERROR))// &
                    & ". The element number must be between 1 and "// &
                    & TRIM(NUMBER_TO_VSTRING(ELEMENTS_TOPOLOGY%TOTAL_NUMBER_OF_ELEMENTS,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ENDDO !elementIdx
            ENDDO !component_idx
          ENDIF
          ELEMENT_MATRIX%MATRIX=0.0_DP
        ENDIF
      ELSE
        CALL FLAG_ERROR("Columns field variable is not associated.",ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Rows field variable is not associated.",ERR,ERROR,*999)
    ENDIF
    
    CALL EXITS("CONSTRAINT_MATRICES_ELEMENT_MATRIX_CALCULATE")
    RETURN
999 CALL ERRORS("CONSTRAINT_MATRICES_ELEMENT_MATRIX_CALCULATE",ERR,ERROR)
    CALL EXITS("CONSTRAINT_MATRICES_ELEMENT_MATRIX_CALCULATE")
    RETURN 1
    
  END SUBROUTINE CONSTRAINT_MATRICES_ELEMENT_MATRIX_CALCULATE

  !
  !================================================================================================================================
  !

  !>Finalise an element matrix and deallocate all memory
  SUBROUTINE CONSTRAINT_MATRICES_ELEMENT_MATRIX_FINALISE(ELEMENT_MATRIX,ERR,ERROR,*)

    !Argument variables
    TYPE(ELEMENT_MATRIX_TYPE):: ELEMENT_MATRIX !<The element matrix to finalise
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    
    CALL ENTERS("CONSTRAINT_MATRICES_ELEMENT_MATRIX_FINALISE",ERR,ERROR,*999)

    ELEMENT_MATRIX%MAX_NUMBER_OF_ROWS=0
    ELEMENT_MATRIX%MAX_NUMBER_OF_COLUMNS=0
    IF(ALLOCATED(ELEMENT_MATRIX%ROW_DOFS)) DEALLOCATE(ELEMENT_MATRIX%ROW_DOFS)
    IF(ALLOCATED(ELEMENT_MATRIX%COLUMN_DOFS)) DEALLOCATE(ELEMENT_MATRIX%COLUMN_DOFS)
    IF(ALLOCATED(ELEMENT_MATRIX%TRANSPOSE_ROW_DOFS)) DEALLOCATE(ELEMENT_MATRIX%TRANSPOSE_ROW_DOFS)
    IF(ALLOCATED(ELEMENT_MATRIX%TRANSPOSE_COLUMN_DOFS)) DEALLOCATE(ELEMENT_MATRIX%TRANSPOSE_COLUMN_DOFS)
    IF(ALLOCATED(ELEMENT_MATRIX%MATRIX)) DEALLOCATE(ELEMENT_MATRIX%MATRIX)
    
    CALL EXITS("CONSTRAINT_MATRICES_ELEMENT_MATRIX_FINALISE")
    RETURN
999 CALL ERRORS("CONSTRAINT_MATRICES_ELEMENT_MATRIX_FINALISE",ERR,ERROR)
    CALL EXITS("CONSTRAINT_MATRICES_ELEMENT_MATRIX_FINALISE")
    RETURN 1
  END SUBROUTINE CONSTRAINT_MATRICES_ELEMENT_MATRIX_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialise the element matrix.
  SUBROUTINE CONSTRAINT_MATRICES_ELEMENT_MATRIX_INITIALISE(ELEMENT_MATRIX,ERR,ERROR,*)

    !Argument variables
    TYPE(ELEMENT_MATRIX_TYPE) :: ELEMENT_MATRIX !The element matrix to initialise
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables

    CALL ENTERS("CONSTRAINT_MATRICES_ELEMENT_MATRIX_INITIALISE",ERR,ERROR,*999)

    ELEMENT_MATRIX%EQUATIONS_MATRIX_NUMBER=0
    ELEMENT_MATRIX%NUMBER_OF_ROWS=0
    ELEMENT_MATRIX%NUMBER_OF_COLUMNS=0
    ELEMENT_MATRIX%NUMBER_OF_TRANSPOSE_ROWS=0
    ELEMENT_MATRIX%NUMBER_OF_TRANSPOSE_COLUMNS=0
    ELEMENT_MATRIX%MAX_NUMBER_OF_ROWS=0
    ELEMENT_MATRIX%MAX_NUMBER_OF_COLUMNS=0
       
    CALL EXITS("CONSTRAINT_MATRICES_ELEMENT_MATRIX_INITIALISE")
    RETURN
999 CALL ERRORS("CONSTRAINT_MATRICES_ELEMENT_MATRIX_INITIALISE",ERR,ERROR)
    CALL EXITS("CONSTRAINT_MATRICES_ELEMENT_MATRIX_INITIALISE")
    RETURN 1
  END SUBROUTINE CONSTRAINT_MATRICES_ELEMENT_MATRIX_INITIALISE

  !
  !================================================================================================================================
  !

  !>Sets up the element matrix for the row and column field variables.
  SUBROUTINE CONSTRAINT_MATRICES_ELEMENT_MATRIX_SETUP(elementMatrix,rowsFieldVariable,columnsFieldVariable, &
    & rowsNumberOfElements,colsNumberOfElements,hasTranspose,err,error,*)

    !Argument variables
    TYPE(ELEMENT_MATRIX_TYPE) :: elementMatrix !<The element matrix to setup
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: rowsFieldVariable !<A pointer to the field variable associated with the rows
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: columnsFieldVariable !<A pointer to the field variable associated with the columns
    INTEGER(INTG), INTENT(IN)  :: rowsNumberOfElements !<Number of elements in the row variables whose dofs are present in this element matrix
    INTEGER(INTG), INTENT(IN)  :: colsNumberOfElements !<Number of elements in the col variables whose dofs are present in this element matrix
    LOGICAL, INTENT(IN) :: hasTranspose !<The element matrix has a transpose
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dummyErr, componentIdx
    TYPE(VARYING_STRING) :: dummyError

    CALL ENTERS("CONSTRAINT_MATRICES_ELEMENT_MATRIX_SETUP",err,error,*998)

    IF(ASSOCIATED(rowsFieldVariable)) THEN
      IF(ASSOCIATED(columnsFieldVariable)) THEN
        elementMatrix%MAX_NUMBER_OF_ROWS = 0
        DO componentIdx=1,rowsFieldVariable%NUMBER_OF_COMPONENTS
          elementMatrix%MAX_NUMBER_OF_ROWS=elementMatrix%MAX_NUMBER_OF_ROWS+ &
            & rowsFieldVariable%COMPONENTS(componentIdx)%maxNumberElementInterpolationParameters
        ENDDO
        elementMatrix%MAX_NUMBER_OF_ROWS=elementMatrix%MAX_NUMBER_OF_ROWS*rowsNumberOfElements
        elementMatrix%MAX_NUMBER_OF_COLUMNS = 0
        DO componentIdx=1,columnsFieldVariable%NUMBER_OF_COMPONENTS
          elementMatrix%MAX_NUMBER_OF_COLUMNS=elementMatrix%MAX_NUMBER_OF_COLUMNS+ &
            & columnsFieldVariable%COMPONENTS(componentIdx)%maxNumberElementInterpolationParameters
        ENDDO
        elementMatrix%MAX_NUMBER_OF_COLUMNS=elementMatrix%MAX_NUMBER_OF_COLUMNS*colsNumberOfElements
        IF(ALLOCATED(elementMatrix%ROW_DOFS)) THEN
          CALL FLAG_ERROR("Element matrix row dofs already allocated.",err,error,*999)
        ELSE
          ALLOCATE(elementMatrix%ROW_DOFS(elementMatrix%MAX_NUMBER_OF_ROWS),STAT=err)
          IF(ERR/=0) CALL FLAG_ERROR("Could not allocate element matrix row dofs.",err,error,*999)
        ENDIF
        IF(ALLOCATED(elementMatrix%COLUMN_DOFS)) THEN
          CALL FLAG_ERROR("Element matrix column dofs already allocated.",err,error,*999)
        ELSE
          ALLOCATE(elementMatrix%COLUMN_DOFS(elementMatrix%MAX_NUMBER_OF_COLUMNS),STAT=err)
          IF(ERR/=0) CALL FLAG_ERROR("Could not allocate element matrix column dofs.",err,error,*999)
        ENDIF
        IF(hasTranspose) THEN
          IF(ALLOCATED(elementMatrix%TRANSPOSE_ROW_DOFS)) THEN
            CALL FLAG_ERROR("Element matrix transpose row dofs already allocated.",err,error,*999)
          ELSE
            ALLOCATE(elementMatrix%TRANSPOSE_ROW_DOFS(elementMatrix%MAX_NUMBER_OF_COLUMNS),STAT=err)
            IF(ERR/=0) CALL FLAG_ERROR("Could not allocate transpose element matrix row dofs.",err,error,*999)
          ENDIF
          IF(ALLOCATED(elementMatrix%TRANSPOSE_COLUMN_DOFS)) THEN
            CALL FLAG_ERROR("Element matrix column dofs already allocated.",err,error,*999)
          ELSE
            ALLOCATE(elementMatrix%TRANSPOSE_COLUMN_DOFS(elementMatrix%MAX_NUMBER_OF_ROWS),STAT=err)
            IF(ERR/=0) CALL FLAG_ERROR("Could not allocate transpose element matrix column dofs.",err,error,*999)
          ENDIF
        END IF
        IF(ALLOCATED(elementMatrix%MATRIX)) THEN
          CALL FLAG_ERROR("Element matrix already allocated.",err,error,*999)
        ELSE
          ALLOCATE(elementMatrix%MATRIX(elementMatrix%MAX_NUMBER_OF_ROWS,elementMatrix%MAX_NUMBER_OF_COLUMNS),STAT=err)
          IF(ERR/=0) CALL FLAG_ERROR("Could not allocate element matrix.",err,error,*999)
        ENDIF
      ELSE
        CALL FLAG_ERROR("Columns field variable is not associated.",err,error,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Rows field variable is not associated.",err,error,*999)
    ENDIF
    
    CALL EXITS("CONSTRAINT_MATRICES_ELEMENT_MATRIX_SETUP")
    RETURN
999 CALL CONSTRAINT_MATRICES_ELEMENT_MATRIX_FINALISE(elementMatrix,dummyErr,dummyError,*998)
998 CALL ERRORS("CONSTRAINT_MATRICES_ELEMENT_MATRIX_SETUP",err,error)
    CALL EXITS("CONSTRAINT_MATRICES_ELEMENT_MATRIX_SETUP")
    RETURN 1
  END SUBROUTINE CONSTRAINT_MATRICES_ELEMENT_MATRIX_SETUP

  !
  !================================================================================================================================
  !

  !>Calculate the positions in the equations rhs of the element rhs vector. Old CMISS name MELGE.
  SUBROUTINE CONSTRAINT_MATRICES_ELEMENT_VECTOR_CALCULATE(ELEMENT_VECTOR,UPDATE_VECTOR,ELEMENT_NUMBER,ROWS_FIELD_VARIABLE, &
    & ERR,ERROR,*)

    !Argument variables
    TYPE(ELEMENT_VECTOR_TYPE) :: ELEMENT_VECTOR !<The element vector to calculate.
    LOGICAL :: UPDATE_VECTOR !<Is .TRUE. if the element vector is to be updated, .FALSE. if not.
    INTEGER(INTG), INTENT(IN) :: ELEMENT_NUMBER !<The element number to calculate
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: ROWS_FIELD_VARIABLE !<A pointer to the field variable associated with the rows
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: component_idx,derivative,derivative_idx,local_ny,node,node_idx,version,dataPointIdx,localDataPointNumber
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(DOMAIN_ELEMENTS_TYPE), POINTER :: ELEMENTS_TOPOLOGY
    TYPE(DecompositionDataPointsType), POINTER :: decompositionData
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CONSTRAINT_MATRICES_ELEMENT_VECTOR_CALCULATE",ERR,ERROR,*999)

    IF(ASSOCIATED(ROWS_FIELD_VARIABLE)) THEN
      !Calculate the rows for the element vector
      ELEMENT_VECTOR%NUMBER_OF_ROWS=0
      IF(UPDATE_VECTOR) THEN
        DO component_idx=1,ROWS_FIELD_VARIABLE%NUMBER_OF_COMPONENTS
          ELEMENTS_TOPOLOGY=>ROWS_FIELD_VARIABLE%COMPONENTS(component_idx)%DOMAIN%TOPOLOGY%ELEMENTS
          IF(ELEMENT_NUMBER>=1.AND.ELEMENT_NUMBER<=ELEMENTS_TOPOLOGY%TOTAL_NUMBER_OF_ELEMENTS) THEN
            SELECT CASE(ROWS_FIELD_VARIABLE%COMPONENTS(component_idx)%INTERPOLATION_TYPE)
            CASE(FIELD_CONSTANT_INTERPOLATION)
              local_ny=ROWS_FIELD_VARIABLE%COMPONENTS(component_idx)%PARAM_TO_DOF_MAP%CONSTANT_PARAM2DOF_MAP
              ELEMENT_VECTOR%NUMBER_OF_ROWS=ELEMENT_VECTOR%NUMBER_OF_ROWS+1
              ELEMENT_VECTOR%ROW_DOFS(ELEMENT_VECTOR%NUMBER_OF_ROWS)=local_ny
            CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
              local_ny=ROWS_FIELD_VARIABLE%COMPONENTS(component_idx)%PARAM_TO_DOF_MAP%ELEMENT_PARAM2DOF_MAP% &
                & ELEMENTS(ELEMENT_NUMBER)
              ELEMENT_VECTOR%NUMBER_OF_ROWS=ELEMENT_VECTOR%NUMBER_OF_ROWS+1
              ELEMENT_VECTOR%ROW_DOFS(ELEMENT_VECTOR%NUMBER_OF_ROWS)=local_ny
            CASE(FIELD_NODE_BASED_INTERPOLATION)
              BASIS=>ELEMENTS_TOPOLOGY%ELEMENTS(ELEMENT_NUMBER)%BASIS
              DO node_idx=1,BASIS%NUMBER_OF_NODES
                node=ELEMENTS_TOPOLOGY%ELEMENTS(ELEMENT_NUMBER)%ELEMENT_NODES(node_idx)
                DO derivative_idx=1,BASIS%NUMBER_OF_DERIVATIVES(node_idx)
                  derivative=ELEMENTS_TOPOLOGY%ELEMENTS(ELEMENT_NUMBER)%ELEMENT_DERIVATIVES(derivative_idx,node_idx)
                  version=ELEMENTS_TOPOLOGY%ELEMENTS(ELEMENT_NUMBER)%elementVersions(derivative_idx,node_idx)
                  local_ny=ROWS_FIELD_VARIABLE%COMPONENTS(component_idx)%PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NODES(node)% &
                    & DERIVATIVES(derivative)%VERSIONS(version)
                  ELEMENT_VECTOR%NUMBER_OF_ROWS=ELEMENT_VECTOR%NUMBER_OF_ROWS+1
                  ELEMENT_VECTOR%ROW_DOFS(ELEMENT_VECTOR%NUMBER_OF_ROWS)=local_ny
                ENDDO !derivative_idx
              ENDDO !node_idx
            CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
              CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
            CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
              CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
            CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
              decompositionData=>ROWS_FIELD_VARIABLE%COMPONENTS(component_idx)%DOMAIN%DECOMPOSITION%TOPOLOGY%dataPoints
              DO dataPointIdx=1,decompositionData%elementDataPoint(ELEMENT_NUMBER)%numberOfProjectedData
                localDataPointNumber=decompositionData%elementDataPoint(ELEMENT_NUMBER)% &
                  & dataIndices(dataPointIdx)%localNumber
                local_ny=ROWS_FIELD_VARIABLE%COMPONENTS(component_idx)%PARAM_TO_DOF_MAP%DATA_POINT_PARAM2DOF_MAP% &
                  & DATA_POINTS(localDataPointNumber)
                ELEMENT_VECTOR%NUMBER_OF_ROWS=ELEMENT_VECTOR%NUMBER_OF_ROWS+1
                ELEMENT_VECTOR%ROW_DOFS(ELEMENT_VECTOR%NUMBER_OF_ROWS)=local_ny
              ENDDO
            CASE DEFAULT
              LOCAL_ERROR="The interpolation type of "// &
                & TRIM(NUMBER_TO_VSTRING(ROWS_FIELD_VARIABLE%COMPONENTS(component_idx)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                & " is invalid for component number "// &
                & TRIM(NUMBER_TO_VSTRING(component_idx,"*",ERR,ERROR))// &
                & " of rows field variable type "// &
                & TRIM(NUMBER_TO_VSTRING(ROWS_FIELD_VARIABLE%VARIABLE_TYPE,"*",ERR,ERROR))//"."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)          
            END SELECT
          ELSE
            LOCAL_ERROR="Element number "//TRIM(NUMBER_TO_VSTRING(ELEMENT_NUMBER,"*",ERR,ERROR))// &
              & " is invalid for component number "//TRIM(NUMBER_TO_VSTRING(component_idx,"*",ERR,ERROR))// &
              & " of rows field variable type "//TRIM(NUMBER_TO_VSTRING(ROWS_FIELD_VARIABLE%VARIABLE_TYPE,"*",ERR,ERROR))// &
              & ". The element number must be between 1 and "// &
              & TRIM(NUMBER_TO_VSTRING(ELEMENTS_TOPOLOGY%TOTAL_NUMBER_OF_ELEMENTS,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ENDDO !component_idx
        ELEMENT_VECTOR%VECTOR=0.0_DP
      ENDIF
    ELSE
      CALL FLAG_ERROR("Rows field variable is not associated.",ERR,ERROR,*999)
    ENDIF
    
    CALL EXITS("CONSTRAINT_MATRICES_ELEMENT_VECTOR_CALCULATE")
    RETURN
999 CALL ERRORS("CONSTRAINT_MATRICES_ELEMENT_VECTOR_CALCULATE",ERR,ERROR)
    CALL EXITS("CONSTRAINT_MATRICES_ELEMENT_VECTOR_CALCULATE")
    RETURN 1
    
  END SUBROUTINE CONSTRAINT_MATRICES_ELEMENT_VECTOR_CALCULATE

  !
  !================================================================================================================================
  !

  !>Finalise an element vector and deallocate all memory
  SUBROUTINE CONSTRAINT_MATRICES_ELEMENT_VECTOR_FINALISE(ELEMENT_VECTOR,ERR,ERROR,*)

    !Argument variables
    TYPE(ELEMENT_VECTOR_TYPE):: ELEMENT_VECTOR !<The element vector to finalise
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    
    CALL ENTERS("CONSTRAINT_MATRICES_ELEMENT_VECTOR_FINALISE",ERR,ERROR,*999)

    IF(ALLOCATED(ELEMENT_VECTOR%ROW_DOFS)) DEALLOCATE(ELEMENT_VECTOR%ROW_DOFS)
    IF(ALLOCATED(ELEMENT_VECTOR%VECTOR)) DEALLOCATE(ELEMENT_VECTOR%VECTOR)
    
    CALL EXITS("CONSTRAINT_MATRICES_ELEMENT_VECTOR_FINALISE")
    RETURN
999 CALL ERRORS("CONSTRAINT_MATRICES_ELEMENT_VECTOR_FINALISE",ERR,ERROR)
    CALL EXITS("CONSTRAINT_MATRICES_ELEMENT_VECTOR_FINALISE")

    RETURN 1
  END SUBROUTINE CONSTRAINT_MATRICES_ELEMENT_VECTOR_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialise the element vector
  SUBROUTINE CONSTRAINT_MATRICES_ELEMENT_VECTOR_INITIALISE(ELEMENT_VECTOR,ERR,ERROR,*)

    !Argument variables
    TYPE(ELEMENT_VECTOR_TYPE) :: ELEMENT_VECTOR !The element vector to initialise
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables

    CALL ENTERS("CONSTRAINT_MATRICES_ELEMENT_VECTOR_INITIALISE",ERR,ERROR,*999)

    ELEMENT_VECTOR%NUMBER_OF_ROWS=0
    ELEMENT_VECTOR%MAX_NUMBER_OF_ROWS=0
       
    CALL EXITS("CONSTRAINT_MATRICES_ELEMENT_VECTOR_INITIALISE")
    RETURN
999 CALL ERRORS("CONSTRAINT_MATRICES_ELEMENT_VECTOR_INITIALISE",ERR,ERROR)
    CALL EXITS("CONSTRAINT_MATRICES_ELEMENT_VECTOR_INITIALISE")
    RETURN 1
  END SUBROUTINE CONSTRAINT_MATRICES_ELEMENT_VECTOR_INITIALISE

  !
  !================================================================================================================================
  !

  !>Sets up the element vector for the row field variables.
  SUBROUTINE CONSTRAINT_MATRICES_ELEMENT_VECTOR_SETUP(elementVector,rowsFieldVariable,err,error,*)

    !Argument variables
    TYPE(ELEMENT_VECTOR_TYPE) :: elementVector !<The element vector to setup
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: rowsFieldVariable !<A pointer to the field variable associated with the rows
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: DUMMY_ERR,componentIdx
    TYPE(VARYING_STRING) :: dummyError

    CALL ENTERS("CONSTRAINT_MATRICES_ELEMENT_VECTOR_SETUP",err,error,*998)

    IF(ASSOCIATED(rowsFieldVariable)) THEN
      elementVector%MAX_NUMBER_OF_ROWS = 0
      DO componentIdx=1,rowsFieldVariable%NUMBER_OF_COMPONENTS
        elementVector%MAX_NUMBER_OF_ROWS=elementVector%MAX_NUMBER_OF_ROWS+ &
          & rowsFieldVariable%COMPONENTS(componentIdx)%maxNumberElementInterpolationParameters
      ENDDO
      IF(ALLOCATED(elementVector%ROW_DOFS)) THEN
        CALL FLAG_ERROR("Element vector row dofs is already allocated.",err,error,*999)
      ELSE
        ALLOCATE(elementVector%ROW_DOFS(elementVector%MAX_NUMBER_OF_ROWS),STAT=err)
        IF(ERR/=0) CALL FLAG_ERROR("Could not allocate element vector row dofs.",err,error,*999)
      ENDIF
      IF(ALLOCATED(elementVector%VECTOR)) THEN
        CALL FLAG_ERROR("Element vector vector already allocated.",err,error,*999)
      ELSE
        ALLOCATE(elementVector%VECTOR(elementVector%MAX_NUMBER_OF_ROWS),STAT=err)
        IF(ERR/=0) CALL FLAG_ERROR("Could not allocate element vector vector.",err,error,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Rows field variable is not associated.",err,error,*999)
    ENDIF
    
    CALL EXITS("CONSTRAINT_MATRICES_ELEMENT_VECTOR_SETUP")
    RETURN
999 CALL CONSTRAINT_MATRICES_ELEMENT_VECTOR_FINALISE(elementVector,DUMMY_ERR,dummyError,*998)
998 CALL ERRORS("CONSTRAINT_MATRICES_ELEMENT_VECTOR_SETUP",err,error)
    CALL EXITS("CONSTRAINT_MATRICES_ELEMENT_VECTOR_SETUP")
    RETURN 1
  END SUBROUTINE CONSTRAINT_MATRICES_ELEMENT_VECTOR_SETUP

  !
  !================================================================================================================================
  !

  !>Adds the element matrices and rhs vector into the constraint matrices and rhs vector.
  SUBROUTINE CONSTRAINT_MATRICES_ELEMENT_ADD(CONSTRAINT_MATRICES,ERR,ERROR,*)

    !Argument variables
    TYPE(CONSTRAINT_MATRICES_TYPE), POINTER :: CONSTRAINT_MATRICES !<A pointer to the constraint matrices
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: matrix_idx
    TYPE(CONSTRAINT_MATRICES_DYNAMIC_TYPE), POINTER :: DYNAMIC_MATRICES
    TYPE(CONSTRAINT_MATRICES_LINEAR_TYPE), POINTER :: LINEAR_MATRICES
    TYPE(CONSTRAINT_MATRICES_NONLINEAR_TYPE), POINTER :: NONLINEAR_MATRICES
    TYPE(CONSTRAINT_RHS_TYPE), POINTER :: RHS_VECTOR
    TYPE(CONSTRAINT_MATRIX_TYPE), POINTER :: CONSTRAINT_MATRIX
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START("CONSTRAINT_MATRICES_ELEMENT_ADD()")
#endif

    CALL ENTERS("CONSTRAINT_MATRICES_ELEMENT_ADD",ERR,ERROR,*999)

    IF(ASSOCIATED(CONSTRAINT_MATRICES)) THEN
      DYNAMIC_MATRICES=>CONSTRAINT_MATRICES%DYNAMIC_MATRICES
      IF(ASSOCIATED(DYNAMIC_MATRICES)) THEN
        !Add the element matrices
        DO matrix_idx=1,DYNAMIC_MATRICES%NUMBER_OF_DYNAMIC_MATRICES
          CONSTRAINT_MATRIX=>DYNAMIC_MATRICES%MATRICES(matrix_idx)%PTR
          IF(ASSOCIATED(CONSTRAINT_MATRIX)) THEN
            IF(CONSTRAINT_MATRIX%UPDATE_MATRIX) THEN
              !Add the element matrice into the distributed constraint matrix
              CALL DISTRIBUTED_MATRIX_VALUES_ADD(CONSTRAINT_MATRIX%MATRIX,CONSTRAINT_MATRIX%ELEMENT_MATRIX%ROW_DOFS(1: &
                & CONSTRAINT_MATRIX%ELEMENT_MATRIX%NUMBER_OF_ROWS),CONSTRAINT_MATRIX%ELEMENT_MATRIX%COLUMN_DOFS(1: &
                & CONSTRAINT_MATRIX%ELEMENT_MATRIX%NUMBER_OF_COLUMNS),CONSTRAINT_MATRIX%ELEMENT_MATRIX%MATRIX(1: &
                & CONSTRAINT_MATRIX%ELEMENT_MATRIX%NUMBER_OF_ROWS,1:CONSTRAINT_MATRIX%ELEMENT_MATRIX%NUMBER_OF_COLUMNS), &
                & ERR,ERROR,*999)
            ENDIF
            IF(CONSTRAINT_MATRIX%HAS_TRANSPOSE) THEN
              CALL DISTRIBUTED_MATRIX_VALUES_ADD(CONSTRAINT_MATRIX%MATRIX_TRANSPOSE, &
                & CONSTRAINT_MATRIX%ELEMENT_MATRIX%TRANSPOSE_ROW_DOFS(1:CONSTRAINT_MATRIX% &
                & ELEMENT_MATRIX%NUMBER_OF_TRANSPOSE_ROWS), &
                & CONSTRAINT_MATRIX%ELEMENT_MATRIX%TRANSPOSE_COLUMN_DOFS(1:CONSTRAINT_MATRIX% &
                & ELEMENT_MATRIX%NUMBER_OF_TRANSPOSE_COLUMNS), &
                & TRANSPOSE(CONSTRAINT_MATRIX%ELEMENT_MATRIX%MATRIX(1:CONSTRAINT_MATRIX%ELEMENT_MATRIX%NUMBER_OF_ROWS, &
                & 1:CONSTRAINT_MATRIX%ELEMENT_MATRIX%NUMBER_OF_COLUMNS)),ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="Constraint matrix for dynamic matrix number "//TRIM(NUMBER_TO_VSTRING(matrix_idx,"*",ERR,ERROR))// &
              & " is not associated."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ENDDO !matrix_idx
      ENDIF
      LINEAR_MATRICES=>CONSTRAINT_MATRICES%LINEAR_MATRICES
      IF(ASSOCIATED(LINEAR_MATRICES)) THEN
        !Add the element matrices
        DO matrix_idx=1,LINEAR_MATRICES%NUMBER_OF_LINEAR_MATRICES
          CONSTRAINT_MATRIX=>LINEAR_MATRICES%MATRICES(matrix_idx)%PTR
          IF(ASSOCIATED(CONSTRAINT_MATRIX)) THEN
            IF(CONSTRAINT_MATRIX%UPDATE_MATRIX) THEN
              !Add the element matrice into the distributed constraint matrix
              CALL DISTRIBUTED_MATRIX_VALUES_ADD(CONSTRAINT_MATRIX%MATRIX,CONSTRAINT_MATRIX%ELEMENT_MATRIX%ROW_DOFS(1: &
                & CONSTRAINT_MATRIX%ELEMENT_MATRIX%NUMBER_OF_ROWS),CONSTRAINT_MATRIX%ELEMENT_MATRIX%COLUMN_DOFS(1: &
                & CONSTRAINT_MATRIX%ELEMENT_MATRIX%NUMBER_OF_COLUMNS),CONSTRAINT_MATRIX%ELEMENT_MATRIX%MATRIX(1: &
                & CONSTRAINT_MATRIX%ELEMENT_MATRIX%NUMBER_OF_ROWS,1:CONSTRAINT_MATRIX%ELEMENT_MATRIX%NUMBER_OF_COLUMNS), &
                & ERR,ERROR,*999)
            ENDIF
            !If the constraint matrix has a transpose add it
            IF(CONSTRAINT_MATRIX%HAS_TRANSPOSE) THEN
              CALL DISTRIBUTED_MATRIX_VALUES_ADD(CONSTRAINT_MATRIX%MATRIX_TRANSPOSE, &
                & CONSTRAINT_MATRIX%ELEMENT_MATRIX%TRANSPOSE_ROW_DOFS(1:CONSTRAINT_MATRIX% &
                & ELEMENT_MATRIX%NUMBER_OF_TRANSPOSE_ROWS), &
                & CONSTRAINT_MATRIX%ELEMENT_MATRIX%TRANSPOSE_COLUMN_DOFS(1:CONSTRAINT_MATRIX% &
                & ELEMENT_MATRIX%NUMBER_OF_TRANSPOSE_COLUMNS), &
                & TRANSPOSE(CONSTRAINT_MATRIX%ELEMENT_MATRIX%MATRIX(1:CONSTRAINT_MATRIX%ELEMENT_MATRIX%NUMBER_OF_ROWS, &
                & 1:CONSTRAINT_MATRIX%ELEMENT_MATRIX%NUMBER_OF_COLUMNS)),ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="Constraint matrix for linear matrix number "//TRIM(NUMBER_TO_VSTRING(matrix_idx,"*",ERR,ERROR))// &
              & " is not associated."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ENDDO !matrix_idx
      ENDIF
      NONLINEAR_MATRICES=>CONSTRAINT_MATRICES%NONLINEAR_MATRICES
      IF(ASSOCIATED(NONLINEAR_MATRICES)) THEN
        IF(NONLINEAR_MATRICES%UPDATE_RESIDUAL) THEN
          !Add the residual element vector
          CALL DISTRIBUTED_VECTOR_VALUES_ADD(NONLINEAR_MATRICES%RESIDUAL,NONLINEAR_MATRICES%ELEMENT_RESIDUAL%ROW_DOFS(1: &
            & NONLINEAR_MATRICES%ELEMENT_RESIDUAL%NUMBER_OF_ROWS),NONLINEAR_MATRICES%ELEMENT_RESIDUAL%VECTOR(1:NONLINEAR_MATRICES% &
            & ELEMENT_RESIDUAL%NUMBER_OF_ROWS),ERR,ERROR,*999)
        ENDIF
      ENDIF
      RHS_VECTOR=>CONSTRAINT_MATRICES%RHS_VECTOR
      IF(ASSOCIATED(RHS_VECTOR)) THEN
        IF(RHS_VECTOR%UPDATE_VECTOR) THEN
          !Add the rhs element vector
          CALL DISTRIBUTED_VECTOR_VALUES_ADD(RHS_VECTOR%RHS_VECTOR,RHS_VECTOR%ELEMENT_VECTOR%ROW_DOFS(1: &
            & RHS_VECTOR%ELEMENT_VECTOR%NUMBER_OF_ROWS),RHS_VECTOR%ELEMENT_VECTOR%VECTOR(1:RHS_VECTOR% &
            & ELEMENT_VECTOR%NUMBER_OF_ROWS),ERR,ERROR,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FLAG_ERROR("Constraint matrices is not allocated.",ERR,ERROR,*999)
    ENDIF
#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP("CONSTRAINT_MATRICES_ELEMENT_ADD()")
#endif
    
    CALL EXITS("CONSTRAINT_MATRICES_ELEMENT_ADD")
    RETURN
999 CALL ERRORS("CONSTRAINT_MATRICES_ELEMENT_ADD",ERR,ERROR)
    CALL EXITS("CONSTRAINT_MATRICES_ELEMENT_ADD")
    RETURN 1
  END SUBROUTINE CONSTRAINT_MATRICES_ELEMENT_ADD

  !
  !================================================================================================================================
  !

  !>Calculate the positions in the constraint matrices and rhs of the element matrices and rhs vector. Old CMISS name MELGE.
  SUBROUTINE CONSTRAINT_MATRICES_ELEMENT_CALCULATE(CONSTRAINT_MATRICES,ELEMENT_NUMBER,ERR,ERROR,*)

    !Argument variables
    TYPE(CONSTRAINT_MATRICES_TYPE), POINTER :: CONSTRAINT_MATRICES !<A pointer to the constraint matrices
    INTEGER(INTG), INTENT(IN) :: ELEMENT_NUMBER !<The element number to calculate the mappings for
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: matrix_idx
    TYPE(CONSTRAINT_JACOBIAN_TYPE), POINTER :: JACOBIAN_MATRIX
    TYPE(CONSTRAINT_MAPPING_TYPE), POINTER :: CONSTRAINT_MAPPING
    TYPE(CONSTRAINT_MAPPING_DYNAMIC_TYPE), POINTER :: DYNAMIC_MAPPING
    TYPE(CONSTRAINT_MAPPING_LINEAR_TYPE), POINTER :: LINEAR_MAPPING
    TYPE(CONSTRAINT_MAPPING_NONLINEAR_TYPE), POINTER :: NONLINEAR_MAPPING
    TYPE(CONSTRAINT_MAPPING_RHS_TYPE), POINTER :: RHS_MAPPING
    TYPE(CONSTRAINT_MATRICES_DYNAMIC_TYPE), POINTER :: DYNAMIC_MATRICES
    TYPE(CONSTRAINT_MATRICES_LINEAR_TYPE), POINTER :: LINEAR_MATRICES
    TYPE(CONSTRAINT_MATRICES_NONLINEAR_TYPE), POINTER :: NONLINEAR_MATRICES
    TYPE(CONSTRAINT_RHS_TYPE), POINTER :: RHS_VECTOR
    TYPE(CONSTRAINT_MATRIX_TYPE), POINTER :: CONSTRAINT_MATRIX
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: ROW_FIELD_VARIABLE,COL_FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START("CONSTRAINT_MATRICES_ELEMENT_CALCULATE()")
#endif

    CALL ENTERS("CONSTRAINT_MATRICES_ELEMENT_CALCULATE",ERR,ERROR,*999)

    IF(ASSOCIATED(CONSTRAINT_MATRICES)) THEN
      CONSTRAINT_MAPPING=>CONSTRAINT_MATRICES%CONSTRAINT_MAPPING
      IF(ASSOCIATED(CONSTRAINT_MAPPING)) THEN
        COL_FIELD_VARIABLE=>CONSTRAINT_MAPPING%LAGRANGE_VARIABLE
        DYNAMIC_MATRICES=>CONSTRAINT_MATRICES%DYNAMIC_MATRICES
        IF(ASSOCIATED(DYNAMIC_MATRICES)) THEN
          !Calculate the row and columns for the dynamic constraint matrices
          DYNAMIC_MAPPING=>CONSTRAINT_MAPPING%DYNAMIC_MAPPING
          IF(ASSOCIATED(DYNAMIC_MAPPING)) THEN
            DO matrix_idx=1,DYNAMIC_MATRICES%NUMBER_OF_DYNAMIC_MATRICES
              CONSTRAINT_MATRIX=>DYNAMIC_MATRICES%MATRICES(matrix_idx)%PTR
              IF(ASSOCIATED(CONSTRAINT_MATRIX)) THEN
                ROW_FIELD_VARIABLE=>DYNAMIC_MAPPING%CONSTRAINT_MATRIX_ROWS_TO_VAR_MAP(matrix_idx)%VARIABLE
                CALL CONSTRAINT_MATRICES_ELEMENT_MATRIX_CALCULATE(CONSTRAINT_MATRIX%ELEMENT_MATRIX, &
                  & CONSTRAINT_MATRIX%UPDATE_MATRIX,CONSTRAINT_MATRIX%HAS_TRANSPOSE,[ELEMENT_NUMBER],[ELEMENT_NUMBER], &
                  & ROW_FIELD_VARIABLE,COL_FIELD_VARIABLE,ERR,ERROR,*999)
              ELSE
                LOCAL_ERROR="Constraint matrix for dynamic matrix number "//TRIM(NUMBER_TO_VSTRING(matrix_idx,"*",ERR,ERROR))// &
                  & " is not associated."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ENDDO !matrix_idx
          ELSE
            CALL FLAG_ERROR("Constraint mapping dynamic mapping is not associated.",ERR,ERROR,*999)
          ENDIF
        ENDIF
        LINEAR_MATRICES=>CONSTRAINT_MATRICES%LINEAR_MATRICES
        IF(ASSOCIATED(LINEAR_MATRICES)) THEN
          !Calculate the row and columns for the linear constraint matrices
          LINEAR_MAPPING=>CONSTRAINT_MAPPING%LINEAR_MAPPING
          IF(ASSOCIATED(LINEAR_MAPPING)) THEN
            DO matrix_idx=1,LINEAR_MATRICES%NUMBER_OF_LINEAR_MATRICES
              CONSTRAINT_MATRIX=>LINEAR_MATRICES%MATRICES(matrix_idx)%PTR
              IF(ASSOCIATED(CONSTRAINT_MATRIX)) THEN
                ROW_FIELD_VARIABLE=>LINEAR_MAPPING%CONSTRAINT_MATRIX_ROWS_TO_VAR_MAP(matrix_idx)%VARIABLE
                CALL CONSTRAINT_MATRICES_ELEMENT_MATRIX_CALCULATE(CONSTRAINT_MATRIX%ELEMENT_MATRIX, &
                  & CONSTRAINT_MATRIX%UPDATE_MATRIX,CONSTRAINT_MATRIX%HAS_TRANSPOSE,[ELEMENT_NUMBER],[ELEMENT_NUMBER], &
                  & ROW_FIELD_VARIABLE,COL_FIELD_VARIABLE,ERR,ERROR,*999)
              ELSE
                LOCAL_ERROR="Constraint matrix for linear matrix number "//TRIM(NUMBER_TO_VSTRING(matrix_idx,"*",ERR,ERROR))// &
                  & " is not associated."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ENDDO !matrix_idx
          ELSE
            CALL FLAG_ERROR("Constraint mapping linear mapping is not associated.",ERR,ERROR,*999)
          ENDIF
        ENDIF
        NONLINEAR_MATRICES=>CONSTRAINT_MATRICES%NONLINEAR_MATRICES
        IF(ASSOCIATED(NONLINEAR_MATRICES)) THEN
          !Calculate the rows and columns of the Jacobian
          NONLINEAR_MAPPING=>CONSTRAINT_MAPPING%NONLINEAR_MAPPING
          IF(ASSOCIATED(NONLINEAR_MAPPING)) THEN
            DO matrix_idx=1,NONLINEAR_MATRICES%NUMBER_OF_JACOBIANS
              JACOBIAN_MATRIX=>NONLINEAR_MATRICES%JACOBIANS(matrix_idx)%PTR
              IF(ASSOCIATED(JACOBIAN_MATRIX)) THEN
                ROW_FIELD_VARIABLE=>NONLINEAR_MAPPING%CONSTRAINT_JACOBIAN_ROWS_TO_VAR_MAP(matrix_idx)%VARIABLE
                CALL CONSTRAINT_MATRICES_ELEMENT_MATRIX_CALCULATE(JACOBIAN_MATRIX%ELEMENT_JACOBIAN, &
                  & JACOBIAN_MATRIX%UPDATE_JACOBIAN,JACOBIAN_MATRIX%HAS_TRANSPOSE,[ELEMENT_NUMBER],[ELEMENT_NUMBER], &
                  & ROW_FIELD_VARIABLE,COL_FIELD_VARIABLE,ERR,ERROR,*999)
              ELSE
                CALL FLAG_ERROR("Jacobian matrix is not associated.",ERR,ERROR,*999)
              ENDIF
            ENDDO
            !Calculate the rows of the equations residual
            ROW_FIELD_VARIABLE=>CONSTRAINT_MAPPING%LAGRANGE_VARIABLE
            CALL CONSTRAINT_MATRICES_ELEMENT_VECTOR_CALCULATE(NONLINEAR_MATRICES%ELEMENT_RESIDUAL,NONLINEAR_MATRICES% &
              & UPDATE_RESIDUAL,ELEMENT_NUMBER,ROW_FIELD_VARIABLE,ERR,ERROR,*999)
            NONLINEAR_MATRICES%ELEMENT_RESIDUAL_CALCULATED=0
          ELSE
            CALL FLAG_ERROR("Constraint mapping nonlinear mapping is not associated.",ERR,ERROR,*999)
          ENDIF
        ENDIF
        RHS_VECTOR=>CONSTRAINT_MATRICES%RHS_VECTOR
        IF(ASSOCIATED(RHS_VECTOR)) THEN
          RHS_MAPPING=>CONSTRAINT_MAPPING%RHS_MAPPING
          IF(ASSOCIATED(RHS_MAPPING)) THEN
            !Calculate the rows  for the equations RHS
            ROW_FIELD_VARIABLE=>RHS_MAPPING%RHS_VARIABLE
            CALL CONSTRAINT_MATRICES_ELEMENT_VECTOR_CALCULATE(RHS_VECTOR%ELEMENT_VECTOR,RHS_VECTOR%UPDATE_VECTOR,ELEMENT_NUMBER, &
              & ROW_FIELD_VARIABLE,ERR,ERROR,*999)
          ELSE
            CALL FLAG_ERROR("Constraint mapping rhs mapping is not associated.",ERR,ERROR,*999)
          ENDIF
        ENDIF
      ELSE
        CALL FLAG_ERROR("Constraint mapping is not associated.",ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Constraint matrices is not allocated",ERR,ERROR,*999)
    ENDIF
    
#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP("CONSTRAINT_MATRICES_ELEMENT_CALCULATE()")
#endif
    
    CALL EXITS("CONSTRAINT_MATRICES_ELEMENT_CALCULATE")
    RETURN
999 CALL ERRORS("CONSTRAINT_MATRICES_ELEMENT_CALCULATE",ERR,ERROR)
    CALL EXITS("CONSTRAINT_MATRICES_ELEMENT_CALCULATE")
    RETURN 1
  END SUBROUTINE CONSTRAINT_MATRICES_ELEMENT_CALCULATE

  !
  !================================================================================================================================
  !

  !>Finalise the element calculation information and deallocate all memory
  SUBROUTINE CONSTRAINT_MATRICES_ELEMENT_FINALISE(CONSTRAINT_MATRICES,ERR,ERROR,*)

    !Argument variables
    TYPE(CONSTRAINT_MATRICES_TYPE), POINTER :: CONSTRAINT_MATRICES !<The constraint matrices for which to finalise the elements
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: matrix_idx
    TYPE(CONSTRAINT_JACOBIAN_TYPE), POINTER :: JACOBIAN_MATRIX
    TYPE(CONSTRAINT_MATRICES_DYNAMIC_TYPE), POINTER :: DYNAMIC_MATRICES
    TYPE(CONSTRAINT_MATRICES_LINEAR_TYPE), POINTER :: LINEAR_MATRICES
    TYPE(CONSTRAINT_MATRICES_NONLINEAR_TYPE), POINTER :: NONLINEAR_MATRICES
    TYPE(CONSTRAINT_RHS_TYPE), POINTER :: RHS_VECTOR
    TYPE(CONSTRAINT_MATRIX_TYPE), POINTER :: CONSTRAINT_MATRIX
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CONSTRAINT_MATRICES_ELEMENT_FINALISE",ERR,ERROR,*999)

    IF(ASSOCIATED(CONSTRAINT_MATRICES)) THEN
      DYNAMIC_MATRICES=>CONSTRAINT_MATRICES%DYNAMIC_MATRICES
      IF(ASSOCIATED(DYNAMIC_MATRICES)) THEN
        !Finalise the dynamic element matrices
        DO matrix_idx=1,DYNAMIC_MATRICES%NUMBER_OF_DYNAMIC_MATRICES
          CONSTRAINT_MATRIX=>DYNAMIC_MATRICES%MATRICES(matrix_idx)%PTR
          IF(ASSOCIATED(CONSTRAINT_MATRIX)) THEN
            CALL CONSTRAINT_MATRICES_ELEMENT_MATRIX_FINALISE(CONSTRAINT_MATRIX%ELEMENT_MATRIX,ERR,ERROR,*999)
          ELSE
            LOCAL_ERROR="Constraint matrix for dynamic matrix number "//TRIM(NUMBER_TO_VSTRING(matrix_idx,"*",ERR,ERROR))// &
              & " is not associated."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ENDDO !matrix_idx
      ENDIF
      LINEAR_MATRICES=>CONSTRAINT_MATRICES%LINEAR_MATRICES
      IF(ASSOCIATED(LINEAR_MATRICES)) THEN
        !Finalise the linear element matrices
        DO matrix_idx=1,LINEAR_MATRICES%NUMBER_OF_LINEAR_MATRICES
          CONSTRAINT_MATRIX=>LINEAR_MATRICES%MATRICES(matrix_idx)%PTR
          IF(ASSOCIATED(CONSTRAINT_MATRIX)) THEN
            CALL CONSTRAINT_MATRICES_ELEMENT_MATRIX_FINALISE(CONSTRAINT_MATRIX%ELEMENT_MATRIX,ERR,ERROR,*999)
          ELSE
            LOCAL_ERROR="Constraint matrix for linear matrix number "//TRIM(NUMBER_TO_VSTRING(matrix_idx,"*",ERR,ERROR))// &
              & " is not associated."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ENDDO !matrix_idx
      ENDIF
      NONLINEAR_MATRICES=>CONSTRAINT_MATRICES%NONLINEAR_MATRICES
      IF(ASSOCIATED(NONLINEAR_MATRICES)) THEN
        DO matrix_idx=1,NONLINEAR_MATRICES%NUMBER_OF_JACOBIANS
          JACOBIAN_MATRIX=>NONLINEAR_MATRICES%JACOBIANS(matrix_idx)%PTR
          IF(ASSOCIATED(JACOBIAN_MATRIX)) THEN
            JACOBIAN_MATRIX%ELEMENT_JACOBIAN%MAX_NUMBER_OF_ROWS=0
            JACOBIAN_MATRIX%ELEMENT_JACOBIAN%MAX_NUMBER_OF_COLUMNS=0
            IF(ALLOCATED(JACOBIAN_MATRIX%ELEMENT_JACOBIAN%ROW_DOFS))  &
              & DEALLOCATE(JACOBIAN_MATRIX%ELEMENT_JACOBIAN%ROW_DOFS)
            IF(ALLOCATED(JACOBIAN_MATRIX%ELEMENT_JACOBIAN%COLUMN_DOFS)) &
              & DEALLOCATE(JACOBIAN_MATRIX%ELEMENT_JACOBIAN%COLUMN_DOFS)
            IF(ALLOCATED(JACOBIAN_MATRIX%ELEMENT_JACOBIAN%TRANSPOSE_ROW_DOFS))  &
              & DEALLOCATE(JACOBIAN_MATRIX%ELEMENT_JACOBIAN%TRANSPOSE_ROW_DOFS)
            IF(ALLOCATED(JACOBIAN_MATRIX%ELEMENT_JACOBIAN%TRANSPOSE_COLUMN_DOFS)) &
              & DEALLOCATE(JACOBIAN_MATRIX%ELEMENT_JACOBIAN%TRANSPOSE_COLUMN_DOFS)
            IF(ALLOCATED(JACOBIAN_MATRIX%ELEMENT_JACOBIAN%MATRIX)) DEALLOCATE(JACOBIAN_MATRIX%ELEMENT_JACOBIAN%MATRIX)
          ELSE
            CALL FLAG_ERROR("Nonlinear matrices Jacobian number "//TRIM(NUMBER_TO_VSTRING(matrix_idx,"*",ERR,ERROR))// &
                & " is not associated.",ERR,ERROR,*999)
          ENDIF
        ENDDO
        NONLINEAR_MATRICES%ELEMENT_RESIDUAL%MAX_NUMBER_OF_ROWS=0
        IF(ALLOCATED(NONLINEAR_MATRICES%ELEMENT_RESIDUAL%ROW_DOFS)) DEALLOCATE(NONLINEAR_MATRICES%ELEMENT_RESIDUAL%ROW_DOFS)
        IF(ALLOCATED(NONLINEAR_MATRICES%ELEMENT_RESIDUAL%VECTOR)) DEALLOCATE(NONLINEAR_MATRICES%ELEMENT_RESIDUAL%VECTOR)
      ENDIF
      RHS_VECTOR=>CONSTRAINT_MATRICES%RHS_VECTOR
      IF(ASSOCIATED(RHS_VECTOR)) THEN
        !Finalise the element vector
        RHS_VECTOR%ELEMENT_VECTOR%MAX_NUMBER_OF_ROWS=0
        IF(ALLOCATED(RHS_VECTOR%ELEMENT_VECTOR%ROW_DOFS)) DEALLOCATE(RHS_VECTOR%ELEMENT_VECTOR%ROW_DOFS)
        IF(ALLOCATED(RHS_VECTOR%ELEMENT_VECTOR%VECTOR)) DEALLOCATE(RHS_VECTOR%ELEMENT_VECTOR%VECTOR)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Constraint matrices is not associated.",ERR,ERROR,*999)
    ENDIF
    
    CALL EXITS("CONSTRAINT_MATRICES_ELEMENT_FINALISE")
    RETURN
999 CALL ERRORS("CONSTRAINT_MATRICES_ELEMENT_FINALISE",ERR,ERROR)
    CALL EXITS("CONSTRAINT_MATRICES_ELEMENT_FINALISE")
    RETURN 1
  END SUBROUTINE CONSTRAINT_MATRICES_ELEMENT_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialise the element calculation information for the constraint matrices
  SUBROUTINE CONSTRAINT_MATRICES_ELEMENT_INITIALISE(CONSTRAINT_MATRICES,ERR,ERROR,*)

    !Argument variables
    TYPE(CONSTRAINT_MATRICES_TYPE), POINTER :: CONSTRAINT_MATRICES !The constraint matrices to initialise the element information for
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: matrix_idx
    INTEGER(INTG) :: rowsNumberOfElements,colsNumberOfElements !Number of elements in the row and col variables whose dofs are present in the element matrix
    TYPE(CONSTRAINT_JACOBIAN_TYPE), POINTER :: JACOBIAN_MATRIX
    TYPE(CONSTRAINT_MAPPING_TYPE), POINTER :: CONSTRAINT_MAPPING
    TYPE(CONSTRAINT_MAPPING_DYNAMIC_TYPE), POINTER :: DYNAMIC_MAPPING
    TYPE(CONSTRAINT_MAPPING_LINEAR_TYPE), POINTER :: LINEAR_MAPPING
    TYPE(CONSTRAINT_MAPPING_NONLINEAR_TYPE), POINTER :: NONLINEAR_MAPPING
    TYPE(CONSTRAINT_MAPPING_RHS_TYPE), POINTER :: RHS_MAPPING
    TYPE(CONSTRAINT_MATRICES_DYNAMIC_TYPE), POINTER :: DYNAMIC_MATRICES
    TYPE(CONSTRAINT_MATRICES_LINEAR_TYPE), POINTER :: LINEAR_MATRICES
    TYPE(CONSTRAINT_MATRICES_NONLINEAR_TYPE), POINTER :: NONLINEAR_MATRICES
    TYPE(CONSTRAINT_RHS_TYPE), POINTER :: RHS_VECTOR
    TYPE(CONSTRAINT_MATRIX_TYPE), POINTER :: CONSTRAINT_MATRIX
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: ROW_FIELD_VARIABLE,COL_FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CONSTRAINT_MATRICES_ELEMENT_INITIALISE",ERR,ERROR,*999)

    IF(ASSOCIATED(CONSTRAINT_MATRICES)) THEN
      rowsNumberOfElements=1
      colsNumberOfElements=1
      CONSTRAINT_MAPPING=>CONSTRAINT_MATRICES%CONSTRAINT_MAPPING
      IF(ASSOCIATED(CONSTRAINT_MAPPING)) THEN
        COL_FIELD_VARIABLE=>CONSTRAINT_MAPPING%LAGRANGE_VARIABLE
        DYNAMIC_MATRICES=>CONSTRAINT_MATRICES%DYNAMIC_MATRICES
        IF(ASSOCIATED(DYNAMIC_MATRICES)) THEN
          !Initialise the dynamic element matrices
          DYNAMIC_MAPPING=>CONSTRAINT_MAPPING%DYNAMIC_MAPPING
          IF(ASSOCIATED(DYNAMIC_MAPPING)) THEN
            DO matrix_idx=1,DYNAMIC_MATRICES%NUMBER_OF_DYNAMIC_MATRICES
              CONSTRAINT_MATRIX=>DYNAMIC_MATRICES%MATRICES(matrix_idx)%PTR
              IF(ASSOCIATED(CONSTRAINT_MATRIX)) THEN
                ROW_FIELD_VARIABLE=>DYNAMIC_MAPPING%CONSTRAINT_MATRIX_ROWS_TO_VAR_MAP(matrix_idx)%VARIABLE
                CALL CONSTRAINT_MATRICES_ELEMENT_MATRIX_SETUP(CONSTRAINT_MATRIX%ELEMENT_MATRIX, &
                  & ROW_FIELD_VARIABLE,COL_FIELD_VARIABLE,rowsNumberOfElements,colsNumberOfElements, &
                  & CONSTRAINT_MATRIX%HAS_TRANSPOSE,ERR,ERROR,*999)
              ELSE
                LOCAL_ERROR="Constraint dynamic matrix number "//TRIM(NUMBER_TO_VSTRING(matrix_idx,"*",ERR,ERROR))// &
                  & " is not associated."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ENDDO !matrix_idx
          ELSE
            CALL FLAG_ERROR("Constraint mapping dynamic mapping is not associated.",ERR,ERROR,*999)
          ENDIF
        ENDIF
        LINEAR_MATRICES=>CONSTRAINT_MATRICES%LINEAR_MATRICES
        IF(ASSOCIATED(LINEAR_MATRICES)) THEN
          !Initialise the linear element matrices
          LINEAR_MAPPING=>CONSTRAINT_MAPPING%LINEAR_MAPPING
          IF(ASSOCIATED(LINEAR_MAPPING)) THEN
            DO matrix_idx=1,LINEAR_MATRICES%NUMBER_OF_LINEAR_MATRICES
              CONSTRAINT_MATRIX=>LINEAR_MATRICES%MATRICES(matrix_idx)%PTR
              IF(ASSOCIATED(CONSTRAINT_MATRIX)) THEN
                ROW_FIELD_VARIABLE=>LINEAR_MAPPING%CONSTRAINT_MATRIX_ROWS_TO_VAR_MAP(matrix_idx)%VARIABLE
                CALL CONSTRAINT_MATRICES_ELEMENT_MATRIX_SETUP(CONSTRAINT_MATRIX%ELEMENT_MATRIX, &
                  & ROW_FIELD_VARIABLE,COL_FIELD_VARIABLE,rowsNumberOfElements,colsNumberOfElements, &
                  & CONSTRAINT_MATRIX%HAS_TRANSPOSE,ERR,ERROR,*999)
              ELSE
                LOCAL_ERROR="Constraint linear matrix number "//TRIM(NUMBER_TO_VSTRING(matrix_idx,"*",ERR,ERROR))// &
                  & " is not associated."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ENDDO !matrix_idx
          ELSE
            CALL FLAG_ERROR("Constraint mapping linear mapping is not associated.",ERR,ERROR,*999)
          ENDIF
        ENDIF
        NONLINEAR_MATRICES=>CONSTRAINT_MATRICES%NONLINEAR_MATRICES
        IF(ASSOCIATED(NONLINEAR_MATRICES)) THEN
          !Initialise the Jacobian element matrices
          NONLINEAR_MAPPING=>CONSTRAINT_MAPPING%NONLINEAR_MAPPING
          IF(ASSOCIATED(NONLINEAR_MAPPING)) THEN
            DO matrix_idx=1,NONLINEAR_MATRICES%NUMBER_OF_JACOBIANS
              JACOBIAN_MATRIX=>NONLINEAR_MATRICES%JACOBIANS(matrix_idx)%PTR
              IF(ASSOCIATED(JACOBIAN_MATRIX)) THEN
                ROW_FIELD_VARIABLE=>NONLINEAR_MAPPING%CONSTRAINT_JACOBIAN_ROWS_TO_VAR_MAP(matrix_idx)%VARIABLE
                CALL CONSTRAINT_MATRICES_ELEMENT_MATRIX_SETUP(JACOBIAN_MATRIX%ELEMENT_JACOBIAN, &
                  & ROW_FIELD_VARIABLE,COL_FIELD_VARIABLE,rowsNumberOfElements,colsNumberOfElements, &
                  & JACOBIAN_MATRIX%HAS_TRANSPOSE,ERR,ERROR,*999)
              ELSE
                CALL FLAG_ERROR("Jacobian matrix is not associated.",ERR,ERROR,*999)
              ENDIF
            ENDDO
            ROW_FIELD_VARIABLE=>CONSTRAINT_MAPPING%LAGRANGE_VARIABLE
            CALL CONSTRAINT_MATRICES_ELEMENT_VECTOR_SETUP(NONLINEAR_MATRICES%ELEMENT_RESIDUAL,ROW_FIELD_VARIABLE,ERR,ERROR,*999)
            NONLINEAR_MATRICES%ELEMENT_RESIDUAL_CALCULATED=0
          ELSE
            CALL FLAG_ERROR("Constraint mapping nonlinear mapping is not associated.",ERR,ERROR,*999)
          ENDIF
        ENDIF
        RHS_VECTOR=>CONSTRAINT_MATRICES%RHS_VECTOR
        IF(ASSOCIATED(RHS_VECTOR)) THEN
          !Initialise the RHS element vector
          RHS_MAPPING=>CONSTRAINT_MAPPING%RHS_MAPPING
          IF(ASSOCIATED(RHS_MAPPING)) THEN
            ROW_FIELD_VARIABLE=>RHS_MAPPING%RHS_VARIABLE
            CALL CONSTRAINT_MATRICES_ELEMENT_VECTOR_SETUP(RHS_VECTOR%ELEMENT_VECTOR,ROW_FIELD_VARIABLE,ERR,ERROR,*999)
          ELSE
            CALL FLAG_ERROR("RHS mapping is not associated.",ERR,ERROR,*999)
          ENDIF
        ENDIF
      ELSE
        CALL FLAG_ERROR("Constraint matrices mapping is not associated.",ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Constraint matrices is not associated.",ERR,ERROR,*999)
    ENDIF
    
    CALL EXITS("CONSTRAINT_MATRICES_ELEMENT_INITIALISE")
    RETURN
999 CALL ERRORS("CONSTRAINT_MATRICES_ELEMENT_INITIALISE",ERR,ERROR)
    CALL EXITS("CONSTRAINT_MATRICES_ELEMENT_INITIALISE")
    RETURN 1
  END SUBROUTINE CONSTRAINT_MATRICES_ELEMENT_INITIALISE

  !
  !================================================================================================================================
  !

  !>Finalise a constraint matrix and deallocate all memory
  SUBROUTINE CONSTRAINT_MATRIX_FINALISE(CONSTRAINT_MATRIX,ERR,ERROR,*)

    !Argument variables
    TYPE(CONSTRAINT_MATRIX_TYPE), POINTER :: CONSTRAINT_MATRIX !<A pointer to the constraint matrix to finalise
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    
    CALL ENTERS("CONSTRAINT_MATRIX_FINALISE",ERR,ERROR,*999)

    IF(ASSOCIATED(CONSTRAINT_MATRIX)) THEN
      IF(ASSOCIATED(CONSTRAINT_MATRIX%MATRIX)) CALL DISTRIBUTED_MATRIX_DESTROY(CONSTRAINT_MATRIX%MATRIX,ERR,ERROR,*999)
      IF(ASSOCIATED(CONSTRAINT_MATRIX%MATRIX_TRANSPOSE)) CALL DISTRIBUTED_MATRIX_DESTROY(CONSTRAINT_MATRIX%MATRIX_TRANSPOSE, &
        & ERR,ERROR,*999)
      CALL CONSTRAINT_MATRICES_ELEMENT_MATRIX_FINALISE(CONSTRAINT_MATRIX%ELEMENT_MATRIX,ERR,ERROR,*999)
      IF(ASSOCIATED(CONSTRAINT_MATRIX%TEMP_VECTOR)) CALL DISTRIBUTED_VECTOR_DESTROY(CONSTRAINT_MATRIX%TEMP_VECTOR,ERR,ERROR,*999)
      IF(ASSOCIATED(CONSTRAINT_MATRIX%TEMP_TRANSPOSE_VECTOR)) &
        & CALL DISTRIBUTED_VECTOR_DESTROY(CONSTRAINT_MATRIX%TEMP_TRANSPOSE_VECTOR,ERR,ERROR,*999)
    ENDIF
    
    CALL EXITS("CONSTRAINT_MATRIX_FINALISE")
    RETURN
999 CALL ERRORS("CONSTRAINT_MATRIX_FINALISE",ERR,ERROR)
    CALL EXITS("CONSTRAINT_MATRIX_FINALISE")
    RETURN 1
  END SUBROUTINE CONSTRAINT_MATRIX_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialise the dynamic constraint matrix.
  SUBROUTINE CONSTRAINT_MATRIX_DYNAMIC_INITIALISE(DYNAMIC_MATRICES,MATRIX_NUMBER,ERR,ERROR,*)

    !Argument variables
    TYPE(CONSTRAINT_MATRICES_DYNAMIC_TYPE), POINTER :: DYNAMIC_MATRICES !<A pointer to the dynamic matrices to initialise the dynamic constraint matrix for
    INTEGER(INTG) :: MATRIX_NUMBER !<The dynamic matrix number in the dynamic constraint matrices to initialise.
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DUMMY_ERR
    TYPE(CONSTRAINT_MAPPING_TYPE), POINTER :: CONSTRAINT_MAPPING
    TYPE(CONSTRAINT_MAPPING_DYNAMIC_TYPE), POINTER :: DYNAMIC_MAPPING
    TYPE(CONSTRAINT_MATRICES_TYPE), POINTER :: CONSTRAINT_MATRICES
    TYPE(CONSTRAINT_MATRIX_TYPE), POINTER :: CONSTRAINT_MATRIX
    TYPE(VARYING_STRING) :: DUMMY_ERROR,LOCAL_ERROR

    CALL ENTERS("CONSTRAINT_MATRIX_DYNAMIC_INITIALISE",ERR,ERROR,*998)

    IF(ASSOCIATED(DYNAMIC_MATRICES)) THEN
      IF(MATRIX_NUMBER>0.AND.MATRIX_NUMBER<=DYNAMIC_MATRICES%NUMBER_OF_DYNAMIC_MATRICES) THEN
        CONSTRAINT_MATRICES=>DYNAMIC_MATRICES%CONSTRAINT_MATRICES
        IF(ASSOCIATED(CONSTRAINT_MATRICES)) THEN
          CONSTRAINT_MAPPING=>CONSTRAINT_MATRICES%CONSTRAINT_MAPPING
          IF(ASSOCIATED(CONSTRAINT_MAPPING)) THEN
            DYNAMIC_MAPPING=>CONSTRAINT_MAPPING%DYNAMIC_MAPPING
            IF(ASSOCIATED(DYNAMIC_MAPPING)) THEN
              IF(ASSOCIATED(DYNAMIC_MATRICES%MATRICES(MATRIX_NUMBER)%PTR)) THEN
                LOCAL_ERROR="Constraint matrix for dynamic matrix number "//TRIM(NUMBER_TO_VSTRING(MATRIX_NUMBER,"*",ERR,ERROR))// &
                & " is already associated."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*998)
              ELSE
                ALLOCATE(DYNAMIC_MATRICES%MATRICES(MATRIX_NUMBER)%PTR,STAT=ERR)
                IF(ERR/=0) CALL FLAG_ERROR("Could not allocate constraint matrix.",ERR,ERROR,*999)
                CONSTRAINT_MATRIX=>DYNAMIC_MATRICES%MATRICES(MATRIX_NUMBER)%PTR
                CONSTRAINT_MATRIX%MATRIX_NUMBER=MATRIX_NUMBER
                CONSTRAINT_MATRIX%DYNAMIC_MATRICES=>DYNAMIC_MATRICES
                NULLIFY(CONSTRAINT_MATRIX%LINEAR_MATRICES)
                CONSTRAINT_MATRIX%STORAGE_TYPE=MATRIX_BLOCK_STORAGE_TYPE
                CONSTRAINT_MATRIX%STRUCTURE_TYPE=CONSTRAINT_MATRIX_NO_STRUCTURE
                CONSTRAINT_MATRIX%UPDATE_MATRIX=.TRUE.
                CONSTRAINT_MATRIX%FIRST_ASSEMBLY=.TRUE.
                CONSTRAINT_MATRIX%HAS_TRANSPOSE=DYNAMIC_MAPPING%CONSTRAINT_MATRIX_ROWS_TO_VAR_MAP(MATRIX_NUMBER)%HAS_TRANSPOSE
                CONSTRAINT_MATRIX%NUMBER_OF_ROWS=DYNAMIC_MAPPING%CONSTRAINT_MATRIX_ROWS_TO_VAR_MAP(MATRIX_NUMBER)%NUMBER_OF_ROWS
                CONSTRAINT_MATRIX%TOTAL_NUMBER_OF_ROWS=DYNAMIC_MAPPING%CONSTRAINT_MATRIX_ROWS_TO_VAR_MAP(MATRIX_NUMBER)% &
                  & TOTAL_NUMBER_OF_ROWS
                DYNAMIC_MAPPING%CONSTRAINT_MATRIX_ROWS_TO_VAR_MAP(MATRIX_NUMBER)%CONSTRAINT_MATRIX=>CONSTRAINT_MATRIX
                NULLIFY(CONSTRAINT_MATRIX%MATRIX)
                NULLIFY(CONSTRAINT_MATRIX%MATRIX_TRANSPOSE)
                NULLIFY(CONSTRAINT_MATRIX%TEMP_VECTOR)
                NULLIFY(CONSTRAINT_MATRIX%TEMP_TRANSPOSE_VECTOR)
                CALL CONSTRAINT_MATRICES_ELEMENT_MATRIX_INITIALISE(CONSTRAINT_MATRIX%ELEMENT_MATRIX,ERR,ERROR,*999)
              ENDIF
            ELSE
              CALL FLAG_ERROR("Constraint mapping dynamic mapping is not associated.",ERR,ERROR,*998)
            ENDIF
          ELSE
            CALL FLAG_ERROR("Constraint mapping is not associated.",ERR,ERROR,*998)
          ENDIF
        ELSE
          CALL FLAG_ERROR("Dynamic matrices constraint matrices is not associated.",ERR,ERROR,*998)
        ENDIF
      ELSE
        LOCAL_ERROR="The specified dynamic matrix number of "//TRIM(NUMBER_TO_VSTRING(MATRIX_NUMBER,"*",ERR,ERROR))// &
          & " is invalid. The matrix number must be > 0 and <= "// &
          & TRIM(NUMBER_TO_VSTRING(DYNAMIC_MATRICES%NUMBER_OF_DYNAMIC_MATRICES,"*",ERR,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*998)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Dynamic matrices is not associated.",ERR,ERROR,*998)
    ENDIF
    
    CALL EXITS("CONSTRAINT_MATRIX_DYNAMIC_INITIALISE")
    RETURN
999 CALL CONSTRAINT_MATRIX_FINALISE(DYNAMIC_MATRICES%MATRICES(MATRIX_NUMBER)%PTR,DUMMY_ERR,DUMMY_ERROR,*998)
998 CALL ERRORS("CONSTRAINT_MATRIX_DYNAMIC_INITIALISE",ERR,ERROR)
    CALL EXITS("CONSTRAINT_MATRIX_DYNAMIC_INITIALISE")
    RETURN 1
  END SUBROUTINE CONSTRAINT_MATRIX_DYNAMIC_INITIALISE

  !
  !================================================================================================================================
  !

  !>Initialise the linear constraint matrix.
  SUBROUTINE CONSTRAINT_MATRIX_LINEAR_INITIALISE(LINEAR_MATRICES,MATRIX_NUMBER,ERR,ERROR,*)

    !Argument variables
    TYPE(CONSTRAINT_MATRICES_LINEAR_TYPE), POINTER :: LINEAR_MATRICES !<A pointer to the linear matrices to initialise the linear constraint matrix for
    INTEGER(INTG) :: MATRIX_NUMBER !<The linear matrix number in the linear constraint matrices to initialise.
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DUMMY_ERR
    TYPE(CONSTRAINT_MAPPING_TYPE), POINTER :: CONSTRAINT_MAPPING
    TYPE(CONSTRAINT_MAPPING_LINEAR_TYPE), POINTER :: LINEAR_MAPPING
    TYPE(CONSTRAINT_MATRICES_TYPE), POINTER :: CONSTRAINT_MATRICES
    TYPE(CONSTRAINT_MATRIX_TYPE), POINTER :: CONSTRAINT_MATRIX
    TYPE(VARYING_STRING) :: DUMMY_ERROR,LOCAL_ERROR

    CALL ENTERS("CONSTRAINT_MATRIX_LINEAR_INITIALISE",ERR,ERROR,*998)

    IF(ASSOCIATED(LINEAR_MATRICES)) THEN
      IF(MATRIX_NUMBER>0.AND.MATRIX_NUMBER<=LINEAR_MATRICES%NUMBER_OF_LINEAR_MATRICES) THEN
        CONSTRAINT_MATRICES=>LINEAR_MATRICES%CONSTRAINT_MATRICES
        IF(ASSOCIATED(CONSTRAINT_MATRICES)) THEN
          CONSTRAINT_MAPPING=>CONSTRAINT_MATRICES%CONSTRAINT_MAPPING
          IF(ASSOCIATED(CONSTRAINT_MAPPING)) THEN
            LINEAR_MAPPING=>CONSTRAINT_MAPPING%LINEAR_MAPPING
            IF(ASSOCIATED(LINEAR_MAPPING)) THEN
              IF(ASSOCIATED(LINEAR_MATRICES%MATRICES(MATRIX_NUMBER)%PTR)) THEN
                LOCAL_ERROR="Constraint matrix for linear matrix number "//TRIM(NUMBER_TO_VSTRING(MATRIX_NUMBER,"*",ERR,ERROR))// &
                & " is already associated."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*998)
              ELSE
                ALLOCATE(LINEAR_MATRICES%MATRICES(MATRIX_NUMBER)%PTR,STAT=ERR)
                IF(ERR/=0) CALL FLAG_ERROR("Could not allocate constraint matrix.",ERR,ERROR,*999)
                CONSTRAINT_MATRIX=>LINEAR_MATRICES%MATRICES(MATRIX_NUMBER)%PTR
                CONSTRAINT_MATRIX%MATRIX_NUMBER=MATRIX_NUMBER
                NULLIFY(CONSTRAINT_MATRIX%DYNAMIC_MATRICES)
                CONSTRAINT_MATRIX%LINEAR_MATRICES=>LINEAR_MATRICES
                CONSTRAINT_MATRIX%STORAGE_TYPE=MATRIX_BLOCK_STORAGE_TYPE
                CONSTRAINT_MATRIX%STRUCTURE_TYPE=CONSTRAINT_MATRIX_NO_STRUCTURE
                CONSTRAINT_MATRIX%UPDATE_MATRIX=.TRUE.
                CONSTRAINT_MATRIX%FIRST_ASSEMBLY=.TRUE.
                CONSTRAINT_MATRIX%HAS_TRANSPOSE=LINEAR_MAPPING%CONSTRAINT_MATRIX_ROWS_TO_VAR_MAP(MATRIX_NUMBER)%HAS_TRANSPOSE
                CONSTRAINT_MATRIX%NUMBER_OF_ROWS=LINEAR_MAPPING%CONSTRAINT_MATRIX_ROWS_TO_VAR_MAP(MATRIX_NUMBER)%NUMBER_OF_ROWS
                CONSTRAINT_MATRIX%TOTAL_NUMBER_OF_ROWS=LINEAR_MAPPING%CONSTRAINT_MATRIX_ROWS_TO_VAR_MAP(MATRIX_NUMBER)% &
                  & TOTAL_NUMBER_OF_ROWS
                LINEAR_MAPPING%CONSTRAINT_MATRIX_ROWS_TO_VAR_MAP(MATRIX_NUMBER)%CONSTRAINT_MATRIX=>CONSTRAINT_MATRIX
                NULLIFY(CONSTRAINT_MATRIX%MATRIX)
                NULLIFY(CONSTRAINT_MATRIX%MATRIX_TRANSPOSE)
                NULLIFY(CONSTRAINT_MATRIX%TEMP_VECTOR)
                NULLIFY(CONSTRAINT_MATRIX%TEMP_TRANSPOSE_VECTOR)
                CALL CONSTRAINT_MATRICES_ELEMENT_MATRIX_INITIALISE(CONSTRAINT_MATRIX%ELEMENT_MATRIX,ERR,ERROR,*999)
              ENDIF
            ELSE
              CALL FLAG_ERROR("Constraint mapping linear mapping is not associated.",ERR,ERROR,*998)
            ENDIF
          ELSE
            CALL FLAG_ERROR("Constraint mapping is not associated.",ERR,ERROR,*998)
          ENDIF
        ELSE
          CALL FLAG_ERROR("Linear matrices constraint matrices is not associated.",ERR,ERROR,*998)
        ENDIF
      ELSE
        LOCAL_ERROR="The specified linear matrix number of "//TRIM(NUMBER_TO_VSTRING(MATRIX_NUMBER,"*",ERR,ERROR))// &
          & " is invalid. The matrix number must be > 0 and <= "// &
          & TRIM(NUMBER_TO_VSTRING(LINEAR_MATRICES%NUMBER_OF_LINEAR_MATRICES,"*",ERR,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*998)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Linear matrices is not associated.",ERR,ERROR,*998)
    ENDIF
    
    CALL EXITS("CONSTRAINT_MATRIX_LINEAR_INITIALISE")
    RETURN
999 CALL CONSTRAINT_MATRIX_FINALISE(LINEAR_MATRICES%MATRICES(MATRIX_NUMBER)%PTR,DUMMY_ERR,DUMMY_ERROR,*998)
998 CALL ERRORS("CONSTRAINT_MATRIX_LINEAR_INITIALISE",ERR,ERROR)
    CALL EXITS("CONSTRAINT_MATRIX_LINEAR_INITIALISE")
    RETURN 1
  END SUBROUTINE CONSTRAINT_MATRIX_LINEAR_INITIALISE

  !
  !================================================================================================================================
  !

  !>Finalises the constraint matrices dynamic matrices and deallocates all memory
  SUBROUTINE CONSTRAINT_MATRICES_DYNAMIC_FINALISE(DYNAMIC_MATRICES,ERR,ERROR,*)

    !Argument variables
    TYPE(CONSTRAINT_MATRICES_DYNAMIC_TYPE), POINTER :: DYNAMIC_MATRICES !<A pointer to the constraint matrices dynamic matrices to finalise
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: matrix_idx
     
    CALL ENTERS("CONSTRAINT_MATRICES_DYNAMIC_FINALISE",ERR,ERROR,*999)

    IF(ASSOCIATED(DYNAMIC_MATRICES)) THEN
      IF(ALLOCATED(DYNAMIC_MATRICES%MATRICES)) THEN
        DO matrix_idx=1,SIZE(DYNAMIC_MATRICES%MATRICES,1)
          CALL CONSTRAINT_MATRIX_FINALISE(DYNAMIC_MATRICES%MATRICES(matrix_idx)%PTR,ERR,ERROR,*999)
        ENDDO !matrix_idx
        DEALLOCATE(DYNAMIC_MATRICES%MATRICES)
      ENDIF
      IF(ASSOCIATED(DYNAMIC_MATRICES%TEMP_VECTOR)) CALL DISTRIBUTED_VECTOR_DESTROY(DYNAMIC_MATRICES%TEMP_VECTOR,ERR,ERROR,*999)
      DEALLOCATE(DYNAMIC_MATRICES)
    ENDIF
    
    CALL EXITS("CONSTRAINT_MATRICES_DYNAMIC_FINALISE")
    RETURN
999 CALL ERRORS("CONSTRAINT_MATRICES_DYNAMIC_FINALISE",ERR,ERROR)
    CALL EXITS("CONSTRAINT_MATRICES_DYNAMIC_FINALISE")
    RETURN 1
  END SUBROUTINE CONSTRAINT_MATRICES_DYNAMIC_FINALISE
  
  !
  !================================================================================================================================
  !

  !>Initialises the constraint matrices dynamic matrices
  SUBROUTINE CONSTRAINT_MATRICES_DYNAMIC_INITIALISE(CONSTRAINT_MATRICES,ERR,ERROR,*)

    !Argument variables
    TYPE(CONSTRAINT_MATRICES_TYPE), POINTER :: CONSTRAINT_MATRICES !<A pointer to the constraint matrices to initialise the dynamic matrices for
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DUMMY_ERR,matrix_idx
    TYPE(CONSTRAINT_MAPPING_TYPE), POINTER :: CONSTRAINT_MAPPING
    TYPE(CONSTRAINT_MAPPING_DYNAMIC_TYPE), POINTER :: DYNAMIC_MAPPING
    TYPE(VARYING_STRING) :: DUMMY_ERROR
     
    CALL ENTERS("CONSTRAINT_MATRICES_DYNAMIC_INITIALISE",ERR,ERROR,*998)
    
    IF(ASSOCIATED(CONSTRAINT_MATRICES)) THEN
      CONSTRAINT_MAPPING=>CONSTRAINT_MATRICES%CONSTRAINT_MAPPING
      IF(ASSOCIATED(CONSTRAINT_MAPPING)) THEN
        DYNAMIC_MAPPING=>CONSTRAINT_MAPPING%DYNAMIC_MAPPING
        IF(ASSOCIATED(DYNAMIC_MAPPING)) THEN
          IF(ASSOCIATED(CONSTRAINT_MATRICES%DYNAMIC_MATRICES)) THEN
            CALL FLAG_ERROR("Constraint matrices dynamic matrices is already associated.",ERR,ERROR,*998)
          ELSE
            ALLOCATE(CONSTRAINT_MATRICES%DYNAMIC_MATRICES,STAT=ERR)
            IF(ERR/=0) CALL FLAG_ERROR("Could not allocate constraint matrices dynamic matrices.",ERR,ERROR,*999)
            CONSTRAINT_MATRICES%DYNAMIC_MATRICES%CONSTRAINT_MATRICES=>CONSTRAINT_MATRICES
            CONSTRAINT_MATRICES%DYNAMIC_MATRICES%NUMBER_OF_DYNAMIC_MATRICES=DYNAMIC_MAPPING%NUMBER_OF_DYNAMIC_CONSTRAINT_MATRICES
            ALLOCATE(CONSTRAINT_MATRICES%DYNAMIC_MATRICES%MATRICES(DYNAMIC_MAPPING%NUMBER_OF_DYNAMIC_CONSTRAINT_MATRICES),STAT=ERR)
            IF(ERR/=0) CALL FLAG_ERROR("Could not allocate constraint matrices dynamic matrices matrices.",ERR,ERROR,*999)
            DO matrix_idx=1,DYNAMIC_MAPPING%NUMBER_OF_DYNAMIC_CONSTRAINT_MATRICES
              NULLIFY(CONSTRAINT_MATRICES%DYNAMIC_MATRICES%MATRICES(matrix_idx)%PTR)
              CALL CONSTRAINT_MATRIX_DYNAMIC_INITIALISE(CONSTRAINT_MATRICES%DYNAMIC_MATRICES,matrix_idx,ERR,ERROR,*999)
            ENDDO !matrix_idx
            NULLIFY(CONSTRAINT_MATRICES%DYNAMIC_MATRICES%TEMP_VECTOR)
          ENDIF
        ENDIF
      ELSE
        CALL FLAG_ERROR("Constraint matrices equations mapping is not associated.",ERR,ERROR,*998)        
      ENDIF
    ELSE
      CALL FLAG_ERROR("Constraint matrices is not associated.",ERR,ERROR,*998)
    ENDIF
    
    CALL EXITS("CONSTRAINT_MATRICES_DYNAMIC_INITIALISE")
    RETURN
999 CALL CONSTRAINT_MATRICES_DYNAMIC_FINALISE(CONSTRAINT_MATRICES%DYNAMIC_MATRICES,DUMMY_ERR,DUMMY_ERROR,*998)
998 CALL ERRORS("CONSTRAINT_MATRICES_DYNAMIC_INITIALISE",ERR,ERROR)
    CALL EXITS("CONSTRAINT_MATRICES_DYNAMIC_INITIALISE")
    RETURN 1
  END SUBROUTINE CONSTRAINT_MATRICES_DYNAMIC_INITIALISE
  
  !
  !================================================================================================================================
  !

  !>Adds the Jacobain matrices into the constraint Jacobian.
  SUBROUTINE CONSTRAINT_MATRICES_JACOBIAN_ELEMENT_ADD(CONSTRAINT_MATRICES,ERR,ERROR,*)

    !Argument variables
    TYPE(CONSTRAINT_MATRICES_TYPE), POINTER :: CONSTRAINT_MATRICES !<A pointer to the constraint matrices
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: jacobian_matrix_idx
    TYPE(CONSTRAINT_JACOBIAN_TYPE), POINTER :: JACOBIAN_MATRIX
    TYPE(CONSTRAINT_MATRICES_NONLINEAR_TYPE), POINTER :: NONLINEAR_MATRICES
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START("CONSTRAINT_MATRICES_JACOBIAN_ELEMENT_ADD()")
#endif

    CALL ENTERS("CONSTRAINT_MATRICES_JACOBIAN_ELEMENT_ADD",ERR,ERROR,*999)

    IF(ASSOCIATED(CONSTRAINT_MATRICES)) THEN
      NONLINEAR_MATRICES=>CONSTRAINT_MATRICES%NONLINEAR_MATRICES
      IF(ASSOCIATED(NONLINEAR_MATRICES)) THEN
        DO jacobian_matrix_idx=1,NONLINEAR_MATRICES%NUMBER_OF_JACOBIANS
          JACOBIAN_MATRIX=>NONLINEAR_MATRICES%JACOBIANS(jacobian_matrix_idx)%PTR
          IF(ASSOCIATED(JACOBIAN_MATRIX)) THEN
            IF(JACOBIAN_MATRIX%UPDATE_JACOBIAN) THEN
              !Add in Jacobian element matrices
              CALL DISTRIBUTED_MATRIX_VALUES_ADD(JACOBIAN_MATRIX%JACOBIAN,JACOBIAN_MATRIX%ELEMENT_JACOBIAN%ROW_DOFS(1: &
                & JACOBIAN_MATRIX%ELEMENT_JACOBIAN%NUMBER_OF_ROWS),JACOBIAN_MATRIX%ELEMENT_JACOBIAN%COLUMN_DOFS(1: &
                & JACOBIAN_MATRIX%ELEMENT_JACOBIAN%NUMBER_OF_COLUMNS),JACOBIAN_MATRIX%ELEMENT_JACOBIAN%MATRIX(1: &
                & JACOBIAN_MATRIX%ELEMENT_JACOBIAN%NUMBER_OF_ROWS,1:JACOBIAN_MATRIX%ELEMENT_JACOBIAN%NUMBER_OF_COLUMNS), &
                & ERR,ERROR,*999)
            ENDIF
            IF(JACOBIAN_MATRIX%HAS_TRANSPOSE) THEN
              CALL DISTRIBUTED_MATRIX_VALUES_ADD(JACOBIAN_MATRIX%JACOBIAN_TRANSPOSE, &
                & JACOBIAN_MATRIX%ELEMENT_JACOBIAN%TRANSPOSE_ROW_DOFS(1:JACOBIAN_MATRIX% &
                & ELEMENT_JACOBIAN%NUMBER_OF_TRANSPOSE_ROWS), &
                & JACOBIAN_MATRIX%ELEMENT_JACOBIAN%TRANSPOSE_COLUMN_DOFS(1:JACOBIAN_MATRIX%ELEMENT_JACOBIAN% &
                & NUMBER_OF_TRANSPOSE_COLUMNS), &
                & TRANSPOSE(JACOBIAN_MATRIX%ELEMENT_JACOBIAN%MATRIX(1:JACOBIAN_MATRIX%ELEMENT_JACOBIAN%NUMBER_OF_ROWS, &
                & 1:JACOBIAN_MATRIX%ELEMENT_JACOBIAN%NUMBER_OF_COLUMNS)),ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="Jacobian matrix for Jacobian matrix index "// &
              & TRIM(NUMBER_TO_VSTRING(jacobian_matrix_idx,"*",ERR,ERROR))//" is not associated."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ENDDO !jacobian_matrix_idx
      ENDIF
    ELSE
      CALL FLAG_ERROR("Constraint matrices is not allocated.",ERR,ERROR,*999)
    ENDIF
#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP("CONSTRAINT_MATRICES_JACOBIAN_ELEMENT_ADD()")
#endif
    
    CALL EXITS("CONSTRAINT_MATRICES_JACOBIAN_ELEMENT_ADD")
    RETURN
999 CALL ERRORS("CONSTRAINT_MATRICES_JACOBIAN_ELEMENT_ADD",ERR,ERROR)
    CALL EXITS("CONSTRAINT_MATRICES_JACOBIAN_ELEMENT_ADD")
    RETURN 1
  END SUBROUTINE CONSTRAINT_MATRICES_JACOBIAN_ELEMENT_ADD

  !
  !================================================================================================================================
  !

  !>Outputs the constraint Jacobian matrices
  SUBROUTINE CONSTRAINT_MATRICES_JACOBIAN_OUTPUT(ID,CONSTRAINT_MATRICES,ERR,ERROR,*)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ID !<The ID of the ouptut stream
    TYPE(CONSTRAINT_MATRICES_TYPE), POINTER :: CONSTRAINT_MATRICES !<A pointer to the constraint Jacobian matrices
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: jacobian_matrix_idx
    TYPE(CONSTRAINT_JACOBIAN_TYPE), POINTER :: JACOBIAN_MATRIX
    TYPE(CONSTRAINT_MATRICES_NONLINEAR_TYPE), POINTER :: NONLINEAR_MATRICES
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CONSTRAINT_MATRICES_JACOBIAN_OUTPUT",ERR,ERROR,*999)
    
    IF(ASSOCIATED(CONSTRAINT_MATRICES)) THEN
      IF(CONSTRAINT_MATRICES%CONSTRAINT_MATRICES_FINISHED) THEN
        NONLINEAR_MATRICES=>CONSTRAINT_MATRICES%NONLINEAR_MATRICES
        IF(ASSOCIATED(NONLINEAR_MATRICES)) THEN
          CALL WRITE_STRING(ID,"",ERR,ERROR,*999)
          CALL WRITE_STRING(ID,"Jacobian matrices:",ERR,ERROR,*999)
          DO jacobian_matrix_idx=1,NONLINEAR_MATRICES%NUMBER_OF_JACOBIANS
            JACOBIAN_MATRIX=>NONLINEAR_MATRICES%JACOBIANS(jacobian_matrix_idx)%PTR
            IF(ASSOCIATED(JACOBIAN_MATRIX)) THEN        
              CALL WRITE_STRING(ID,"Jacobian matrix:",ERR,ERROR,*999)
              CALL DISTRIBUTED_MATRIX_OUTPUT(ID,JACOBIAN_MATRIX%JACOBIAN,ERR,ERROR,*999)
              IF(JACOBIAN_MATRIX%HAS_TRANSPOSE) THEN
                CALL WRITE_STRING(ID,"Transposed Jacobian matrix:",ERR,ERROR,*999)
                CALL DISTRIBUTED_MATRIX_OUTPUT(ID,JACOBIAN_MATRIX%JACOBIAN_TRANSPOSE,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="Jacobian matrix for Jacobian matrix index "// &
                & TRIM(NUMBER_TO_VSTRING(jacobian_matrix_idx,"*",ERR,ERROR))//" is not associated."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ENDDO !jacobian_matrix_idx
        ENDIF
      ELSE
        CALL FLAG_ERROR("Constraint matrices have not been finished.",ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Constraint matrices is not associated.",ERR,ERROR,*999)
    ENDIF
    
    CALL EXITS("CONSTRAINT_MATRICES_JACOBIAN_OUTPUT")
    RETURN
999 CALL ERRORS("CONSTRAINT_MATRICES_JACOBIAN_OUTPUT",ERR,ERROR)
    CALL EXITS("CONSTRAINT_MATRICES_JACOBIAN_OUTPUT")
    RETURN 1
  END SUBROUTINE CONSTRAINT_MATRICES_JACOBIAN_OUTPUT
  
  !
  !================================================================================================================================
  !

  !>Finalises the constraint matrices linear matrices and deallocates all memory
  SUBROUTINE CONSTRAINT_MATRICES_LINEAR_FINALISE(LINEAR_MATRICES,ERR,ERROR,*)

    !Argument variables
    TYPE(CONSTRAINT_MATRICES_LINEAR_TYPE), POINTER :: LINEAR_MATRICES !<A pointer to the constraint matrices linear matrices to finalise
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: matrix_idx
     
    CALL ENTERS("CONSTRAINT_MATRICES_LINEAR_FINALISE",ERR,ERROR,*999)

    IF(ASSOCIATED(LINEAR_MATRICES)) THEN
      IF(ALLOCATED(LINEAR_MATRICES%MATRICES)) THEN
        DO matrix_idx=1,SIZE(LINEAR_MATRICES%MATRICES,1)
          CALL CONSTRAINT_MATRIX_FINALISE(LINEAR_MATRICES%MATRICES(matrix_idx)%PTR,ERR,ERROR,*999)
        ENDDO !matrix_idx
        DEALLOCATE(LINEAR_MATRICES%MATRICES)
      ENDIF
      DEALLOCATE(LINEAR_MATRICES)
    ENDIF
    
    CALL EXITS("CONSTRAINT_MATRICES_LINEAR_FINALISE")
    RETURN
999 CALL ERRORS("CONSTRAINT_MATRICES_LINEAR_FINALISE",ERR,ERROR)
    CALL EXITS("CONSTRAINT_MATRICES_LINEAR_FINALISE")
    RETURN 1
  END SUBROUTINE CONSTRAINT_MATRICES_LINEAR_FINALISE
  
  !
  !================================================================================================================================
  !

  !>Initialises the constraint matrices linear matrices
  SUBROUTINE CONSTRAINT_MATRICES_LINEAR_INITIALISE(CONSTRAINT_MATRICES,ERR,ERROR,*)

    !Argument variables
    TYPE(CONSTRAINT_MATRICES_TYPE), POINTER :: CONSTRAINT_MATRICES !<A pointer to the constraint matrices to initialise the linear matrices for
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DUMMY_ERR,matrix_idx
    TYPE(CONSTRAINT_MAPPING_TYPE), POINTER :: CONSTRAINT_MAPPING
    TYPE(CONSTRAINT_MAPPING_LINEAR_TYPE), POINTER :: LINEAR_MAPPING
    TYPE(VARYING_STRING) :: DUMMY_ERROR
     
    CALL ENTERS("CONSTRAINT_MATRICES_LINEAR_INITIALISE",ERR,ERROR,*998)
    
    IF(ASSOCIATED(CONSTRAINT_MATRICES)) THEN
      CONSTRAINT_MAPPING=>CONSTRAINT_MATRICES%CONSTRAINT_MAPPING
      IF(ASSOCIATED(CONSTRAINT_MAPPING)) THEN
        LINEAR_MAPPING=>CONSTRAINT_MAPPING%LINEAR_MAPPING
        IF(ASSOCIATED(LINEAR_MAPPING)) THEN
          IF(ASSOCIATED(CONSTRAINT_MATRICES%LINEAR_MATRICES)) THEN
            CALL FLAG_ERROR("Constraint matrices linear matrices is already associated.",ERR,ERROR,*998)
          ELSE
            ALLOCATE(CONSTRAINT_MATRICES%LINEAR_MATRICES,STAT=ERR)
            IF(ERR/=0) CALL FLAG_ERROR("Could not allocate constraint matrices linear matrices.",ERR,ERROR,*999)
            CONSTRAINT_MATRICES%LINEAR_MATRICES%CONSTRAINT_MATRICES=>CONSTRAINT_MATRICES
            CONSTRAINT_MATRICES%LINEAR_MATRICES%NUMBER_OF_LINEAR_MATRICES=LINEAR_MAPPING%NUMBER_OF_LINEAR_CONSTRAINT_MATRICES
            ALLOCATE(CONSTRAINT_MATRICES%LINEAR_MATRICES%MATRICES(LINEAR_MAPPING%NUMBER_OF_LINEAR_CONSTRAINT_MATRICES),STAT=ERR)
            IF(ERR/=0) CALL FLAG_ERROR("Could not allocate constraint matrices linear matrices matrices.",ERR,ERROR,*999)
            DO matrix_idx=1,LINEAR_MAPPING%NUMBER_OF_LINEAR_CONSTRAINT_MATRICES
              NULLIFY(CONSTRAINT_MATRICES%LINEAR_MATRICES%MATRICES(matrix_idx)%PTR)
              CALL CONSTRAINT_MATRIX_LINEAR_INITIALISE(CONSTRAINT_MATRICES%LINEAR_MATRICES,matrix_idx,ERR,ERROR,*999)
            ENDDO !matrix_idx
          ENDIF
        ENDIF
      ELSE
        CALL FLAG_ERROR("Constraint matrices equations mapping is not associated.",ERR,ERROR,*998)        
      ENDIF
    ELSE
      CALL FLAG_ERROR("Constraint matrices is not associated.",ERR,ERROR,*998)
    ENDIF
    
    CALL EXITS("CONSTRAINT_MATRICES_LINEAR_INITIALISE")
    RETURN
999 CALL CONSTRAINT_MATRICES_LINEAR_FINALISE(CONSTRAINT_MATRICES%LINEAR_MATRICES,DUMMY_ERR,DUMMY_ERROR,*998)
998 CALL ERRORS("CONSTRAINT_MATRICES_LINEAR_INITIALISE",ERR,ERROR)
    CALL EXITS("CONSTRAINT_MATRICES_LINEAR_INITIALISE")
    RETURN 1
  END SUBROUTINE CONSTRAINT_MATRICES_LINEAR_INITIALISE
  
  !
  !================================================================================================================================
  !

  !>Finalises the constraint matrices nonlinear matrices and deallocates all memory
  SUBROUTINE CONSTRAINT_MATRICES_NONLINEAR_FINALISE(NONLINEAR_MATRICES,ERR,ERROR,*)

    !Argument variables
    TYPE(CONSTRAINT_MATRICES_NONLINEAR_TYPE), POINTER :: NONLINEAR_MATRICES !<A pointer to the constraint matrices nonlinear matrices to finalise
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: matrix_idx
     
    CALL ENTERS("CONSTRAINT_MATRICES_NONLINEAR_FINALISE",ERR,ERROR,*999)

    IF(ASSOCIATED(NONLINEAR_MATRICES)) THEN
      IF(ALLOCATED(NONLINEAR_MATRICES%JACOBIANS)) THEN
        DO matrix_idx=1,NONLINEAR_MATRICES%NUMBER_OF_JACOBIANS
          CALL CONSTRAINT_JACOBIAN_FINALISE(NONLINEAR_MATRICES%JACOBIANS(matrix_idx)%PTR,ERR,ERROR,*999)
        ENDDO
        DEALLOCATE(NONLINEAR_MATRICES%JACOBIANS)
      ENDIF
      IF(ASSOCIATED(NONLINEAR_MATRICES%RESIDUAL)) CALL DISTRIBUTED_VECTOR_DESTROY(NONLINEAR_MATRICES%RESIDUAL,ERR,ERROR,*999)
      CALL CONSTRAINT_MATRICES_ELEMENT_VECTOR_FINALISE(NONLINEAR_MATRICES%ELEMENT_RESIDUAL,ERR,ERROR,*999)
      DEALLOCATE(NONLINEAR_MATRICES)
    ENDIF
    
    CALL EXITS("CONSTRAINT_MATRICES_NONLINEAR_FINALISE")
    RETURN
999 CALL ERRORS("CONSTRAINT_MATRICES_NONLINEAR_FINALISE",ERR,ERROR)
    CALL EXITS("CONSTRAINT_MATRICES_NONLINEAR_FINALISE")
    RETURN 1
  END SUBROUTINE CONSTRAINT_MATRICES_NONLINEAR_FINALISE
  
  !
  !================================================================================================================================
  !

  !>Initialises the constraint matrices nonlinear matrices
  SUBROUTINE CONSTRAINT_MATRICES_NONLINEAR_INITIALISE(CONSTRAINT_MATRICES,ERR,ERROR,*)

    !Argument variables
    TYPE(CONSTRAINT_MATRICES_TYPE), POINTER :: CONSTRAINT_MATRICES !<A pointer to the constraint matrices to initialise the nonlinear matrices for
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: matrix_idx,DUMMY_ERR
    TYPE(CONSTRAINT_MAPPING_TYPE), POINTER :: CONSTRAINT_MAPPING
    TYPE(CONSTRAINT_MAPPING_NONLINEAR_TYPE), POINTER :: NONLINEAR_MAPPING
    TYPE(VARYING_STRING) :: DUMMY_ERROR
    
    CALL ENTERS("CONSTRAINT_MATRICES_NONLINEAR_INITIALISE",ERR,ERROR,*998)

    IF(ASSOCIATED(CONSTRAINT_MATRICES)) THEN
      CONSTRAINT_MAPPING=>CONSTRAINT_MATRICES%CONSTRAINT_MAPPING
      IF(ASSOCIATED(CONSTRAINT_MAPPING)) THEN
        NONLINEAR_MAPPING=>CONSTRAINT_MAPPING%NONLINEAR_MAPPING
        IF(ASSOCIATED(NONLINEAR_MAPPING)) THEN
          IF(ASSOCIATED(CONSTRAINT_MATRICES%NONLINEAR_MATRICES)) THEN
            CALL FLAG_ERROR("Constraint matrices nonlinear matrices is already associated.",ERR,ERROR,*998)
          ELSE
            ALLOCATE(CONSTRAINT_MATRICES%NONLINEAR_MATRICES,STAT=ERR)
            IF(ERR/=0) CALL FLAG_ERROR("Could not allocate constraint matrices nonlinear matrices.",ERR,ERROR,*999)
            CONSTRAINT_MATRICES%NONLINEAR_MATRICES%CONSTRAINT_MATRICES=>CONSTRAINT_MATRICES
            CONSTRAINT_MATRICES%NONLINEAR_MATRICES%UPDATE_RESIDUAL=.TRUE.
            CONSTRAINT_MATRICES%NONLINEAR_MATRICES%FIRST_ASSEMBLY=.TRUE.
            NULLIFY(CONSTRAINT_MATRICES%NONLINEAR_MATRICES%RESIDUAL)
            CALL CONSTRAINT_MATRICES_ELEMENT_VECTOR_INITIALISE( &
              & CONSTRAINT_MATRICES%NONLINEAR_MATRICES%ELEMENT_RESIDUAL,ERR,ERROR,*999)
            CONSTRAINT_MATRICES%NONLINEAR_MATRICES%NUMBER_OF_JACOBIANS=NONLINEAR_MAPPING%NUMBER_OF_JACOBIAN_CONSTRAINT_MATRICES
            ALLOCATE(CONSTRAINT_MATRICES%NONLINEAR_MATRICES% &
              & JACOBIANS(NONLINEAR_MAPPING%NUMBER_OF_JACOBIAN_CONSTRAINT_MATRICES),STAT=ERR)
            IF(ERR/=0) CALL FLAG_ERROR("Could not allocate constraint matrices Jacobian matrices.",ERR,ERROR,*999)
            DO matrix_idx=1,NONLINEAR_MAPPING%NUMBER_OF_JACOBIAN_CONSTRAINT_MATRICES
              NULLIFY(CONSTRAINT_MATRICES%NONLINEAR_MATRICES%JACOBIANS(matrix_idx)%PTR)
              CALL CONSTRAINT_JACOBIAN_INITIALISE(CONSTRAINT_MATRICES%NONLINEAR_MATRICES,matrix_idx,ERR,ERROR,*999)
            ENDDO !matrix_idx
          ENDIF
        ENDIF
      ELSE
        CALL FLAG_ERROR("Constraint matrices equations mapping is not associated.",ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Constraint matrices is not associated.",ERR,ERROR,*998)
    ENDIF
    
    CALL EXITS("CONSTRAINT_MATRICES_NONLINEAR_INITIALISE")
    RETURN
999 CALL CONSTRAINT_MATRICES_NONLINEAR_FINALISE(CONSTRAINT_MATRICES%NONLINEAR_MATRICES,DUMMY_ERR,DUMMY_ERROR,*998)
998 CALL ERRORS("CONSTRAINT_MATRICES_NONLINEAR_INITIALISE",ERR,ERROR)
    CALL EXITS("CONSTRAINT_MATRICES_NONLINEAR_INITIALISE")
    RETURN 1
  END SUBROUTINE CONSTRAINT_MATRICES_NONLINEAR_INITIALISE
  
  !
  !================================================================================================================================
  !

  !>Outputs the constraint matrices
  SUBROUTINE CONSTRAINT_MATRICES_OUTPUT(ID,CONSTRAINT_MATRICES,ERR,ERROR,*)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ID !<The ID of the ouptut stream
    TYPE(CONSTRAINT_MATRICES_TYPE), POINTER :: CONSTRAINT_MATRICES !<A pointer to the constraint matrices
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: matrix_idx
    TYPE(CONSTRAINT_MATRICES_DYNAMIC_TYPE), POINTER :: DYNAMIC_MATRICES
    TYPE(CONSTRAINT_MATRICES_LINEAR_TYPE), POINTER :: LINEAR_MATRICES
    TYPE(CONSTRAINT_MATRICES_NONLINEAR_TYPE), POINTER :: NONLINEAR_MATRICES
    TYPE(CONSTRAINT_RHS_TYPE), POINTER :: RHS_VECTOR
    TYPE(CONSTRAINT_MATRIX_TYPE), POINTER :: CONSTRAINT_MATRIX
    
    CALL ENTERS("CONSTRAINT_MATRICES_OUTPUT",ERR,ERROR,*999)
    
    IF(ASSOCIATED(CONSTRAINT_MATRICES)) THEN
      IF(CONSTRAINT_MATRICES%CONSTRAINT_MATRICES_FINISHED) THEN
        CALL WRITE_STRING(ID,"",ERR,ERROR,*999)
        CALL WRITE_STRING(ID,"Constraint matrices:",ERR,ERROR,*999)
        DYNAMIC_MATRICES=>CONSTRAINT_MATRICES%DYNAMIC_MATRICES
        IF(ASSOCIATED(DYNAMIC_MATRICES)) THEN
          CALL WRITE_STRING(ID,"Dynamic matrices:",ERR,ERROR,*999)
          CALL WRITE_STRING_VALUE(ID,"Number of dynamic matrices = ",DYNAMIC_MATRICES%NUMBER_OF_DYNAMIC_MATRICES,ERR,ERROR,*999)
          DO matrix_idx=1,DYNAMIC_MATRICES%NUMBER_OF_DYNAMIC_MATRICES
            CONSTRAINT_MATRIX=>DYNAMIC_MATRICES%MATRICES(matrix_idx)%PTR
            IF(ASSOCIATED(CONSTRAINT_MATRIX)) THEN
              CALL WRITE_STRING_VALUE(ID,"Constraint matrix : ",matrix_idx,ERR,ERROR,*999)
              CALL DISTRIBUTED_MATRIX_OUTPUT(ID,CONSTRAINT_MATRIX%MATRIX,ERR,ERROR,*999)
              IF(CONSTRAINT_MATRIX%HAS_TRANSPOSE) THEN
                CALL WRITE_STRING(ID,"Transposed matrix:",ERR,ERROR,*999)
                CALL DISTRIBUTED_MATRIX_OUTPUT(ID,CONSTRAINT_MATRIX%MATRIX_TRANSPOSE,ERR,ERROR,*999)
              ENDIF
            ELSE
              CALL FLAG_ERROR("Constraint matrix is not associated.",ERR,ERROR,*999)
            ENDIF
          ENDDO !matrix_idx
        ENDIF
        LINEAR_MATRICES=>CONSTRAINT_MATRICES%LINEAR_MATRICES
        IF(ASSOCIATED(LINEAR_MATRICES)) THEN
          CALL WRITE_STRING(ID,"Linear matrices:",ERR,ERROR,*999)
          CALL WRITE_STRING_VALUE(ID,"Number of linear matrices = ",LINEAR_MATRICES%NUMBER_OF_LINEAR_MATRICES,ERR,ERROR,*999)
          DO matrix_idx=1,LINEAR_MATRICES%NUMBER_OF_LINEAR_MATRICES
            CONSTRAINT_MATRIX=>LINEAR_MATRICES%MATRICES(matrix_idx)%PTR
            IF(ASSOCIATED(CONSTRAINT_MATRIX)) THEN
              CALL WRITE_STRING_VALUE(ID,"Constraint matrix : ",matrix_idx,ERR,ERROR,*999)
              CALL DISTRIBUTED_MATRIX_OUTPUT(ID,CONSTRAINT_MATRIX%MATRIX,ERR,ERROR,*999)
              IF(CONSTRAINT_MATRIX%HAS_TRANSPOSE) THEN
                CALL WRITE_STRING(ID,"Transposed matrix:",ERR,ERROR,*999)
                CALL DISTRIBUTED_MATRIX_OUTPUT(ID,CONSTRAINT_MATRIX%MATRIX_TRANSPOSE,ERR,ERROR,*999)
              ENDIF
            ELSE
              CALL FLAG_ERROR("Constraint matrix is not associated.",ERR,ERROR,*999)
            ENDIF
          ENDDO !matrix_idx
        ENDIF
        NONLINEAR_MATRICES=>CONSTRAINT_MATRICES%NONLINEAR_MATRICES
        IF(ASSOCIATED(NONLINEAR_MATRICES)) THEN
          CALL WRITE_STRING(ID,"Nonlinear vectors:",ERR,ERROR,*999)
          IF(ASSOCIATED(NONLINEAR_MATRICES%RESIDUAL)) THEN
            CALL WRITE_STRING(ID,"Residual vector:",ERR,ERROR,*999)
            CALL DISTRIBUTED_VECTOR_OUTPUT(ID,NONLINEAR_MATRICES%RESIDUAL,ERR,ERROR,*999)
          ELSE
            CALL FLAG_ERROR("Nonlinear matrices residual is not associated.",ERR,ERROR,*999)
          ENDIF
        ENDIF
        RHS_VECTOR=>CONSTRAINT_MATRICES%RHS_VECTOR
        IF(ASSOCIATED(RHS_VECTOR)) THEN
          CALL WRITE_STRING(ID,"RHS vector:",ERR,ERROR,*999)
          CALL DISTRIBUTED_VECTOR_OUTPUT(ID,RHS_VECTOR%RHS_VECTOR,ERR,ERROR,*999)
        ENDIF
      ELSE
        CALL FLAG_ERROR("Constraint matrices have not been finished.",ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Constraint matrices is not associated.",ERR,ERROR,*999)
    ENDIF
    
    CALL EXITS("CONSTRAINT_MATRICES_OUTPUT")
    RETURN
999 CALL ERRORS("CONSTRAINT_MATRICES_OUTPUT",ERR,ERROR)
    CALL EXITS("CONSTRAINT_MATRICES_OUTPUT")
    RETURN 1
  END SUBROUTINE CONSTRAINT_MATRICES_OUTPUT
  
  !
  !================================================================================================================================
  !

  !>Finalises the constraint matrices RHS vector and deallocates all memory
  SUBROUTINE CONSTRAINT_MATRICES_RHS_FINALISE(RHS_VECTOR,ERR,ERROR,*)

    !Argument variables
    TYPE(CONSTRAINT_RHS_TYPE), POINTER :: RHS_VECTOR !<A pointer to the constraint matrices RHS vector to finalise
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
     
    CALL ENTERS("CONSTRAINT_MATRICES_RHS_FINALISE",ERR,ERROR,*999)

    IF(ASSOCIATED(RHS_VECTOR)) THEN
      IF(ASSOCIATED(RHS_VECTOR%RHS_VECTOR)) CALL DISTRIBUTED_VECTOR_DESTROY(RHS_VECTOR%RHS_VECTOR,ERR,ERROR,*999)
      CALL CONSTRAINT_MATRICES_ELEMENT_VECTOR_FINALISE(RHS_VECTOR%ELEMENT_VECTOR,ERR,ERROR,*999)
      DEALLOCATE(RHS_VECTOR)
    ENDIF      
     
    CALL EXITS("CONSTRAINT_MATRICES_RHS_FINALISE")
    RETURN
999 CALL ERRORS("CONSTRAINT_MATRICES_RHS_FINALISE",ERR,ERROR)
    CALL EXITS("CONSTRAINT_MATRICES_RHS_FINALISE")
    RETURN 1
  END SUBROUTINE CONSTRAINT_MATRICES_RHS_FINALISE
  
  !
  !================================================================================================================================
  !

  !>Initialises the constraint matrices RHS vector
  SUBROUTINE CONSTRAINT_MATRICES_RHS_INITIALISE(CONSTRAINT_MATRICES,ERR,ERROR,*)

    !Argument variables
    TYPE(CONSTRAINT_MATRICES_TYPE), POINTER :: CONSTRAINT_MATRICES !<A pointer to the constraint matrices to initialise the rhs vector for
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DUMMY_ERR
    TYPE(CONSTRAINT_MAPPING_TYPE), POINTER :: CONSTRAINT_MAPPING
    TYPE(CONSTRAINT_MAPPING_RHS_TYPE), POINTER :: RHS_MAPPING
    TYPE(VARYING_STRING) :: DUMMY_ERROR
    
    CALL ENTERS("CONSTRAINT_MATRICES_RHS_INITIALISE",ERR,ERROR,*998)

    IF(ASSOCIATED(CONSTRAINT_MATRICES)) THEN
      CONSTRAINT_MAPPING=>CONSTRAINT_MATRICES%CONSTRAINT_MAPPING
      IF(ASSOCIATED(CONSTRAINT_MAPPING)) THEN
        RHS_MAPPING=>CONSTRAINT_MAPPING%RHS_MAPPING
        IF(ASSOCIATED(RHS_MAPPING)) THEN
          IF(ASSOCIATED(CONSTRAINT_MATRICES%RHS_VECTOR)) THEN
            CALL FLAG_ERROR("Constraint matrices RHS vector is already associated.",ERR,ERROR,*998)
          ELSE
            ALLOCATE(CONSTRAINT_MATRICES%RHS_VECTOR,STAT=ERR)
            IF(ERR/=0) CALL FLAG_ERROR("Could not allocate constraint matrices RHS vector.",ERR,ERROR,*999)
            CONSTRAINT_MATRICES%RHS_VECTOR%UPDATE_VECTOR=.TRUE.
            CONSTRAINT_MATRICES%RHS_VECTOR%FIRST_ASSEMBLY=.TRUE.
            NULLIFY(CONSTRAINT_MATRICES%RHS_VECTOR%RHS_VECTOR)
            CALL CONSTRAINT_MATRICES_ELEMENT_VECTOR_INITIALISE(CONSTRAINT_MATRICES%RHS_VECTOR%ELEMENT_VECTOR,ERR,ERROR,*999)
          ENDIF
        ENDIF
      ELSE
        CALL FLAG_ERROR("Constraint matrices equation mapping is not associated.",ERR,ERROR,*998)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Constraint matrices is not associated.",ERR,ERROR,*998)
    ENDIF
    
    CALL EXITS("CONSTRAINT_MATRICES_RHS_INITIALISE")
    RETURN
999 CALL CONSTRAINT_MATRICES_RHS_FINALISE(CONSTRAINT_MATRICES%RHS_VECTOR,DUMMY_ERR,DUMMY_ERROR,*998)
998 CALL ERRORS("CONSTRAINT_MATRICES_RHS_INITIALISE",ERR,ERROR)
    CALL EXITS("CONSTRAINT_MATRICES_RHS_INITIALISE")
    RETURN 1
  END SUBROUTINE CONSTRAINT_MATRICES_RHS_INITIALISE
  
  !
  !================================================================================================================================
  !

  !>Sets the storage type (sparsity) of the dynamic constraint matrices
  SUBROUTINE CONSTRAINT_MATRICES_DYNAMIC_STORAGE_TYPE_SET(CONSTRAINT_MATRICES,STORAGE_TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(CONSTRAINT_MATRICES_TYPE), POINTER :: CONSTRAINT_MATRICES !<A pointer to the eqautions matrices
    INTEGER(INTG), INTENT(IN) :: STORAGE_TYPE(:) !<STORAGE_TYPE(matrix_idx). The storage type for the matrix_idx'th dynamic constraint matrix
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: matrix_idx
    TYPE(CONSTRAINT_MATRICES_DYNAMIC_TYPE), POINTER :: DYNAMIC_MATRICES
    TYPE(CONSTRAINT_MATRIX_TYPE), POINTER :: CONSTRAINT_MATRIX
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CONSTRAINT_MATRICES_DYNAMIC_STORAGE_TYPE_SET",ERR,ERROR,*999)

    IF(ASSOCIATED(CONSTRAINT_MATRICES)) THEN
      IF(CONSTRAINT_MATRICES%CONSTRAINT_MATRICES_FINISHED) THEN
        CALL FLAG_ERROR("Constraint matrices have already been finished.",ERR,ERROR,*999)
      ELSE
        DYNAMIC_MATRICES=>CONSTRAINT_MATRICES%DYNAMIC_MATRICES
        IF(ASSOCIATED(DYNAMIC_MATRICES)) THEN
          IF(SIZE(STORAGE_TYPE,1)==DYNAMIC_MATRICES%NUMBER_OF_DYNAMIC_MATRICES) THEN
            DO matrix_idx=1,DYNAMIC_MATRICES%NUMBER_OF_DYNAMIC_MATRICES
              CONSTRAINT_MATRIX=>DYNAMIC_MATRICES%MATRICES(matrix_idx)%PTR
              IF(ASSOCIATED(CONSTRAINT_MATRIX)) THEN
                SELECT CASE(STORAGE_TYPE(matrix_idx))
                CASE(DISTRIBUTED_MATRIX_BLOCK_STORAGE_TYPE)
                  CONSTRAINT_MATRIX%STORAGE_TYPE=DISTRIBUTED_MATRIX_BLOCK_STORAGE_TYPE
                CASE(DISTRIBUTED_MATRIX_DIAGONAL_STORAGE_TYPE)
                  CONSTRAINT_MATRIX%STORAGE_TYPE=DISTRIBUTED_MATRIX_DIAGONAL_STORAGE_TYPE        
                CASE(DISTRIBUTED_MATRIX_COLUMN_MAJOR_STORAGE_TYPE)
                  CONSTRAINT_MATRIX%STORAGE_TYPE=DISTRIBUTED_MATRIX_COLUMN_MAJOR_STORAGE_TYPE
                CASE(DISTRIBUTED_MATRIX_ROW_MAJOR_STORAGE_TYPE)
                  CONSTRAINT_MATRIX%STORAGE_TYPE=DISTRIBUTED_MATRIX_ROW_MAJOR_STORAGE_TYPE
                CASE(DISTRIBUTED_MATRIX_COMPRESSED_ROW_STORAGE_TYPE)
                  CONSTRAINT_MATRIX%STORAGE_TYPE=DISTRIBUTED_MATRIX_COMPRESSED_ROW_STORAGE_TYPE
                CASE(DISTRIBUTED_MATRIX_COMPRESSED_COLUMN_STORAGE_TYPE)
                  CONSTRAINT_MATRIX%STORAGE_TYPE=DISTRIBUTED_MATRIX_COMPRESSED_COLUMN_STORAGE_TYPE
                CASE(DISTRIBUTED_MATRIX_ROW_COLUMN_STORAGE_TYPE)
                  CONSTRAINT_MATRIX%STORAGE_TYPE=DISTRIBUTED_MATRIX_ROW_COLUMN_STORAGE_TYPE
                CASE DEFAULT
                  LOCAL_ERROR="The specified storage type of "//TRIM(NUMBER_TO_VSTRING(STORAGE_TYPE(matrix_idx),"*",ERR,ERROR))// &
                    & " for the dynamic matrix number "//TRIM(NUMBER_TO_VSTRING(matrix_idx,"*",ERR,ERROR))//" is invalid."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                END SELECT
              ELSE
                CALL FLAG_ERROR("Constraint matrix is not associated.",ERR,ERROR,*999)
              ENDIF
            ENDDO !matrix_idx
          ELSE
            LOCAL_ERROR="The size of the storage type array ("//TRIM(NUMBER_TO_VSTRING(SIZE(STORAGE_TYPE,1),"*",ERR,ERROR))// &
              & ") is not equal to the number of dynamic matrices ("// &
              & TRIM(NUMBER_TO_VSTRING(DYNAMIC_MATRICES%NUMBER_OF_DYNAMIC_MATRICES,"*",ERR,ERROR))//")."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          CALL FLAG_ERROR("Constraint matrices dynamic matrices is not associated.",ERR,ERROR,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FLAG_ERROR("Constraint matrices is not associated.",ERR,ERROR,*999)
    ENDIF
    
    CALL EXITS("CONSTRAINT_MATRICES_DYNAMIC_STORAGE_TYPE_SET")
    RETURN
999 CALL ERRORS("CONSTRAINT_MATRICES_DYNAMIC_STORAGE_TYPE_SET",ERR,ERROR)
    CALL EXITS("CONSTRAINT_MATRICES_DYNAMIC_STORAGE_TYPE_SET")
    RETURN 1
  END SUBROUTINE CONSTRAINT_MATRICES_DYNAMIC_STORAGE_TYPE_SET

  !
  !================================================================================================================================
  !

  !>Sets the storage type (sparsity) of the linear constraint matrices
  SUBROUTINE CONSTRAINT_MATRICES_LINEAR_STORAGE_TYPE_SET(CONSTRAINT_MATRICES,STORAGE_TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(CONSTRAINT_MATRICES_TYPE), POINTER :: CONSTRAINT_MATRICES !<A pointer to the constraint matrices
    INTEGER(INTG), INTENT(IN) :: STORAGE_TYPE(:) !<STORAGE_TYPE(matrix_idx). The storage type for the matrix_idx'th linear constraint matrix
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: matrix_idx
    TYPE(CONSTRAINT_MATRICES_LINEAR_TYPE), POINTER :: LINEAR_MATRICES
    TYPE(CONSTRAINT_MATRIX_TYPE), POINTER :: CONSTRAINT_MATRIX
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CONSTRAINT_MATRICES_LINEAR_STORAGE_TYPE_SET",ERR,ERROR,*999)

    IF(ASSOCIATED(CONSTRAINT_MATRICES)) THEN
      IF(CONSTRAINT_MATRICES%CONSTRAINT_MATRICES_FINISHED) THEN
        CALL FLAG_ERROR("Constraint matrices have been finished.",ERR,ERROR,*999)
      ELSE
        LINEAR_MATRICES=>CONSTRAINT_MATRICES%LINEAR_MATRICES
        IF(ASSOCIATED(LINEAR_MATRICES)) THEN
          IF(SIZE(STORAGE_TYPE,1)==LINEAR_MATRICES%NUMBER_OF_LINEAR_MATRICES) THEN
            DO matrix_idx=1,LINEAR_MATRICES%NUMBER_OF_LINEAR_MATRICES
              CONSTRAINT_MATRIX=>LINEAR_MATRICES%MATRICES(matrix_idx)%PTR
              IF(ASSOCIATED(CONSTRAINT_MATRIX)) THEN
                SELECT CASE(STORAGE_TYPE(matrix_idx))
                CASE(DISTRIBUTED_MATRIX_BLOCK_STORAGE_TYPE)
                  CONSTRAINT_MATRIX%STORAGE_TYPE=DISTRIBUTED_MATRIX_BLOCK_STORAGE_TYPE
                CASE(DISTRIBUTED_MATRIX_DIAGONAL_STORAGE_TYPE)
                  CONSTRAINT_MATRIX%STORAGE_TYPE=DISTRIBUTED_MATRIX_DIAGONAL_STORAGE_TYPE        
                CASE(DISTRIBUTED_MATRIX_COLUMN_MAJOR_STORAGE_TYPE)
                  CONSTRAINT_MATRIX%STORAGE_TYPE=DISTRIBUTED_MATRIX_COLUMN_MAJOR_STORAGE_TYPE
                CASE(DISTRIBUTED_MATRIX_ROW_MAJOR_STORAGE_TYPE)
                  CONSTRAINT_MATRIX%STORAGE_TYPE=DISTRIBUTED_MATRIX_ROW_MAJOR_STORAGE_TYPE
                CASE(DISTRIBUTED_MATRIX_COMPRESSED_ROW_STORAGE_TYPE)
                  CONSTRAINT_MATRIX%STORAGE_TYPE=DISTRIBUTED_MATRIX_COMPRESSED_ROW_STORAGE_TYPE
                CASE(DISTRIBUTED_MATRIX_COMPRESSED_COLUMN_STORAGE_TYPE)
                  CONSTRAINT_MATRIX%STORAGE_TYPE=DISTRIBUTED_MATRIX_COMPRESSED_COLUMN_STORAGE_TYPE
                CASE(DISTRIBUTED_MATRIX_ROW_COLUMN_STORAGE_TYPE)
                  CONSTRAINT_MATRIX%STORAGE_TYPE=DISTRIBUTED_MATRIX_ROW_COLUMN_STORAGE_TYPE
                CASE DEFAULT
                  LOCAL_ERROR="The specified storage type of "//TRIM(NUMBER_TO_VSTRING(STORAGE_TYPE(matrix_idx),"*",ERR,ERROR))// &
                    & " for the linear matrix number "//TRIM(NUMBER_TO_VSTRING(matrix_idx,"*",ERR,ERROR))//" is invalid."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                END SELECT
              ELSE
                CALL FLAG_ERROR("Constraint matrix is not associated.",ERR,ERROR,*999)
              ENDIF
            ENDDO !matrix_idx
          ELSE
            LOCAL_ERROR="The size of the storage type array ("//TRIM(NUMBER_TO_VSTRING(SIZE(STORAGE_TYPE,1),"*",ERR,ERROR))// &
              & ") is not equal to the number of linear matrices ("// &
              & TRIM(NUMBER_TO_VSTRING(LINEAR_MATRICES%NUMBER_OF_LINEAR_MATRICES,"*",ERR,ERROR))//")."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          CALL FLAG_ERROR("Constraint matrices linear matrices is not associated.",ERR,ERROR,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FLAG_ERROR("Constraint matrices is not associated.",ERR,ERROR,*999)
    ENDIF
    
    CALL EXITS("CONSTRAINT_MATRICES_LINEAR_STORAGE_TYPE_SET")
    RETURN
999 CALL ERRORS("CONSTRAINT_MATRICES_LINEAR_STORAGE_TYPE_SET",ERR,ERROR)
    CALL EXITS("CONSTRAINT_MATRICES_LINEAR_STORAGE_TYPE_SET")
    RETURN 1
  END SUBROUTINE CONSTRAINT_MATRICES_LINEAR_STORAGE_TYPE_SET

  !
  !================================================================================================================================
  !

  !>Sets the storage type (sparsity) of the nonlinear (Jacobian) constraint matrices
  SUBROUTINE CONSTRAINT_MATRICES_NONLINEAR_STORAGE_TYPE_SET_0(CONSTRAINT_MATRICES,STORAGE_TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(CONSTRAINT_MATRICES_TYPE), POINTER :: CONSTRAINT_MATRICES !<A pointer to the eqautions matrices
    INTEGER(INTG), INTENT(IN) :: STORAGE_TYPE(:) !<STORAGE_TYPE(matrix_idx). The storage type for the matrix_idx'th Jacobian constraint matrix
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: matrix_idx
    TYPE(CONSTRAINT_MATRICES_NONLINEAR_TYPE), POINTER :: NONLINEAR_MATRICES
    TYPE(CONSTRAINT_JACOBIAN_TYPE), POINTER :: JACOBIAN_MATRIX
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CONSTRAINT_MATRICES_NONLINEAR_STORAGE_TYPE_SET_0",ERR,ERROR,*999)

    IF(ASSOCIATED(CONSTRAINT_MATRICES)) THEN
      IF(CONSTRAINT_MATRICES%CONSTRAINT_MATRICES_FINISHED) THEN
        CALL FLAG_ERROR("Constraint matrices have been finished.",ERR,ERROR,*999)
      ELSE
        NONLINEAR_MATRICES=>CONSTRAINT_MATRICES%NONLINEAR_MATRICES
        IF(ASSOCIATED(NONLINEAR_MATRICES)) THEN
          IF(SIZE(STORAGE_TYPE,1)==NONLINEAR_MATRICES%NUMBER_OF_JACOBIANS) THEN
            DO matrix_idx=1,NONLINEAR_MATRICES%NUMBER_OF_JACOBIANS
              JACOBIAN_MATRIX=>NONLINEAR_MATRICES%JACOBIANS(matrix_idx)%PTR
              IF(ASSOCIATED(JACOBIAN_MATRIX)) THEN
                SELECT CASE(STORAGE_TYPE(matrix_idx))
                CASE(DISTRIBUTED_MATRIX_BLOCK_STORAGE_TYPE)
                  JACOBIAN_MATRIX%STORAGE_TYPE=DISTRIBUTED_MATRIX_BLOCK_STORAGE_TYPE
                CASE(DISTRIBUTED_MATRIX_DIAGONAL_STORAGE_TYPE)
                  JACOBIAN_MATRIX%STORAGE_TYPE=DISTRIBUTED_MATRIX_DIAGONAL_STORAGE_TYPE        
                CASE(DISTRIBUTED_MATRIX_COLUMN_MAJOR_STORAGE_TYPE)
                  JACOBIAN_MATRIX%STORAGE_TYPE=DISTRIBUTED_MATRIX_COLUMN_MAJOR_STORAGE_TYPE
                CASE(DISTRIBUTED_MATRIX_ROW_MAJOR_STORAGE_TYPE)
                  JACOBIAN_MATRIX%STORAGE_TYPE=DISTRIBUTED_MATRIX_ROW_MAJOR_STORAGE_TYPE
                CASE(DISTRIBUTED_MATRIX_COMPRESSED_ROW_STORAGE_TYPE)
                  JACOBIAN_MATRIX%STORAGE_TYPE=DISTRIBUTED_MATRIX_COMPRESSED_ROW_STORAGE_TYPE
                CASE(DISTRIBUTED_MATRIX_COMPRESSED_COLUMN_STORAGE_TYPE)
                  JACOBIAN_MATRIX%STORAGE_TYPE=DISTRIBUTED_MATRIX_COMPRESSED_COLUMN_STORAGE_TYPE
                CASE(DISTRIBUTED_MATRIX_ROW_COLUMN_STORAGE_TYPE)
                  JACOBIAN_MATRIX%STORAGE_TYPE=DISTRIBUTED_MATRIX_ROW_COLUMN_STORAGE_TYPE
                CASE DEFAULT
                  LOCAL_ERROR="The specified storage type of "//TRIM(NUMBER_TO_VSTRING(STORAGE_TYPE(matrix_idx),"*",ERR,ERROR))// &
                    & " for the Jacobian matrix is invalid."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                END SELECT
              ELSE
                CALL FLAG_ERROR("Jacobian matrix is not associated.",ERR,ERROR,*999)
              ENDIF
            ENDDO
          ELSE
            LOCAL_ERROR="The size of the storage type array ("//TRIM(NUMBER_TO_VSTRING(SIZE(STORAGE_TYPE,1),"*",ERR,ERROR))// &
              & ") is not equal to the number of Jacobian matrices ("// &
              & TRIM(NUMBER_TO_VSTRING(NONLINEAR_MATRICES%NUMBER_OF_JACOBIANS,"*",ERR,ERROR))//")."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          CALL FLAG_ERROR("Constraint matrices nonlinear matrices is not associated.",ERR,ERROR,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FLAG_ERROR("Constraint matrices is not associated.",ERR,ERROR,*999)
    ENDIF
    
    CALL EXITS("CONSTRAINT_MATRICES_NONLINEAR_STORAGE_TYPE_SET_0")
    RETURN
999 CALL ERRORS("CONSTRAINT_MATRICES_NONLINEAR_STORAGE_TYPE_SET_0",ERR,ERROR)
    CALL EXITS("CONSTRAINT_MATRICES_NONLINEAR_STORAGE_TYPE_SET_0")
    RETURN 1
  END SUBROUTINE CONSTRAINT_MATRICES_NONLINEAR_STORAGE_TYPE_SET_0

  !
  !================================================================================================================================
  !

  !>Sets the storage type (sparsity) of all nonlinear (Jacobian) constraint matrices
  SUBROUTINE CONSTRAINT_MATRICES_NONLINEAR_STORAGE_TYPE_SET_1(CONSTRAINT_MATRICES,STORAGE_TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(CONSTRAINT_MATRICES_TYPE), POINTER :: CONSTRAINT_MATRICES !<A pointer to the eqautions matrices
    INTEGER(INTG), INTENT(IN) :: STORAGE_TYPE !<STORAGE_TYPE. The storage type for all Jacobian constraint matrices
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG), ALLOCATABLE :: STORAGE_TYPES(:)
    TYPE(CONSTRAINT_MATRICES_NONLINEAR_TYPE), POINTER :: NONLINEAR_MATRICES

    CALL ENTERS("CONSTRAINT_MATRICES_NONLINEAR_STORAGE_TYPE_SET_1",ERR,ERROR,*999)

    IF(ASSOCIATED(CONSTRAINT_MATRICES)) THEN
      IF(CONSTRAINT_MATRICES%CONSTRAINT_MATRICES_FINISHED) THEN
        CALL FLAG_ERROR("Constraint matrices have been finished.",ERR,ERROR,*999)
      ELSE
        NONLINEAR_MATRICES=>CONSTRAINT_MATRICES%NONLINEAR_MATRICES
        IF(ASSOCIATED(NONLINEAR_MATRICES)) THEN
          ALLOCATE(STORAGE_TYPES(NONLINEAR_MATRICES%NUMBER_OF_JACOBIANS),STAT=ERR)
          IF(ERR/=0) CALL FLAG_ERROR("Could not allocate storage types.",ERR,ERROR,*999)
          STORAGE_TYPES=STORAGE_TYPE
          CALL CONSTRAINT_MATRICES_NONLINEAR_STORAGE_TYPE_SET_0(CONSTRAINT_MATRICES,STORAGE_TYPES,ERR,ERROR,*999)
          DEALLOCATE(STORAGE_TYPES)
        ELSE
          CALL FLAG_ERROR("Constraint matrices nonlinear matrices is not associated.",ERR,ERROR,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FLAG_ERROR("Constraint matrices is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("CONSTRAINT_MATRICES_NONLINEAR_STORAGE_TYPE_SET_1")
    RETURN
999 CALL ERRORS("CONSTRAINT_MATRICES_NONLINEAR_STORAGE_TYPE_SET_1",ERR,ERROR)
    CALL EXITS("CONSTRAINT_MATRICES_NONLINEAR_STORAGE_TYPE_SET_1")
    RETURN 1
  END SUBROUTINE CONSTRAINT_MATRICES_NONLINEAR_STORAGE_TYPE_SET_1

  !
  !================================================================================================================================
  !

  !>Sets the structure (sparsity) of the dynamic constraint matrices
  SUBROUTINE CONSTRAINT_MATRICES_DYNAMIC_STRUCTURE_TYPE_SET(CONSTRAINT_MATRICES,STRUCTURE_TYPE,ERR,ERROR,*)
    
    !Argument variables
    TYPE(CONSTRAINT_MATRICES_TYPE), POINTER :: CONSTRAINT_MATRICES !<A pointer to the constraint matrices
    INTEGER(INTG), INTENT(IN) :: STRUCTURE_TYPE(:) !<STRUCTURE_TYPE(matrix_idx). The storage type for the matrix_idx'th dynamic constraint matrix
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: matrix_idx
    TYPE(CONSTRAINT_MATRICES_DYNAMIC_TYPE), POINTER :: DYNAMIC_MATRICES
    TYPE(CONSTRAINT_MATRIX_TYPE), POINTER :: CONSTRAINT_MATRIX
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CONSTRAINT_MATRICES_DYNAMIC_STRUCTURE_TYPE_SET",ERR,ERROR,*999)

    IF(ASSOCIATED(CONSTRAINT_MATRICES)) THEN
      IF(CONSTRAINT_MATRICES%CONSTRAINT_MATRICES_FINISHED) THEN
        CALL FLAG_ERROR("Constraint matrices have been finished.",ERR,ERROR,*999)
      ELSE
        DYNAMIC_MATRICES=>CONSTRAINT_MATRICES%DYNAMIC_MATRICES
        IF(ASSOCIATED(DYNAMIC_MATRICES)) THEN
          IF(SIZE(STRUCTURE_TYPE,1)==DYNAMIC_MATRICES%NUMBER_OF_DYNAMIC_MATRICES) THEN
           DO matrix_idx=1,DYNAMIC_MATRICES%NUMBER_OF_DYNAMIC_MATRICES
              CONSTRAINT_MATRIX=>DYNAMIC_MATRICES%MATRICES(matrix_idx)%PTR
              IF(ASSOCIATED(CONSTRAINT_MATRIX)) THEN
                SELECT CASE(STRUCTURE_TYPE(matrix_idx))
                CASE(CONSTRAINT_MATRIX_NO_STRUCTURE)
                  CONSTRAINT_MATRIX%STRUCTURE_TYPE=CONSTRAINT_MATRIX_NO_STRUCTURE
                CASE(CONSTRAINT_MATRIX_FEM_STRUCTURE)
                  CONSTRAINT_MATRIX%STRUCTURE_TYPE=CONSTRAINT_MATRIX_FEM_STRUCTURE
                CASE(CONSTRAINT_MATRIX_DIAGONAL_STRUCTURE)
                  CONSTRAINT_MATRIX%STRUCTURE_TYPE=CONSTRAINT_MATRIX_DIAGONAL_STRUCTURE
                CASE DEFAULT
                  LOCAL_ERROR="The specified strucutre type of "// &
                    & TRIM(NUMBER_TO_VSTRING(STRUCTURE_TYPE(matrix_idx),"*",ERR,ERROR))//" for dynamic matrix number "// &
                    & TRIM(NUMBER_TO_VSTRING(matrix_idx,"*",ERR,ERROR))//" is invalid."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                END SELECT
              ELSE
                CALL FLAG_ERROR("Constraint matrix is not associated.",ERR,ERROR,*999)
              ENDIF
            ENDDO !matrix_idx
          ELSE
            LOCAL_ERROR="The size of the structure type array ("//TRIM(NUMBER_TO_VSTRING(SIZE(STRUCTURE_TYPE,1),"*",ERR,ERROR))// &
              & ") is not equal to the number of dynamic matrices ("// &
              & TRIM(NUMBER_TO_VSTRING(DYNAMIC_MATRICES%NUMBER_OF_DYNAMIC_MATRICES,"*",ERR,ERROR))//")."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          CALL FLAG_ERROR("Constraint matrices dynamic matrices is not associated.",ERR,ERROR,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FLAG_ERROR("Constraint matrices is not associated.",ERR,ERROR,*999)
    ENDIF
    
    CALL EXITS("CONSTRAINT_MATRICES_DYNAMIC_STRUCTURE_TYPE_SET")
    RETURN
999 CALL ERRORS("CONSTRAINT_MATRICES_DYNAMIC_STRUCTURE_TYPE_SET",ERR,ERROR)
    CALL EXITS("CONSTRAINT_MATRICES_DYNAMIC_STRUCTURE_TYPE_SET")
    RETURN 1
  END SUBROUTINE CONSTRAINT_MATRICES_DYNAMIC_STRUCTURE_TYPE_SET
  
  !
  !================================================================================================================================
  !

  !>Sets the structure (sparsity) of the linear constraint matrices
  SUBROUTINE CONSTRAINT_MATRICES_LINEAR_STRUCTURE_TYPE_SET(CONSTRAINT_MATRICES,STRUCTURE_TYPE,ERR,ERROR,*)
    
    !Argument variables
    TYPE(CONSTRAINT_MATRICES_TYPE), POINTER :: CONSTRAINT_MATRICES !<A pointer to the constraint matrices
    INTEGER(INTG), INTENT(IN) :: STRUCTURE_TYPE(:) !<STRUCTURE_TYPE(matrix_idx). The storage type for the matrix_idx'th linear constraint matrix
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: matrix_idx
    TYPE(CONSTRAINT_MATRICES_LINEAR_TYPE), POINTER :: LINEAR_MATRICES
    TYPE(CONSTRAINT_MATRIX_TYPE), POINTER :: CONSTRAINT_MATRIX
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CONSTRAINT_MATRICES_LINEAR_STRUCTURE_TYPE_SET",ERR,ERROR,*999)

    IF(ASSOCIATED(CONSTRAINT_MATRICES)) THEN
      IF(CONSTRAINT_MATRICES%CONSTRAINT_MATRICES_FINISHED) THEN
        CALL FLAG_ERROR("Constraint matrices have been finished.",ERR,ERROR,*999)
      ELSE
        LINEAR_MATRICES=>CONSTRAINT_MATRICES%LINEAR_MATRICES
        IF(ASSOCIATED(LINEAR_MATRICES)) THEN
          IF(SIZE(STRUCTURE_TYPE,1)==LINEAR_MATRICES%NUMBER_OF_LINEAR_MATRICES) THEN
            DO matrix_idx=1,LINEAR_MATRICES%NUMBER_OF_LINEAR_MATRICES
              CONSTRAINT_MATRIX=>LINEAR_MATRICES%MATRICES(matrix_idx)%PTR
              IF(ASSOCIATED(CONSTRAINT_MATRIX)) THEN
                SELECT CASE(STRUCTURE_TYPE(matrix_idx))
                CASE(CONSTRAINT_MATRIX_NO_STRUCTURE)
                  CONSTRAINT_MATRIX%STRUCTURE_TYPE=CONSTRAINT_MATRIX_NO_STRUCTURE
                CASE(CONSTRAINT_MATRIX_FEM_STRUCTURE)
                  CONSTRAINT_MATRIX%STRUCTURE_TYPE=CONSTRAINT_MATRIX_FEM_STRUCTURE
                CASE(CONSTRAINT_MATRIX_DIAGONAL_STRUCTURE)
                  CONSTRAINT_MATRIX%STRUCTURE_TYPE=CONSTRAINT_MATRIX_DIAGONAL_STRUCTURE
                CASE DEFAULT
                  LOCAL_ERROR="The specified strucutre type of "// &
                    & TRIM(NUMBER_TO_VSTRING(STRUCTURE_TYPE(matrix_idx),"*",ERR,ERROR))//" for linear matrix number "// &
                    & TRIM(NUMBER_TO_VSTRING(matrix_idx,"*",ERR,ERROR))//" is invalid."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                END SELECT
              ELSE
                CALL FLAG_ERROR("Constraint matrix is not associated.",ERR,ERROR,*999)
              ENDIF
            ENDDO !matrix_idx
          ELSE
            LOCAL_ERROR="The size of the structure type array ("//TRIM(NUMBER_TO_VSTRING(SIZE(STRUCTURE_TYPE,1),"*",ERR,ERROR))// &
              & ") is not equal to the number of linear matrices ("// &
              & TRIM(NUMBER_TO_VSTRING(LINEAR_MATRICES%NUMBER_OF_LINEAR_MATRICES,"*",ERR,ERROR))//")."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          CALL FLAG_ERROR("Constraint matrices linear matrices is not associated.",ERR,ERROR,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FLAG_ERROR("Constraint matrices is not associated.",ERR,ERROR,*999)
    ENDIF
    
    CALL EXITS("CONSTRAINT_MATRICES_LINEAR_STRUCTURE_TYPE_SET")
    RETURN
999 CALL ERRORS("CONSTRAINT_MATRICES_LINEAR_STRUCTURE_TYPE_SET",ERR,ERROR)
    CALL EXITS("CONSTRAINT_MATRICES_LINEAR_STRUCTURE_TYPE_SET")
    RETURN 1
  END SUBROUTINE CONSTRAINT_MATRICES_LINEAR_STRUCTURE_TYPE_SET
  
  !
  !================================================================================================================================
  !

  !>Sets the structure (sparsity) of the nonlinear (Jacobian) constraint matrices
  SUBROUTINE CONSTRAINT_MATRICES_NONLINEAR_STRUCTURE_TYPE_SET_0(CONSTRAINT_MATRICES,STRUCTURE_TYPE,ERR,ERROR,*)
    
    !Argument variables
    TYPE(CONSTRAINT_MATRICES_TYPE), POINTER :: CONSTRAINT_MATRICES !<A pointer to the constraint matrices
    INTEGER(INTG), INTENT(IN) :: STRUCTURE_TYPE(:) !<STRUCTURE_TYPE(matrix_idx). The structure type for the matrix_idx'th Jacobian constraint matrix
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: matrix_idx
    TYPE(CONSTRAINT_MATRICES_NONLINEAR_TYPE), POINTER :: NONLINEAR_MATRICES
    TYPE(CONSTRAINT_JACOBIAN_TYPE), POINTER :: JACOBIAN_MATRIX
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CONSTRAINT_MATRICES_NONLINEAR_STRUCTURE_TYPE_SET_0",ERR,ERROR,*999)

    IF(ASSOCIATED(CONSTRAINT_MATRICES)) THEN
      IF(CONSTRAINT_MATRICES%CONSTRAINT_MATRICES_FINISHED) THEN
        CALL FLAG_ERROR("Constraint matrices have been finished.",ERR,ERROR,*999)
      ELSE
        NONLINEAR_MATRICES=>CONSTRAINT_MATRICES%NONLINEAR_MATRICES
        IF(ASSOCIATED(NONLINEAR_MATRICES)) THEN
          IF(SIZE(STRUCTURE_TYPE,1)==NONLINEAR_MATRICES%NUMBER_OF_JACOBIANS) THEN
            DO matrix_idx=1,NONLINEAR_MATRICES%NUMBER_OF_JACOBIANS
              JACOBIAN_MATRIX=>NONLINEAR_MATRICES%JACOBIANS(matrix_idx)%PTR
              IF(ASSOCIATED(JACOBIAN_MATRIX)) THEN
                SELECT CASE(STRUCTURE_TYPE(matrix_idx))
                CASE(CONSTRAINT_MATRIX_NO_STRUCTURE)
                  JACOBIAN_MATRIX%STRUCTURE_TYPE=CONSTRAINT_MATRIX_NO_STRUCTURE
                CASE(CONSTRAINT_MATRIX_FEM_STRUCTURE)
                  JACOBIAN_MATRIX%STRUCTURE_TYPE=CONSTRAINT_MATRIX_FEM_STRUCTURE
                CASE(CONSTRAINT_MATRIX_DIAGONAL_STRUCTURE)
                  JACOBIAN_MATRIX%STRUCTURE_TYPE=CONSTRAINT_MATRIX_DIAGONAL_STRUCTURE
                CASE DEFAULT
                  LOCAL_ERROR="The specified strucutre type of "// &
                    & TRIM(NUMBER_TO_VSTRING(STRUCTURE_TYPE(matrix_idx),"*",ERR,ERROR))//" for the Jacobian matrix is invalid."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                END SELECT
              ELSE
                CALL FLAG_ERROR("Constraint matrix is not associated.",ERR,ERROR,*999)
              ENDIF
            ENDDO
          ELSE
            LOCAL_ERROR="The size of the structure type array ("//TRIM(NUMBER_TO_VSTRING(SIZE(STRUCTURE_TYPE,1),"*",ERR,ERROR))// &
              & ") is not equal to the number of Jacobian matrices ("// &
              & TRIM(NUMBER_TO_VSTRING(NONLINEAR_MATRICES%NUMBER_OF_JACOBIANS,"*",ERR,ERROR))//")."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          CALL FLAG_ERROR("Constraint matrices nonlinear matrices is not associated.",ERR,ERROR,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FLAG_ERROR("Constraint matrices is not associated.",ERR,ERROR,*999)
    ENDIF
    
    CALL EXITS("CONSTRAINT_MATRICES_NONLINEAR_STRUCTURE_TYPE_SET_0")
    RETURN
999 CALL ERRORS("CONSTRAINT_MATRICES_NONLINEAR_STRUCTURE_TYPE_SET_0",ERR,ERROR)
    CALL EXITS("CONSTRAINT_MATRICES_NONLINEAR_STRUCTURE_TYPE_SET_0")
    RETURN 1
  END SUBROUTINE CONSTRAINT_MATRICES_NONLINEAR_STRUCTURE_TYPE_SET_0

  !
  !================================================================================================================================
  !

  !>Sets the structure (sparsity) of all nonlinear (Jacobian) constraint matrices
  SUBROUTINE CONSTRAINT_MATRICES_NONLINEAR_STRUCTURE_TYPE_SET_1(CONSTRAINT_MATRICES,STRUCTURE_TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(CONSTRAINT_MATRICES_TYPE), POINTER :: CONSTRAINT_MATRICES !<A pointer to the constraint matrices
    INTEGER(INTG), INTENT(IN) :: STRUCTURE_TYPE !<The structure type for all Jacobian constraint matrices
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG), ALLOCATABLE :: STRUCTURE_TYPES(:)
    TYPE(CONSTRAINT_MATRICES_NONLINEAR_TYPE), POINTER :: NONLINEAR_MATRICES

    CALL ENTERS("CONSTRAINT_MATRICES_NONLINEAR_STRUCTURE_TYPE_SET_1",ERR,ERROR,*999)

    IF(ASSOCIATED(CONSTRAINT_MATRICES)) THEN
      IF(CONSTRAINT_MATRICES%CONSTRAINT_MATRICES_FINISHED) THEN
        CALL FLAG_ERROR("Constraint matrices have been finished.",ERR,ERROR,*999)
      ELSE
        NONLINEAR_MATRICES=>CONSTRAINT_MATRICES%NONLINEAR_MATRICES
        IF(ASSOCIATED(NONLINEAR_MATRICES)) THEN
          ALLOCATE(STRUCTURE_TYPES(NONLINEAR_MATRICES%NUMBER_OF_JACOBIANS),STAT=ERR)
          IF(ERR/=0) CALL FLAG_ERROR("Could not allocate storage types.",ERR,ERROR,*999)
          STRUCTURE_TYPES=STRUCTURE_TYPE
          CALL CONSTRAINT_MATRICES_NONLINEAR_STRUCTURE_TYPE_SET_0(CONSTRAINT_MATRICES,STRUCTURE_TYPES,ERR,ERROR,*999)
          DEALLOCATE(STRUCTURE_TYPES)
        ELSE
          CALL FLAG_ERROR("Constraint matrices nonlinear matrices is not associated.",ERR,ERROR,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FLAG_ERROR("Constraint matrices is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("CONSTRAINT_MATRICES_NONLINEAR_STRUCTURE_TYPE_SET_1")
    RETURN
999 CALL ERRORS("CONSTRAINT_MATRICES_NONLINEAR_STRUCTURE_TYPE_SET_1",ERR,ERROR)
    CALL EXITS("CONSTRAINT_MATRICES_NONLINEAR_STRUCTURE_TYPE_SET_1")
    RETURN 1
  END SUBROUTINE CONSTRAINT_MATRICES_NONLINEAR_STRUCTURE_TYPE_SET_1

  !
  !================================================================================================================================
  !

  !>Finalise the constraint matrices and deallocate all memory.
  SUBROUTINE CONSTRAINT_MATRICES_FINALISE(CONSTRAINT_MATRICES,ERR,ERROR,*)

    !Argument variables
    TYPE(CONSTRAINT_MATRICES_TYPE), POINTER :: CONSTRAINT_MATRICES !<A pointer to the constraint matrices
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
   
    CALL ENTERS("CONSTRAINT_MATRICES_FINALISE",ERR,ERROR,*999)

    IF(ASSOCIATED(CONSTRAINT_MATRICES)) THEN
      CALL CONSTRAINT_MATRICES_DYNAMIC_FINALISE(CONSTRAINT_MATRICES%DYNAMIC_MATRICES,ERR,ERROR,*999)
      CALL CONSTRAINT_MATRICES_LINEAR_FINALISE(CONSTRAINT_MATRICES%LINEAR_MATRICES,ERR,ERROR,*999)
      CALL CONSTRAINT_MATRICES_NONLINEAR_FINALISE(CONSTRAINT_MATRICES%NONLINEAR_MATRICES,ERR,ERROR,*999)
      CALL CONSTRAINT_MATRICES_RHS_FINALISE(CONSTRAINT_MATRICES%RHS_VECTOR,ERR,ERROR,*999)      
      DEALLOCATE(CONSTRAINT_MATRICES)
    ENDIF
       
    CALL EXITS("CONSTRAINT_MATRICES_FINALISE")
    RETURN
999 CALL ERRORS("CONSTRAINT_MATRICES_FINALISE",ERR,ERROR)
    CALL EXITS("CONSTRAINT_MATRICES_FINALISE")
    RETURN 1
  END SUBROUTINE CONSTRAINT_MATRICES_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialise the constraint matrices for the equations.
  SUBROUTINE CONSTRAINT_MATRICES_INITIALISE(CONSTRAINT_EQUATIONS,ERR,ERROR,*)
    
     !Argument variables
    TYPE(CONSTRAINT_EQUATIONS_TYPE), POINTER :: CONSTRAINT_EQUATIONS !<A pointer to the equations to initialise the constraint matrices for
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DUMMY_ERR
    TYPE(CONSTRAINT_MAPPING_TYPE), POINTER :: CONSTRAINT_MAPPING
    TYPE(VARYING_STRING) :: DUMMY_ERROR
    
    CALL ENTERS("CONSTRAINT_MATRICES_INITIALISE",ERR,ERROR,*998)

    IF(ASSOCIATED(CONSTRAINT_EQUATIONS)) THEN
      IF(ASSOCIATED(CONSTRAINT_EQUATIONS%CONSTRAINT_MATRICES)) THEN
        CALL FLAG_ERROR("Constraint matrices is already associated for this equations.",ERR,ERROR,*998)
      ELSE
        CONSTRAINT_MAPPING=>CONSTRAINT_EQUATIONS%CONSTRAINT_MAPPING
        IF(ASSOCIATED(CONSTRAINT_MAPPING)) THEN
          IF(CONSTRAINT_MAPPING%CONSTRAINT_MAPPING_FINISHED) THEN
            ALLOCATE(CONSTRAINT_EQUATIONS%CONSTRAINT_MATRICES,STAT=ERR)
            IF(ERR/=0) CALL FLAG_ERROR("Could not allocate equations constraint matrices.",ERR,ERROR,*999)
            CONSTRAINT_EQUATIONS%CONSTRAINT_MATRICES%CONSTRAINT_EQUATIONS=>CONSTRAINT_EQUATIONS
            CONSTRAINT_EQUATIONS%CONSTRAINT_MATRICES%CONSTRAINT_MATRICES_FINISHED=.FALSE.
            CONSTRAINT_EQUATIONS%CONSTRAINT_MATRICES%CONSTRAINT_MAPPING=>CONSTRAINT_MAPPING
            NULLIFY(CONSTRAINT_EQUATIONS%CONSTRAINT_MATRICES%SOLVER_MAPPING)
            CONSTRAINT_EQUATIONS%CONSTRAINT_MATRICES%NUMBER_OF_COLUMNS=CONSTRAINT_MAPPING%NUMBER_OF_COLUMNS
            CONSTRAINT_EQUATIONS%CONSTRAINT_MATRICES%TOTAL_NUMBER_OF_COLUMNS=CONSTRAINT_MAPPING%TOTAL_NUMBER_OF_COLUMNS
            CONSTRAINT_EQUATIONS%CONSTRAINT_MATRICES%NUMBER_OF_GLOBAL_COLUMNS=CONSTRAINT_MAPPING%NUMBER_OF_GLOBAL_COLUMNS
            NULLIFY(CONSTRAINT_EQUATIONS%CONSTRAINT_MATRICES%DYNAMIC_MATRICES)
            NULLIFY(CONSTRAINT_EQUATIONS%CONSTRAINT_MATRICES%LINEAR_MATRICES)
            NULLIFY(CONSTRAINT_EQUATIONS%CONSTRAINT_MATRICES%NONLINEAR_MATRICES)
            NULLIFY(CONSTRAINT_EQUATIONS%CONSTRAINT_MATRICES%RHS_VECTOR)
            CALL CONSTRAINT_MATRICES_DYNAMIC_INITIALISE(CONSTRAINT_EQUATIONS%CONSTRAINT_MATRICES,ERR,ERROR,*999)            
            CALL CONSTRAINT_MATRICES_LINEAR_INITIALISE(CONSTRAINT_EQUATIONS%CONSTRAINT_MATRICES,ERR,ERROR,*999)            
            CALL CONSTRAINT_MATRICES_NONLINEAR_INITIALISE(CONSTRAINT_EQUATIONS%CONSTRAINT_MATRICES,ERR,ERROR,*999)            
            CALL CONSTRAINT_MATRICES_RHS_INITIALISE(CONSTRAINT_EQUATIONS%CONSTRAINT_MATRICES,ERR,ERROR,*999)            
          ELSE
            CALL FLAG_ERROR("Constraint mapping has not been finished.",ERR,ERROR,*999)
          ENDIF
        ELSE
          CALL FLAG_ERROR("Equations equations mapping is not associated.",ERR,ERROR,*998)
        ENDIF
      ENDIF
    ELSE
      CALL FLAG_ERROR("Equations is not associated.",ERR,ERROR,*998)
    ENDIF
       
    CALL EXITS("CONSTRAINT_MATRICES_INITIALISE")
    RETURN
999 CALL CONSTRAINT_MATRICES_FINALISE(CONSTRAINT_EQUATIONS%CONSTRAINT_MATRICES,DUMMY_ERR,DUMMY_ERROR,*998)
998 CALL ERRORS("CONSTRAINT_MATRICES_INITIALISE",ERR,ERROR)
    CALL EXITS("CONSTRAINT_MATRICES_INITIALISE")
    RETURN 1
  END SUBROUTINE CONSTRAINT_MATRICES_INITIALISE

  !
  !================================================================================================================================
  !

  !>Initialise the values of the constraint matrices and vectors to the given value e.g., 0.0_DP
  SUBROUTINE CONSTRAINT_MATRICES_VALUES_INITIALISE(CONSTRAINT_MATRICES,SELECTION_TYPE,VALUE,ERR,ERROR,*)
    
    !Argument variables
    TYPE(CONSTRAINT_MATRICES_TYPE), POINTER :: CONSTRAINT_MATRICES !<A pointer to the constraint matrices to initialise the values for
    INTEGER(INTG), INTENT(IN) :: SELECTION_TYPE !<The selection of constraint matrices to be initialised \see CONSTRAINT_MATRICES_ROUTINES::SelectMatricesTypes,CONSTRAINT_MATRICES_ROUTINES
    REAL(DP), INTENT(IN) :: VALUE !<The value to initialise
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: matrix_idx
    TYPE(CONSTRAINT_JACOBIAN_TYPE), POINTER :: JACOBIAN_MATRIX
    TYPE(CONSTRAINT_MATRICES_DYNAMIC_TYPE), POINTER :: DYNAMIC_MATRICES
    TYPE(CONSTRAINT_MATRICES_LINEAR_TYPE), POINTER :: LINEAR_MATRICES
    TYPE(CONSTRAINT_MATRICES_NONLINEAR_TYPE), POINTER :: NONLINEAR_MATRICES
    TYPE(CONSTRAINT_RHS_TYPE), POINTER :: RHS_VECTOR
    TYPE(CONSTRAINT_MATRIX_TYPE), POINTER :: CONSTRAINT_MATRIX
    
    CALL ENTERS("CONSTRAINT_MATRICES_VALUES_INITIALISE",ERR,ERROR,*999)
    
    IF(ASSOCIATED(CONSTRAINT_MATRICES)) THEN
      IF(SELECTION_TYPE==CONSTRAINT_MATRICES_ALL.OR. &
        & SELECTION_TYPE==CONSTRAINT_MATRICES_DYNAMIC_ONLY.OR. &
        & SELECTION_TYPE==CONSTRAINT_MATRICES_LINEAR_ONLY.OR. &
        & SELECTION_TYPE==CONSTRAINT_MATRICES_NONLINEAR_ONLY) THEN
        DYNAMIC_MATRICES=>CONSTRAINT_MATRICES%DYNAMIC_MATRICES
        IF(ASSOCIATED(DYNAMIC_MATRICES)) THEN
          DO matrix_idx=1,DYNAMIC_MATRICES%NUMBER_OF_DYNAMIC_MATRICES
            CONSTRAINT_MATRIX=>DYNAMIC_MATRICES%MATRICES(matrix_idx)%PTR
            IF(ASSOCIATED(CONSTRAINT_MATRIX)) THEN
              IF(CONSTRAINT_MATRIX%UPDATE_MATRIX) THEN
                CALL DISTRIBUTED_MATRIX_ALL_VALUES_SET(CONSTRAINT_MATRIX%MATRIX,VALUE,ERR,ERROR,*999)
                IF(CONSTRAINT_MATRIX%HAS_TRANSPOSE) THEN
                  CALL DISTRIBUTED_MATRIX_ALL_VALUES_SET(CONSTRAINT_MATRIX%MATRIX_TRANSPOSE,VALUE,ERR,ERROR,*999)
                ENDIF
              ENDIF
            ELSE
              CALL FLAG_ERROR("Constraint matrix is not associated.",ERR,ERROR,*999)
            ENDIF
          ENDDO !matrix_idx
        ENDIF
      ENDIF
      IF(SELECTION_TYPE==CONSTRAINT_MATRICES_ALL.OR. &
        & SELECTION_TYPE==CONSTRAINT_MATRICES_DYNAMIC_ONLY.OR. &
        & SELECTION_TYPE==CONSTRAINT_MATRICES_LINEAR_ONLY.OR. &
        & SELECTION_TYPE==CONSTRAINT_MATRICES_NONLINEAR_ONLY) THEN
        LINEAR_MATRICES=>CONSTRAINT_MATRICES%LINEAR_MATRICES
        IF(ASSOCIATED(LINEAR_MATRICES)) THEN
          DO matrix_idx=1,LINEAR_MATRICES%NUMBER_OF_LINEAR_MATRICES
            CONSTRAINT_MATRIX=>LINEAR_MATRICES%MATRICES(matrix_idx)%PTR
            IF(ASSOCIATED(CONSTRAINT_MATRIX)) THEN
              IF(CONSTRAINT_MATRIX%UPDATE_MATRIX) THEN
                CALL DISTRIBUTED_MATRIX_ALL_VALUES_SET(CONSTRAINT_MATRIX%MATRIX,VALUE,ERR,ERROR,*999)
                IF(CONSTRAINT_MATRIX%HAS_TRANSPOSE) THEN
                  CALL DISTRIBUTED_MATRIX_ALL_VALUES_SET(CONSTRAINT_MATRIX%MATRIX_TRANSPOSE,VALUE,ERR,ERROR,*999)
                ENDIF
              ENDIF
            ELSE
              CALL FLAG_ERROR("Constraint matrix is not associated.",ERR,ERROR,*999)
            ENDIF
          ENDDO !matrix_idx
        ENDIF
      ENDIF
      IF(SELECTION_TYPE==CONSTRAINT_MATRICES_ALL.OR. &
        & SELECTION_TYPE==CONSTRAINT_MATRICES_NONLINEAR_ONLY.OR. &
        & SELECTION_TYPE==CONSTRAINT_MATRICES_JACOBIAN_ONLY) THEN
        NONLINEAR_MATRICES=>CONSTRAINT_MATRICES%NONLINEAR_MATRICES
        IF(ASSOCIATED(NONLINEAR_MATRICES)) THEN
          DO matrix_idx=1,NONLINEAR_MATRICES%NUMBER_OF_JACOBIANS
            JACOBIAN_MATRIX=>NONLINEAR_MATRICES%JACOBIANS(matrix_idx)%PTR
            IF(ASSOCIATED(JACOBIAN_MATRIX)) THEN
              IF(JACOBIAN_MATRIX%UPDATE_JACOBIAN) THEN
                CALL DISTRIBUTED_MATRIX_ALL_VALUES_SET(JACOBIAN_MATRIX%JACOBIAN,VALUE,ERR,ERROR,*999)
                IF(JACOBIAN_MATRIX%HAS_TRANSPOSE) THEN
                  CALL DISTRIBUTED_MATRIX_ALL_VALUES_SET(JACOBIAN_MATRIX%JACOBIAN_TRANSPOSE,VALUE,ERR,ERROR,*999)
                ENDIF
              ENDIF
            ELSE
              CALL FLAG_ERROR("Jacobian matrix is not associated.",ERR,ERROR,*999)
            ENDIF
          ENDDO
        ENDIF
      ENDIF
      IF(SELECTION_TYPE==CONSTRAINT_MATRICES_ALL.OR. &
        & SELECTION_TYPE==CONSTRAINT_MATRICES_NONLINEAR_ONLY.OR. &
        & SELECTION_TYPE==CONSTRAINT_MATRICES_RESIDUAL_ONLY.OR. &
        & SELECTION_TYPE==CONSTRAINT_MATRICES_RHS_RESIDUAL_ONLY.OR. &
        & SELECTION_TYPE==CONSTRAINT_MATRICES_VECTORS_ONLY) THEN
        NONLINEAR_MATRICES=>CONSTRAINT_MATRICES%NONLINEAR_MATRICES
        IF(ASSOCIATED(NONLINEAR_MATRICES)) THEN
          IF(NONLINEAR_MATRICES%UPDATE_RESIDUAL) THEN
            CALL DISTRIBUTED_VECTOR_ALL_VALUES_SET(NONLINEAR_MATRICES%RESIDUAL,VALUE,ERR,ERROR,*999)
          ENDIF
        ENDIF
      ENDIF
      IF(SELECTION_TYPE==CONSTRAINT_MATRICES_ALL.OR. &
        & SELECTION_TYPE==CONSTRAINT_MATRICES_DYNAMIC_ONLY.OR. &
        & SELECTION_TYPE==CONSTRAINT_MATRICES_LINEAR_ONLY.OR. &
        & SELECTION_TYPE==CONSTRAINT_MATRICES_NONLINEAR_ONLY.OR. &
        & SELECTION_TYPE==CONSTRAINT_MATRICES_RHS_ONLY.OR. &
        & SELECTION_TYPE==CONSTRAINT_MATRICES_RHS_RESIDUAL_ONLY.OR. &
        & SELECTION_TYPE==CONSTRAINT_MATRICES_VECTORS_ONLY) THEN    
        RHS_VECTOR=>CONSTRAINT_MATRICES%RHS_VECTOR
        IF(ASSOCIATED(RHS_VECTOR)) THEN
          IF(RHS_VECTOR%UPDATE_VECTOR) THEN
            CALL DISTRIBUTED_VECTOR_ALL_VALUES_SET(RHS_VECTOR%RHS_VECTOR,VALUE,ERR,ERROR,*999)
          ENDIF
        ENDIF
      ENDIF
    ELSE
      CALL FLAG_ERROR("Constraint matrices is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("CONSTRAINT_MATRICES_VALUES_INITIALISE")
    RETURN
999 CALL ERRORS("CONSTRAINT_MATRICES_VALUES_INITIALISE",ERR,ERROR)
    CALL EXITS("CONSTRAINT_MATRICES_VALUES_INITIALISE")
    RETURN 1
  END SUBROUTINE CONSTRAINT_MATRICES_VALUES_INITIALISE

  !
  !================================================================================================================================
  !

  !>Calculates the matrix structure (sparsity) for an constraint matrix.
  SUBROUTINE CONSTRAINT_MATRIX_STRUCTURE_CALCULATE(CONSTRAINT_MATRIX,NUMBER_OF_NON_ZEROS,ROW_INDICES,COLUMN_INDICES, &
    & TRANSPOSE_ROW_INDICES,TRANSPOSE_COLUMN_INDICES,ERR,ERROR,*)

    !Argument variables
    TYPE(CONSTRAINT_MATRIX_TYPE), POINTER :: CONSTRAINT_MATRIX !<A pointer to the constraint matrix to calculate the strucute for
    INTEGER(INTG), INTENT(OUT) :: NUMBER_OF_NON_ZEROS !<On return, the number of non-zeros in the matrix
    INTEGER(INTG), POINTER :: ROW_INDICES(:) !<On return, a pointer to row location indices in compressed row format. The pointer must be NULL on entry and the calling routine is responsible for deallocation.
    INTEGER(INTG), POINTER :: COLUMN_INDICES(:) !<On return, a pointer to the column location indices in compressed row format. The pointer must be NULL on entry and the calling routine is responsible for deallocation.
    INTEGER(INTG), POINTER :: TRANSPOSE_ROW_INDICES(:) !<On return, if the constraint matrix has a transpose a pointer to transpose row location indices in compressed row format. The pointer must be NULL on entry and the calling routine is responsible for deallocation.
    INTEGER(INTG), POINTER :: TRANSPOSE_COLUMN_INDICES(:) !<On return, if the constraint matrix has a transpose a pointer to the transpose column location indices in compressed row format. The pointer must be NULL on entry and the calling routine is responsible for deallocation.
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
   INTEGER(INTG) :: column_version,column_derivative,column_idx,column_component_idx,column_local_derivative_idx, &
     & column_local_node_idx, column_node,DUMMY_ERR,global_column,global_row,column_element_idx,row_element_idx, &
     & surrounding_element_idx,local_column,local_row,MATRIX_NUMBER,NUMBER_OF_COLUMNS,row_component_idx, &
     & row_version,row_derivative,row_local_derivative_idx,row_local_node_idx,row_node,TRANSPOSE_NUMBER_OF_NON_ZEROS
    INTEGER(INTG), ALLOCATABLE :: COLUMNS(:),TRANSPOSE_COLUMNS(:)
    REAL(DP) :: SPARSITY
    TYPE(BASIS_TYPE), POINTER :: COLUMN_BASIS,ROW_BASIS
    TYPE(CONSTRAINT_EQUATIONS_TYPE), POINTER :: CONSTRAINT_EQUATIONS
    TYPE(CONSTRAINT_MAPPING_TYPE), POINTER :: CONSTRAINT_MAPPING
    TYPE(CONSTRAINT_MATRICES_TYPE), POINTER :: CONSTRAINT_MATRICES
    TYPE(CONSTRAINT_MATRICES_DYNAMIC_TYPE), POINTER :: DYNAMIC_MATRICES
    TYPE(CONSTRAINT_MATRICES_LINEAR_TYPE), POINTER :: LINEAR_MATRICES
    TYPE(DOMAIN_MAPPING_TYPE), POINTER :: COLUMN_DOFS_DOMAIN_MAPPING,ROW_DOFS_DOMAIN_MAPPING
    TYPE(DOMAIN_ELEMENTS_TYPE), POINTER :: COLUMN_DOMAIN_ELEMENTS,ROW_DOMAIN_ELEMENTS
    TYPE(DOMAIN_NODES_TYPE), POINTER :: ROW_DOMAIN_NODES
    TYPE(DOMAIN_NODE_TYPE), POINTER :: ROW_DOMAIN_NODE
    TYPE(FIELD_DOF_TO_PARAM_MAP_TYPE), POINTER :: COLUMN_DOFS_PARAM_MAPPING,ROW_DOFS_PARAM_MAPPING
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: COLUMN_VARIABLE,ROW_VARIABLE
    TYPE(LIST_PTR_TYPE), ALLOCATABLE :: COLUMN_INDICES_LISTS(:)
    TYPE(LIST_PTR_TYPE), ALLOCATABLE :: TRANSPOSE_COLUMN_INDICES_LISTS(:)
    TYPE(VARYING_STRING) :: DUMMY_ERROR,LOCAL_ERROR

    CALL ENTERS("CONSTRAINT_MATRIX_STRUCTURE_CALCULATE",ERR,ERROR,*999)

    IF(ASSOCIATED(CONSTRAINT_MATRIX)) THEN
      IF(.NOT.ASSOCIATED(ROW_INDICES)) THEN
        IF(.NOT.ASSOCIATED(COLUMN_INDICES)) THEN
          IF(.NOT.ASSOCIATED(TRANSPOSE_ROW_INDICES)) THEN
            IF(.NOT.ASSOCIATED(TRANSPOSE_COLUMN_INDICES)) THEN
              MATRIX_NUMBER=CONSTRAINT_MATRIX%MATRIX_NUMBER
              SELECT CASE(CONSTRAINT_MATRIX%STRUCTURE_TYPE)
              CASE(CONSTRAINT_MATRIX_NO_STRUCTURE)
                CALL FLAG_ERROR("There is no structure to calculate for a matrix with no structure.",ERR,ERROR,*998)
              CASE(CONSTRAINT_MATRIX_FEM_STRUCTURE)
                SELECT CASE(CONSTRAINT_MATRIX%STORAGE_TYPE)
                CASE(MATRIX_COMPRESSED_ROW_STORAGE_TYPE)
                  LINEAR_MATRICES=>CONSTRAINT_MATRIX%LINEAR_MATRICES
                  DYNAMIC_MATRICES=>CONSTRAINT_MATRIX%DYNAMIC_MATRICES
                  IF(ASSOCIATED(DYNAMIC_MATRICES)) THEN
                    CONSTRAINT_MATRICES=>DYNAMIC_MATRICES%CONSTRAINT_MATRICES
                  ELSE IF(ASSOCIATED(LINEAR_MATRICES)) THEN
                    CONSTRAINT_MATRICES=>LINEAR_MATRICES%CONSTRAINT_MATRICES
                  ELSE
                    CALL FLAG_ERROR("Dynamic or linear matrices constraint matrices is not associated.",err,error,*999)
                  ENDIF
                  IF(ASSOCIATED(CONSTRAINT_MATRICES)) THEN
                    CONSTRAINT_EQUATIONS=>CONSTRAINT_MATRICES%CONSTRAINT_EQUATIONS
                    IF(ASSOCIATED(CONSTRAINT_EQUATIONS)) THEN
                      CONSTRAINT_MAPPING=>CONSTRAINT_MATRICES%CONSTRAINT_MAPPING
                      IF(ASSOCIATED(CONSTRAINT_MAPPING)) THEN
                        IF(ASSOCIATED(DYNAMIC_MATRICES)) THEN
                          ROW_VARIABLE=>CONSTRAINT_MAPPING%DYNAMIC_MAPPING% &
                            & CONSTRAINT_MATRIX_ROWS_TO_VAR_MAP(MATRIX_NUMBER)%VARIABLE
                        ELSE 
                          ROW_VARIABLE=>CONSTRAINT_MAPPING%LINEAR_MAPPING% &
                            & CONSTRAINT_MATRIX_ROWS_TO_VAR_MAP(MATRIX_NUMBER)%VARIABLE
                        ENDIF
                        IF(ASSOCIATED(ROW_VARIABLE)) THEN
                          COLUMN_VARIABLE=>CONSTRAINT_MAPPING%LAGRANGE_VARIABLE
                          IF(ASSOCIATED(COLUMN_VARIABLE)) THEN
                            ROW_DOFS_DOMAIN_MAPPING=>ROW_VARIABLE%DOMAIN_MAPPING
                            IF(ASSOCIATED(ROW_DOFS_DOMAIN_MAPPING)) THEN
                              COLUMN_DOFS_DOMAIN_MAPPING=>COLUMN_VARIABLE%DOMAIN_MAPPING
                              IF(ASSOCIATED(COLUMN_DOFS_DOMAIN_MAPPING)) THEN
                                ROW_DOFS_PARAM_MAPPING=>ROW_VARIABLE%DOF_TO_PARAM_MAP
                                IF(ASSOCIATED(ROW_DOFS_PARAM_MAPPING)) THEN
                                  COLUMN_DOFS_PARAM_MAPPING=>COLUMN_VARIABLE%DOF_TO_PARAM_MAP
                                  IF(ASSOCIATED(COLUMN_DOFS_PARAM_MAPPING)) THEN
                                    !Allocate lists
                                    ALLOCATE(COLUMN_INDICES_LISTS(ROW_DOFS_DOMAIN_MAPPING%TOTAL_NUMBER_OF_LOCAL),STAT=ERR)
                                    IF(ERR/=0) CALL FLAG_ERROR("Could not allocate column indices lists.",ERR,ERROR,*999)
                                    !Allocate row indices
                                    ALLOCATE(ROW_INDICES(ROW_DOFS_DOMAIN_MAPPING%TOTAL_NUMBER_OF_LOCAL+1),STAT=ERR)
                                    IF(ERR/=0) CALL FLAG_ERROR("Could not allocate row indices.",ERR,ERROR,*999)
                                    DO local_row=1,ROW_DOFS_DOMAIN_MAPPING%TOTAL_NUMBER_OF_LOCAL
                                      !Set up list
                                      NULLIFY(COLUMN_INDICES_LISTS(local_row)%PTR)
                                      CALL LIST_CREATE_START(COLUMN_INDICES_LISTS(local_row)%PTR,ERR,ERROR,*999)
                                      CALL LIST_DATA_TYPE_SET(COLUMN_INDICES_LISTS(local_row)%PTR,LIST_INTG_TYPE, &
                                        & ERR,ERROR,*999)
                                      CALL LIST_INITIAL_SIZE_SET(COLUMN_INDICES_LISTS(local_row)%PTR,50,ERR,ERROR,*999)
                                      CALL LIST_CREATE_FINISH(COLUMN_INDICES_LISTS(local_row)%PTR,ERR,ERROR,*999)
                                    ENDDO !local_row
                                    IF(CONSTRAINT_MATRIX%HAS_TRANSPOSE) THEN
                                      !Allocate transpose lists
                                      ALLOCATE(TRANSPOSE_COLUMN_INDICES_LISTS(COLUMN_DOFS_DOMAIN_MAPPING% &
                                        & TOTAL_NUMBER_OF_LOCAL),STAT=ERR)
                                      IF(ERR/=0) CALL FLAG_ERROR("Could not allocate transpose column indices lists.", &
                                        & ERR,ERROR,*999)
                                      DO local_row=1,COLUMN_DOFS_DOMAIN_MAPPING%TOTAL_NUMBER_OF_LOCAL
                                        !Set up list
                                        NULLIFY(TRANSPOSE_COLUMN_INDICES_LISTS(local_row)%PTR)
                                        CALL LIST_CREATE_START(TRANSPOSE_COLUMN_INDICES_LISTS(local_row)%PTR, &
                                          & ERR,ERROR,*999)
                                        CALL LIST_DATA_TYPE_SET(TRANSPOSE_COLUMN_INDICES_LISTS(local_row)%PTR, &
                                          & LIST_INTG_TYPE,ERR,ERROR,*999)
                                        CALL LIST_INITIAL_SIZE_SET(TRANSPOSE_COLUMN_INDICES_LISTS(local_row)%PTR,50, &
                                          & ERR,ERROR,*999)
                                        CALL LIST_CREATE_FINISH(TRANSPOSE_COLUMN_INDICES_LISTS(local_row)%PTR, &
                                          & ERR,ERROR,*999)
                                      ENDDO !local_row
                                      !Allocate transpose row indices
                                      ALLOCATE(TRANSPOSE_ROW_INDICES(COLUMN_DOFS_DOMAIN_MAPPING%TOTAL_NUMBER_OF_LOCAL+1), &
                                        & STAT=ERR)
                                      IF(ERR/=0) CALL FLAG_ERROR("Could not allocate transpose row indices.",ERR,ERROR,*999)
                                    ENDIF
                                    !Loop over the number of components in the dependent field variable
                                    DO row_component_idx=1,ROW_VARIABLE%NUMBER_OF_COMPONENTS
                                      IF(ROW_VARIABLE%COMPONENTS(row_component_idx)%INTERPOLATION_TYPE== &
                                        & FIELD_NODE_BASED_INTERPOLATION) THEN
                                        !Loop over the elements in the constraint mesh
                                        ROW_DOMAIN_ELEMENTS=>ROW_VARIABLE%COMPONENTS(row_component_idx)%DOMAIN% &
                                          & TOPOLOGY%ELEMENTS
                                        ROW_DOMAIN_NODES=>ROW_VARIABLE%COMPONENTS(row_component_idx)%DOMAIN% &
                                          & TOPOLOGY%NODES
                                        DO row_element_idx=1,ROW_DOMAIN_ELEMENTS%TOTAL_NUMBER_OF_ELEMENTS
                                          ROW_BASIS=>ROW_DOMAIN_ELEMENTS%ELEMENTS(row_element_idx)%BASIS
                                          !Loop over the row DOFs in the element
                                          DO row_local_node_idx=1,ROW_BASIS%NUMBER_OF_NODES
                                            row_node=ROW_DOMAIN_ELEMENTS%ELEMENTS(row_element_idx)% &
                                              & ELEMENT_NODES(row_local_node_idx)
                                            ROW_DOMAIN_NODE=>ROW_DOMAIN_NODES%NODES(row_node)
                                            DO row_local_derivative_idx=1,ROW_BASIS% &
                                              & NUMBER_OF_DERIVATIVES(row_local_node_idx)
                                              row_derivative=ROW_DOMAIN_ELEMENTS%ELEMENTS(row_element_idx)% &
                                                & ELEMENT_DERIVATIVES(row_local_derivative_idx,row_local_node_idx)
                                              row_version=ROW_DOMAIN_ELEMENTS%ELEMENTS(row_element_idx)% &
                                                & elementVersions(row_local_derivative_idx,row_local_node_idx)
                                              local_row=ROW_VARIABLE%COMPONENTS(row_component_idx)% &
                                                & PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NODES(row_node)% &
                                                & DERIVATIVES(row_derivative)%VERSIONS(row_version)
                                              global_row=ROW_DOFS_DOMAIN_MAPPING%LOCAL_TO_GLOBAL_MAP(local_row)
                                              !Loop over the components in the Lagrange multiplier variable
                                              DO column_component_idx=1,COLUMN_VARIABLE%NUMBER_OF_COMPONENTS
                                                SELECT CASE(COLUMN_VARIABLE%COMPONENTS(column_component_idx)%INTERPOLATION_TYPE)
                                                CASE(FIELD_CONSTANT_INTERPOLATION)
                                                  local_column=COLUMN_VARIABLE%COMPONENTS(column_component_idx)%PARAM_TO_DOF_MAP% &
                                                    & CONSTANT_PARAM2DOF_MAP
                                                  global_column=COLUMN_DOFS_DOMAIN_MAPPING%LOCAL_TO_GLOBAL_MAP(local_column)
                                                  CALL LIST_ITEM_ADD(COLUMN_INDICES_LISTS(local_row)%PTR,global_column, &
                                                    & ERR,ERROR,*999)
                                                  IF(CONSTRAINT_MATRIX%HAS_TRANSPOSE) THEN
                                                    CALL LIST_ITEM_ADD(TRANSPOSE_COLUMN_INDICES_LISTS(local_column)%PTR, &
                                                      & global_row,ERR,ERROR,*999)
                                                  ENDIF
                                                CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                                                  COLUMN_DOMAIN_ELEMENTS=>COLUMN_VARIABLE%COMPONENTS(column_component_idx)%DOMAIN% &
                                                    & TOPOLOGY%ELEMENTS
                                                  DO surrounding_element_idx=1,ROW_DOMAIN_NODE%NUMBER_OF_SURROUNDING_ELEMENTS
                                                    column_element_idx=ROW_DOMAIN_NODE%SURROUNDING_ELEMENTS(surrounding_element_idx)
                                                    local_column=COLUMN_VARIABLE%COMPONENTS(column_component_idx)% &
                                                      & PARAM_TO_DOF_MAP%ELEMENT_PARAM2DOF_MAP%ELEMENTS(column_element_idx)
                                                    global_column=COLUMN_DOFS_DOMAIN_MAPPING%LOCAL_TO_GLOBAL_MAP(local_column)
                                                    CALL LIST_ITEM_ADD(COLUMN_INDICES_LISTS(local_row)%PTR, &
                                                      & global_column,err,error,*999)
                                                    IF(CONSTRAINT_MATRIX%HAS_TRANSPOSE) THEN
                                                      CALL LIST_ITEM_ADD(TRANSPOSE_COLUMN_INDICES_LISTS(local_column)%PTR, &
                                                        & global_row,ERR,ERROR,*999)
                                                    ENDIF
                                                  ENDDO !surrounding_element_idx
                                                CASE(FIELD_NODE_BASED_INTERPOLATION)
                                                  COLUMN_DOMAIN_ELEMENTS=>COLUMN_VARIABLE%COMPONENTS(column_component_idx)%DOMAIN% &
                                                    & TOPOLOGY%ELEMENTS
                                                  DO surrounding_element_idx=1,ROW_DOMAIN_NODE%NUMBER_OF_SURROUNDING_ELEMENTS
                                                    column_element_idx=ROW_DOMAIN_NODE%SURROUNDING_ELEMENTS(surrounding_element_idx)
                                                    COLUMN_BASIS=>COLUMN_DOMAIN_ELEMENTS%ELEMENTS(column_element_idx)%BASIS
                                                    !Loop over the column DOFs in the domain mesh element
                                                    DO column_local_node_idx=1,COLUMN_BASIS%NUMBER_OF_NODES
                                                      column_node=COLUMN_DOMAIN_ELEMENTS%ELEMENTS(column_element_idx)% &
                                                        & ELEMENT_NODES(column_local_node_idx)
                                                      DO column_local_derivative_idx=1,COLUMN_BASIS% &
                                                        & NUMBER_OF_DERIVATIVES(column_local_node_idx)
                                                        column_derivative=COLUMN_DOMAIN_ELEMENTS%ELEMENTS(column_element_idx)% &
                                                          & ELEMENT_DERIVATIVES(column_local_derivative_idx,column_local_node_idx)
                                                        column_version=COLUMN_DOMAIN_ELEMENTS%ELEMENTS(column_element_idx)% &
                                                          & elementVersions(column_local_derivative_idx,column_local_node_idx)
                                                        local_column=COLUMN_VARIABLE%COMPONENTS(column_component_idx)% &
                                                          & PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NODES(column_node)% &
                                                          & DERIVATIVES(column_derivative)%VERSIONS(column_version)
                                                        global_column=COLUMN_DOFS_DOMAIN_MAPPING%LOCAL_TO_GLOBAL_MAP(local_column)
                                                        CALL LIST_ITEM_ADD(COLUMN_INDICES_LISTS(local_row)%PTR,global_column, &
                                                          & ERR,ERROR,*999)
                                                        IF(CONSTRAINT_MATRIX%HAS_TRANSPOSE) THEN
                                                          CALL LIST_ITEM_ADD(TRANSPOSE_COLUMN_INDICES_LISTS(local_column)%PTR, &
                                                            & global_row,ERR,ERROR,*999)
                                                        ENDIF
                                                      ENDDO !column_local_derivative_idx
                                                    ENDDO !column_local_node_idx
                                                  ENDDO !surrounding_element_idx
                                                CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                                                  CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
                                                CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                                                  CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
                                                CASE DEFAULT
                                                  LOCAL_ERROR="The column variable interpolation type of "// &
                                                    & TRIM(NUMBER_TO_VSTRING(COLUMN_VARIABLE%COMPONENTS(column_component_idx)% &
                                                    INTERPOLATION_TYPE,"*",ERR,ERROR))//" is invalid."
                                                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                                                END SELECT
                                              ENDDO !column_component_idx
                                            ENDDO !row_local_derivative_idx
                                          ENDDO !row_local_node_idx
                                        ENDDO !constraint_element_idx
                                      ELSE
                                        CALL FLAG_ERROR("Only node based fields implemented.",ERR,ERROR,*999)
                                      ENDIF
                                    ENDDO !column_component_idx
                                    NUMBER_OF_NON_ZEROS=0
                                    ROW_INDICES(1)=1
                                    DO local_row=1,ROW_DOFS_DOMAIN_MAPPING%TOTAL_NUMBER_OF_LOCAL
                                      CALL LIST_REMOVE_DUPLICATES(COLUMN_INDICES_LISTS(local_row)%PTR,ERR,ERROR,*999)
                                      CALL LIST_NUMBER_OF_ITEMS_GET(COLUMN_INDICES_LISTS(local_row)%PTR,NUMBER_OF_COLUMNS, &
                                        & ERR,ERROR,*999)
                                      NUMBER_OF_NON_ZEROS=NUMBER_OF_NON_ZEROS+NUMBER_OF_COLUMNS
                                      ROW_INDICES(local_row+1)=NUMBER_OF_NON_ZEROS+1
                                    ENDDO !local_row
                                    IF(CONSTRAINT_MATRIX%HAS_TRANSPOSE) THEN
                                      TRANSPOSE_NUMBER_OF_NON_ZEROS=0
                                      TRANSPOSE_ROW_INDICES(1)=1
                                      DO local_row=1,COLUMN_DOFS_DOMAIN_MAPPING%TOTAL_NUMBER_OF_LOCAL
                                        CALL LIST_REMOVE_DUPLICATES(TRANSPOSE_COLUMN_INDICES_LISTS(local_row)%PTR, &
                                          & ERR,ERROR,*999)
                                        CALL LIST_NUMBER_OF_ITEMS_GET(TRANSPOSE_COLUMN_INDICES_LISTS(local_row)%PTR, &
                                          & NUMBER_OF_COLUMNS,ERR,ERROR,*999)
                                        TRANSPOSE_NUMBER_OF_NON_ZEROS=TRANSPOSE_NUMBER_OF_NON_ZEROS+NUMBER_OF_COLUMNS
                                        TRANSPOSE_ROW_INDICES(local_row+1)=TRANSPOSE_NUMBER_OF_NON_ZEROS+1
                                      ENDDO !local_row
                                      !Sanity check - the number of non-zeros should be the same
                                      IF(TRANSPOSE_NUMBER_OF_NON_ZEROS/=NUMBER_OF_NON_ZEROS) THEN
                                        LOCAL_ERROR="Invalid number of non-zeros. The number of non-zeros in the "// &
                                          & "transposed matrix ("//TRIM(NUMBER_TO_VSTRING(TRANSPOSE_NUMBER_OF_NON_ZEROS, &
                                          & "*",ERR,ERROR))//") does not match the number of non-zeros in the constraint "// &
                                          & "matrix ("//TRIM(NUMBER_TO_VSTRING(TRANSPOSE_NUMBER_OF_NON_ZEROS,"*",ERR, &
                                          & ERROR))//")."
                                        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                                      ENDIF
                                    ENDIF
                                    !Allocate and setup the column locations
                                    ALLOCATE(COLUMN_INDICES(NUMBER_OF_NON_ZEROS),STAT=ERR)
                                    IF(ERR/=0) CALL FLAG_ERROR("Could not allocate row indices.",ERR,ERROR,*999)
                                    DO local_row=1,ROW_DOFS_DOMAIN_MAPPING%TOTAL_NUMBER_OF_LOCAL
                                      CALL LIST_DETACH_AND_DESTROY(COLUMN_INDICES_LISTS(local_row)%PTR,NUMBER_OF_COLUMNS, &
                                        & COLUMNS,ERR,ERROR,*999)
                                      DO column_idx=1,NUMBER_OF_COLUMNS
                                        COLUMN_INDICES(ROW_INDICES(local_row)+column_idx-1)=COLUMNS(column_idx)
                                      ENDDO !column_idx
                                      DEALLOCATE(COLUMNS)
                                    ENDDO !local_row
                                    IF(CONSTRAINT_MATRIX%HAS_TRANSPOSE) THEN
                                      !Allocate and setup the column locations
                                      ALLOCATE(TRANSPOSE_COLUMN_INDICES(TRANSPOSE_NUMBER_OF_NON_ZEROS),STAT=ERR)
                                      IF(ERR/=0) &
                                        & CALL FLAG_ERROR("Could not allocate transpose column indices.",ERR,ERROR,*999)
                                      DO local_row=1,COLUMN_DOFS_DOMAIN_MAPPING%TOTAL_NUMBER_OF_LOCAL
                                        CALL LIST_DETACH_AND_DESTROY(TRANSPOSE_COLUMN_INDICES_LISTS(local_row)%PTR, &
                                          & NUMBER_OF_COLUMNS,TRANSPOSE_COLUMNS,ERR,ERROR,*999)
                                        DO column_idx=1,NUMBER_OF_COLUMNS
                                          TRANSPOSE_COLUMN_INDICES(TRANSPOSE_ROW_INDICES(local_row)+column_idx-1)= &
                                            & TRANSPOSE_COLUMNS(column_idx)
                                        ENDDO !row_idx
                                        DEALLOCATE(TRANSPOSE_COLUMNS)
                                      ENDDO !local_column
                                    ENDIF
                                    IF(DIAGNOSTICS1) THEN
                                      CALL WRITE_STRING(DIAGNOSTIC_OUTPUT_TYPE,"Constraint matrix structure:",ERR,ERROR,*999)
                                      CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"Constraint matrix number : ", &
                                        & MATRIX_NUMBER,ERR,ERROR,*999)
                                      CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"  Number of rows = ", &
                                        & ROW_DOFS_DOMAIN_MAPPING%TOTAL_NUMBER_OF_LOCAL,ERR,ERROR,*999)
                                      CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"  Number of columns = ", &
                                        & COLUMN_DOFS_DOMAIN_MAPPING%NUMBER_OF_GLOBAL,ERR,ERROR,*999)
                                      CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"  Number of non zeros = ", &
                                        & NUMBER_OF_NON_ZEROS,ERR,ERROR,*999)
                                      IF(ROW_DOFS_DOMAIN_MAPPING%TOTAL_NUMBER_OF_LOCAL* &
                                        & COLUMN_DOFS_DOMAIN_MAPPING%NUMBER_OF_GLOBAL/=0) THEN
                                        SPARSITY=(1.0_DP-REAL(NUMBER_OF_NON_ZEROS,DP)/REAL(ROW_DOFS_DOMAIN_MAPPING% &
                                          & TOTAL_NUMBER_OF_LOCAL*COLUMN_DOFS_DOMAIN_MAPPING%NUMBER_OF_GLOBAL,DP))*100.0_DP
                                        CALL WRITE_STRING_FMT_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"  Sparsity (%) = ",SPARSITY, &
                                          & "F6.2",ERR,ERROR,*999)
                                      ENDIF
                                      CALL WRITE_STRING_VECTOR(DIAGNOSTIC_OUTPUT_TYPE,1,1,ROW_DOFS_DOMAIN_MAPPING% &
                                        & TOTAL_NUMBER_OF_LOCAL+1,5,5,ROW_INDICES, &
                                        & '("  Row indices              :",5(X,I13))','(28X,5(X,I13))',ERR,ERROR,*999)
                                      CALL WRITE_STRING_VECTOR(DIAGNOSTIC_OUTPUT_TYPE,1,1,NUMBER_OF_NON_ZEROS,8,8, &
                                        & COLUMN_INDICES,'("  Column indices           :",5(X,I13))','(28X,5(X,I13))', &
                                        & ERR,ERROR,*999)
                                      IF(CONSTRAINT_MATRIX%HAS_TRANSPOSE) THEN 
                                        CALL WRITE_STRING_VECTOR(DIAGNOSTIC_OUTPUT_TYPE,1,1,COLUMN_DOFS_DOMAIN_MAPPING% &
                                          & TOTAL_NUMBER_OF_LOCAL+1,5,5,TRANSPOSE_ROW_INDICES, &
                                          & '("  Transpose row indices    :",5(X,I13))','(28X,5(X,I13))',ERR,ERROR,*999)
                                        CALL WRITE_STRING_VECTOR(DIAGNOSTIC_OUTPUT_TYPE,1,1,NUMBER_OF_NON_ZEROS,8,8, &
                                          & TRANSPOSE_COLUMN_INDICES,'("  Transpose column indices :",5(X,I13))', &
                                          & '(28X,5(X,I13))',ERR,ERROR,*999)
                                      ENDIF
                                    ENDIF
                                  ELSE
                                    CALL FLAG_ERROR("Column dofs parameter mapping is not associated.",ERR,ERROR,*999)
                                  ENDIF
                                ELSE
                                  CALL FLAG_ERROR("Row dofs parameter mapping is not associated.",ERR,ERROR,*999)
                                ENDIF
                              ELSE
                                CALL FLAG_ERROR("Column dofs domain mapping is not associated.",ERR,ERROR,*999)
                              ENDIF
                            ELSE
                              CALL FLAG_ERROR("Row dofs domain mapping is not associated.",ERR,ERROR,*999)
                            ENDIF
                          ELSE
                            CALL FLAG_ERROR("Column field variable is not associated.",ERR,ERROR,*999)
                          ENDIF
                        ELSE
                          CALL FLAG_ERROR("Row field variable is not associated.",ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FLAG_ERROR("Constraint mapping is not associated.",ERR,ERROR,*999)
                      ENDIF
                    ELSE
                      CALL FLAG_ERROR("Constraint equations is not associated.",ERR,ERROR,*999)
                    ENDIF
                  ELSE
                    CALL FLAG_ERROR("Constraint matrices is not associated.",ERR,ERROR,*999)
                  ENDIF
                CASE DEFAULT
                  LOCAL_ERROR="The matrix storage type of "// &
                    & TRIM(NUMBER_TO_VSTRING(CONSTRAINT_MATRIX%STORAGE_TYPE,"*",ERR,ERROR))//" is invalid."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                END SELECT
              CASE DEFAULT
                LOCAL_ERROR="The matrix structure type of "// &
                  & TRIM(NUMBER_TO_VSTRING(CONSTRAINT_MATRIX%STRUCTURE_TYPE,"*",ERR,ERROR))//" is invalid."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*998)
              END SELECT
            ELSE
              CALL FLAG_ERROR("Transpose column indices is already associated.",ERR,ERROR,*998)
            ENDIF
          ELSE
            CALL FLAG_ERROR("Transpose row indieces is already associated.",ERR,ERROR,*998)
          ENDIF
        ELSE
          CALL FLAG_ERROR("Column indices is already associated.",ERR,ERROR,*998)
        ENDIF
      ELSE
        CALL FLAG_ERROR("Row indieces is already associated.",ERR,ERROR,*998)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Constraint matrix is not associated.",ERR,ERROR,*998)
    ENDIF
     
    CALL EXITS("CONSTRAINT_MATRIX_STRUCTURE_CALCULATE")
    RETURN
999 IF(ASSOCIATED(ROW_INDICES)) DEALLOCATE(ROW_INDICES)
    IF(ASSOCIATED(COLUMN_INDICES)) DEALLOCATE(COLUMN_INDICES)
    IF(ASSOCIATED(TRANSPOSE_ROW_INDICES)) DEALLOCATE(TRANSPOSE_ROW_INDICES)
    IF(ASSOCIATED(TRANSPOSE_COLUMN_INDICES)) DEALLOCATE(TRANSPOSE_COLUMN_INDICES)
    IF(ALLOCATED(COLUMNS)) DEALLOCATE(COLUMNS)
    IF(ALLOCATED(TRANSPOSE_COLUMNS)) DEALLOCATE(TRANSPOSE_COLUMNS)
    IF(ALLOCATED(COLUMN_INDICES_LISTS)) THEN
      DO local_row=1,SIZE(COLUMN_INDICES_LISTS,1)
        IF(ASSOCIATED(COLUMN_INDICES_LISTS(local_row)%PTR)) &
          & CALL LIST_DESTROY(COLUMN_INDICES_LISTS(local_row)%PTR,DUMMY_ERR,DUMMY_ERROR,*998)
      ENDDO !local_row
      DEALLOCATE(COLUMN_INDICES_LISTS)
    ENDIF
    IF(ALLOCATED(TRANSPOSE_COLUMN_INDICES_LISTS)) THEN
      DO local_column=1,SIZE(TRANSPOSE_COLUMN_INDICES_LISTS,1)
        IF(ASSOCIATED(TRANSPOSE_COLUMN_INDICES_LISTS(local_column)%PTR)) &
          & CALL LIST_DESTROY(TRANSPOSE_COLUMN_INDICES_LISTS(local_column)%PTR,DUMMY_ERR,DUMMY_ERROR,*998)
      ENDDO !local_row
      DEALLOCATE(TRANSPOSE_COLUMN_INDICES_LISTS)
    ENDIF
998 CALL ERRORS("CONSTRAINT_MATRIX_STRUCTURE_CALCULATE",ERR,ERROR)
    CALL EXITS("CONSTRAINT_MATRIX_STRUCTURE_CALCULATE")
    RETURN 1
    
  END SUBROUTINE CONSTRAINT_MATRIX_STRUCTURE_CALCULATE

  !
  !================================================================================================================================
  !

  !>Calculates the Jacobian structure (sparsity) for an constraint Jacobian.
  SUBROUTINE CONSTRAINT_JACOBIAN_STRUCTURE_CALCULATE(CONSTRAINT_JACOBIAN,NUMBER_OF_NON_ZEROS,ROW_INDICES,COLUMN_INDICES, &
    & TRANSPOSE_ROW_INDICES,TRANSPOSE_COLUMN_INDICES,ERR,ERROR,*)

    !Argument variables
    TYPE(CONSTRAINT_JACOBIAN_TYPE), POINTER :: CONSTRAINT_JACOBIAN !<A pointer to the constraint Jacobian to calculate the strucute for
    INTEGER(INTG), INTENT(OUT) :: NUMBER_OF_NON_ZEROS !<On return, the number of non-zeros in the Jacobian
    INTEGER(INTG), POINTER :: ROW_INDICES(:) !<On return, a pointer to row location indices in compressed row format. The pointer must be NULL on entry and the calling routine is responsible for deallocation.
    INTEGER(INTG), POINTER :: COLUMN_INDICES(:) !<On return, a pointer to the column location indices in compressed row format. The pointer must be NULL on entry and the calling routine is responsible for deallocation.
    INTEGER(INTG), POINTER :: TRANSPOSE_ROW_INDICES(:) !<On return, if the constraint Jacobian has a transpose a pointer to transpose row location indices in compressed row format. The pointer must be NULL on entry and the calling routine is responsible for deallocation.
    INTEGER(INTG), POINTER :: TRANSPOSE_COLUMN_INDICES(:) !<On return, if the constraint Jacobian has a transpose a pointer to the transpose column location indices in compressed row format. The pointer must be NULL on entry and the calling routine is responsible for deallocation.
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
   INTEGER(INTG) :: column_version,column_derivative,column_idx,column_component_idx,column_local_derivative_idx, &
     & column_local_node_idx, column_node,DUMMY_ERR,global_column,global_row,column_element_idx,row_element_idx, &
     & surrounding_element_idx,local_column,local_row,JACOBIAN_NUMBER,NUMBER_OF_COLUMNS,row_component_idx, &
     & row_version,row_derivative,row_local_derivative_idx,row_local_node_idx,row_node,TRANSPOSE_NUMBER_OF_NON_ZEROS
    INTEGER(INTG), ALLOCATABLE :: COLUMNS(:),TRANSPOSE_COLUMNS(:)
    REAL(DP) :: SPARSITY
    TYPE(BASIS_TYPE), POINTER :: COLUMN_BASIS,ROW_BASIS
    TYPE(CONSTRAINT_EQUATIONS_TYPE), POINTER :: CONSTRAINT_EQUATIONS
    TYPE(CONSTRAINT_MAPPING_TYPE), POINTER :: CONSTRAINT_MAPPING
    TYPE(CONSTRAINT_MATRICES_TYPE), POINTER :: CONSTRAINT_MATRICES
    TYPE(CONSTRAINT_MATRICES_NONLINEAR_TYPE), POINTER :: NONLINEAR_MATRICES
    TYPE(DOMAIN_MAPPING_TYPE), POINTER :: COLUMN_DOFS_DOMAIN_MAPPING,ROW_DOFS_DOMAIN_MAPPING
    TYPE(DOMAIN_ELEMENTS_TYPE), POINTER :: COLUMN_DOMAIN_ELEMENTS,ROW_DOMAIN_ELEMENTS
    TYPE(DOMAIN_NODES_TYPE), POINTER :: ROW_DOMAIN_NODES
    TYPE(DOMAIN_NODE_TYPE), POINTER :: ROW_DOMAIN_NODE
    TYPE(FIELD_DOF_TO_PARAM_MAP_TYPE), POINTER :: COLUMN_DOFS_PARAM_MAPPING,ROW_DOFS_PARAM_MAPPING
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: COLUMN_VARIABLE,ROW_VARIABLE
    TYPE(LIST_PTR_TYPE), ALLOCATABLE :: COLUMN_INDICES_LISTS(:)
    TYPE(LIST_PTR_TYPE), ALLOCATABLE :: TRANSPOSE_COLUMN_INDICES_LISTS(:)
    TYPE(VARYING_STRING) :: DUMMY_ERROR,LOCAL_ERROR

    CALL ENTERS("CONSTRAINT_JACOBIAN_STRUCTURE_CALCULATE",ERR,ERROR,*999)

    IF(ASSOCIATED(CONSTRAINT_JACOBIAN)) THEN
      IF(.NOT.ASSOCIATED(ROW_INDICES)) THEN
        IF(.NOT.ASSOCIATED(COLUMN_INDICES)) THEN
          IF(.NOT.ASSOCIATED(TRANSPOSE_ROW_INDICES)) THEN
            IF(.NOT.ASSOCIATED(TRANSPOSE_COLUMN_INDICES)) THEN
              JACOBIAN_NUMBER=CONSTRAINT_JACOBIAN%JACOBIAN_NUMBER
              SELECT CASE(CONSTRAINT_JACOBIAN%STRUCTURE_TYPE)
              CASE(CONSTRAINT_MATRIX_NO_STRUCTURE)
                CALL FLAG_ERROR("There is no structure to calculate for a Jacobian with no structure.",ERR,ERROR,*998)
              CASE(CONSTRAINT_MATRIX_FEM_STRUCTURE)
                SELECT CASE(CONSTRAINT_JACOBIAN%STORAGE_TYPE)
                CASE(MATRIX_COMPRESSED_ROW_STORAGE_TYPE)
                  NONLINEAR_MATRICES=>CONSTRAINT_JACOBIAN%NONLINEAR_MATRICES
                  IF(ASSOCIATED(NONLINEAR_MATRICES)) THEN
                    CONSTRAINT_MATRICES=>NONLINEAR_MATRICES%CONSTRAINT_MATRICES
                    IF(ASSOCIATED(CONSTRAINT_MATRICES)) THEN
                      CONSTRAINT_EQUATIONS=>CONSTRAINT_MATRICES%CONSTRAINT_EQUATIONS
                      IF(ASSOCIATED(CONSTRAINT_EQUATIONS)) THEN
                        CONSTRAINT_MAPPING=>CONSTRAINT_MATRICES%CONSTRAINT_MAPPING
                        IF(ASSOCIATED(CONSTRAINT_MAPPING)) THEN
                          ROW_VARIABLE=>CONSTRAINT_MAPPING%NONLINEAR_MAPPING% &
                            & CONSTRAINT_JACOBIAN_ROWS_TO_VAR_MAP(JACOBIAN_NUMBER)%VARIABLE
                          IF(ASSOCIATED(ROW_VARIABLE)) THEN
                            COLUMN_VARIABLE=>CONSTRAINT_MAPPING%LAGRANGE_VARIABLE
                            IF(ASSOCIATED(COLUMN_VARIABLE)) THEN
                              ROW_DOFS_DOMAIN_MAPPING=>ROW_VARIABLE%DOMAIN_MAPPING
                              IF(ASSOCIATED(ROW_DOFS_DOMAIN_MAPPING)) THEN
                                COLUMN_DOFS_DOMAIN_MAPPING=>COLUMN_VARIABLE%DOMAIN_MAPPING
                                IF(ASSOCIATED(COLUMN_DOFS_DOMAIN_MAPPING)) THEN
                                  ROW_DOFS_PARAM_MAPPING=>ROW_VARIABLE%DOF_TO_PARAM_MAP
                                  IF(ASSOCIATED(ROW_DOFS_PARAM_MAPPING)) THEN
                                    COLUMN_DOFS_PARAM_MAPPING=>COLUMN_VARIABLE%DOF_TO_PARAM_MAP
                                    IF(ASSOCIATED(COLUMN_DOFS_PARAM_MAPPING)) THEN
                                      !Allocate lists
                                      ALLOCATE(COLUMN_INDICES_LISTS(ROW_DOFS_DOMAIN_MAPPING%TOTAL_NUMBER_OF_LOCAL),STAT=ERR)
                                      IF(ERR/=0) CALL FLAG_ERROR("Could not allocate column indices lists.",ERR,ERROR,*999)
                                      !Allocate row indices
                                      ALLOCATE(ROW_INDICES(ROW_DOFS_DOMAIN_MAPPING%TOTAL_NUMBER_OF_LOCAL+1),STAT=ERR)
                                      IF(ERR/=0) CALL FLAG_ERROR("Could not allocate row indices.",ERR,ERROR,*999)
                                      DO local_row=1,ROW_DOFS_DOMAIN_MAPPING%TOTAL_NUMBER_OF_LOCAL
                                        !Set up list
                                        NULLIFY(COLUMN_INDICES_LISTS(local_row)%PTR)
                                        CALL LIST_CREATE_START(COLUMN_INDICES_LISTS(local_row)%PTR,ERR,ERROR,*999)
                                        CALL LIST_DATA_TYPE_SET(COLUMN_INDICES_LISTS(local_row)%PTR,LIST_INTG_TYPE, &
                                          & ERR,ERROR,*999)
                                        CALL LIST_INITIAL_SIZE_SET(COLUMN_INDICES_LISTS(local_row)%PTR,50,ERR,ERROR,*999)
                                        CALL LIST_CREATE_FINISH(COLUMN_INDICES_LISTS(local_row)%PTR,ERR,ERROR,*999)
                                      ENDDO !local_row
                                      IF(CONSTRAINT_JACOBIAN%HAS_TRANSPOSE) THEN
                                        !Allocate transpose lists
                                        ALLOCATE(TRANSPOSE_COLUMN_INDICES_LISTS(COLUMN_DOFS_DOMAIN_MAPPING% &
                                          & TOTAL_NUMBER_OF_LOCAL),STAT=ERR)
                                        IF(ERR/=0) CALL FLAG_ERROR("Could not allocate transpose column indices lists.", &
                                          & ERR,ERROR,*999)
                                        DO local_row=1,COLUMN_DOFS_DOMAIN_MAPPING%TOTAL_NUMBER_OF_LOCAL
                                          !Set up list
                                          NULLIFY(TRANSPOSE_COLUMN_INDICES_LISTS(local_row)%PTR)
                                          CALL LIST_CREATE_START(TRANSPOSE_COLUMN_INDICES_LISTS(local_row)%PTR, &
                                            & ERR,ERROR,*999)
                                          CALL LIST_DATA_TYPE_SET(TRANSPOSE_COLUMN_INDICES_LISTS(local_row)%PTR, &
                                            & LIST_INTG_TYPE,ERR,ERROR,*999)
                                          CALL LIST_INITIAL_SIZE_SET(TRANSPOSE_COLUMN_INDICES_LISTS(local_row)%PTR,50, &
                                            & ERR,ERROR,*999)
                                          CALL LIST_CREATE_FINISH(TRANSPOSE_COLUMN_INDICES_LISTS(local_row)%PTR, &
                                            & ERR,ERROR,*999)
                                        ENDDO !local_row
                                        !Allocate transpose row indices
                                        ALLOCATE(TRANSPOSE_ROW_INDICES(COLUMN_DOFS_DOMAIN_MAPPING%TOTAL_NUMBER_OF_LOCAL+1), &
                                          & STAT=ERR)
                                        IF(ERR/=0) CALL FLAG_ERROR("Could not allocate transpose row indices.",ERR,ERROR,*999)
                                      ENDIF
                                      !Loop over the number of components in the dependent field variable
                                      DO row_component_idx=1,ROW_VARIABLE%NUMBER_OF_COMPONENTS
                                        IF(ROW_VARIABLE%COMPONENTS(row_component_idx)%INTERPOLATION_TYPE== &
                                          & FIELD_NODE_BASED_INTERPOLATION) THEN
                                          !Loop over the elements in the constraint mesh
                                          ROW_DOMAIN_ELEMENTS=>ROW_VARIABLE%COMPONENTS(row_component_idx)%DOMAIN% &
                                            & TOPOLOGY%ELEMENTS
                                          ROW_DOMAIN_NODES=>ROW_VARIABLE%COMPONENTS(row_component_idx)%DOMAIN% &
                                            & TOPOLOGY%NODES
                                          DO row_element_idx=1,ROW_DOMAIN_ELEMENTS%TOTAL_NUMBER_OF_ELEMENTS
                                            ROW_BASIS=>ROW_DOMAIN_ELEMENTS%ELEMENTS(row_element_idx)%BASIS
                                            !Loop over the row DOFs in the element
                                            DO row_local_node_idx=1,ROW_BASIS%NUMBER_OF_NODES
                                              row_node=ROW_DOMAIN_ELEMENTS%ELEMENTS(row_element_idx)% &
                                                & ELEMENT_NODES(row_local_node_idx)
                                              ROW_DOMAIN_NODE=>ROW_DOMAIN_NODES%NODES(row_node)
                                              DO row_local_derivative_idx=1,ROW_BASIS% &
                                                & NUMBER_OF_DERIVATIVES(row_local_node_idx)
                                                row_derivative=ROW_DOMAIN_ELEMENTS%ELEMENTS(row_element_idx)% &
                                                  & ELEMENT_DERIVATIVES(row_local_derivative_idx,row_local_node_idx)
                                                row_version=ROW_DOMAIN_ELEMENTS%ELEMENTS(row_element_idx)% &
                                                  & elementVersions(row_local_derivative_idx,row_local_node_idx)
                                                local_row=ROW_VARIABLE%COMPONENTS(row_component_idx)% &
                                                  & PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NODES(row_node)% &
                                                  & DERIVATIVES(row_derivative)%VERSIONS(row_version)
                                                global_row=ROW_DOFS_DOMAIN_MAPPING%LOCAL_TO_GLOBAL_MAP(local_row)
                                                !Loop over the components in the Lagrange multiplier variable
                                                DO column_component_idx=1,COLUMN_VARIABLE%NUMBER_OF_COMPONENTS
                                                  SELECT CASE(COLUMN_VARIABLE%COMPONENTS(column_component_idx)%INTERPOLATION_TYPE)
                                                  CASE(FIELD_CONSTANT_INTERPOLATION)
                                                    local_column=COLUMN_VARIABLE%COMPONENTS(column_component_idx)% &
                                                      & PARAM_TO_DOF_MAP%CONSTANT_PARAM2DOF_MAP
                                                    global_column=COLUMN_DOFS_DOMAIN_MAPPING%LOCAL_TO_GLOBAL_MAP(local_column)
                                                    CALL LIST_ITEM_ADD(COLUMN_INDICES_LISTS(local_row)%PTR,global_column, &
                                                      & ERR,ERROR,*999)
                                                    IF(CONSTRAINT_JACOBIAN%HAS_TRANSPOSE) THEN
                                                      CALL LIST_ITEM_ADD(TRANSPOSE_COLUMN_INDICES_LISTS(local_column)%PTR, &
                                                        & global_row,ERR,ERROR,*999)
                                                    ENDIF
                                                  CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                                                    COLUMN_DOMAIN_ELEMENTS=>COLUMN_VARIABLE%COMPONENTS(column_component_idx)% &
                                                      & DOMAIN%TOPOLOGY%ELEMENTS
                                                    DO surrounding_element_idx=1,ROW_DOMAIN_NODE%NUMBER_OF_SURROUNDING_ELEMENTS
                                                      column_element_idx=ROW_DOMAIN_NODE%SURROUNDING_ELEMENTS( &
                                                        & surrounding_element_idx)
                                                      local_column=COLUMN_VARIABLE%COMPONENTS(column_component_idx)% &
                                                        & PARAM_TO_DOF_MAP%ELEMENT_PARAM2DOF_MAP%ELEMENTS(column_element_idx)
                                                      global_column=COLUMN_DOFS_DOMAIN_MAPPING%LOCAL_TO_GLOBAL_MAP(local_column)
                                                      CALL LIST_ITEM_ADD(COLUMN_INDICES_LISTS(local_row)%PTR, &
                                                        & global_column,err,error,*999)
                                                      IF(CONSTRAINT_JACOBIAN%HAS_TRANSPOSE) THEN
                                                        CALL LIST_ITEM_ADD(TRANSPOSE_COLUMN_INDICES_LISTS(local_column)%PTR, &
                                                          & global_row,ERR,ERROR,*999)
                                                      ENDIF
                                                    ENDDO !surrounding_element_idx
                                                  CASE(FIELD_NODE_BASED_INTERPOLATION)
                                                    COLUMN_DOMAIN_ELEMENTS=>COLUMN_VARIABLE%COMPONENTS(column_component_idx)% &
                                                      & DOMAIN%TOPOLOGY%ELEMENTS
                                                    DO surrounding_element_idx=1,ROW_DOMAIN_NODE%NUMBER_OF_SURROUNDING_ELEMENTS
                                                      column_element_idx=ROW_DOMAIN_NODE%SURROUNDING_ELEMENTS( &
                                                        & surrounding_element_idx)
                                                      COLUMN_BASIS=>COLUMN_DOMAIN_ELEMENTS%ELEMENTS(column_element_idx)%BASIS
                                                      !Loop over the column DOFs in the domain mesh element
                                                      DO column_local_node_idx=1,COLUMN_BASIS%NUMBER_OF_NODES
                                                        column_node=COLUMN_DOMAIN_ELEMENTS%ELEMENTS(column_element_idx)% &
                                                          & ELEMENT_NODES(column_local_node_idx)
                                                        DO column_local_derivative_idx=1,COLUMN_BASIS% &
                                                          & NUMBER_OF_DERIVATIVES(column_local_node_idx)
                                                          column_derivative=COLUMN_DOMAIN_ELEMENTS%ELEMENTS(column_element_idx)% &
                                                            & ELEMENT_DERIVATIVES(column_local_derivative_idx,column_local_node_idx)
                                                          column_version=COLUMN_DOMAIN_ELEMENTS%ELEMENTS(column_element_idx)% &
                                                            & elementVersions(column_local_derivative_idx,column_local_node_idx)
                                                          local_column=COLUMN_VARIABLE%COMPONENTS(column_component_idx)% &
                                                            & PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NODES(column_node)% &
                                                            & DERIVATIVES(column_derivative)%VERSIONS(column_version)
                                                          global_column=COLUMN_DOFS_DOMAIN_MAPPING% &
                                                            & LOCAL_TO_GLOBAL_MAP(local_column)
                                                          CALL LIST_ITEM_ADD(COLUMN_INDICES_LISTS(local_row)%PTR,global_column, &
                                                            & ERR,ERROR,*999)
                                                          IF(CONSTRAINT_JACOBIAN%HAS_TRANSPOSE) THEN
                                                            CALL LIST_ITEM_ADD(TRANSPOSE_COLUMN_INDICES_LISTS(local_column)%PTR, &
                                                              & global_row,ERR,ERROR,*999)
                                                          ENDIF
                                                        ENDDO !column_local_derivative_idx
                                                      ENDDO !column_local_node_idx
                                                    ENDDO !surrounding_element_idx
                                                  CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                                                    CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
                                                  CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                                                    CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
                                                  CASE DEFAULT
                                                    LOCAL_ERROR="The column variable interpolation type of "// &
                                                      & TRIM(NUMBER_TO_VSTRING(COLUMN_VARIABLE%COMPONENTS(column_component_idx)% &
                                                      INTERPOLATION_TYPE,"*",ERR,ERROR))//" is invalid."
                                                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                                                  END SELECT
                                                ENDDO !column_component_idx
                                              ENDDO !row_local_derivative_idx
                                            ENDDO !row_local_node_idx
                                          ENDDO !constraint_element_idx
                                        ELSE
                                          CALL FLAG_ERROR("Only node based fields implemented.",ERR,ERROR,*999)
                                        ENDIF
                                      ENDDO !column_component_idx
                                      NUMBER_OF_NON_ZEROS=0
                                      ROW_INDICES(1)=1
                                      DO local_row=1,ROW_DOFS_DOMAIN_MAPPING%TOTAL_NUMBER_OF_LOCAL
                                        CALL LIST_REMOVE_DUPLICATES(COLUMN_INDICES_LISTS(local_row)%PTR,ERR,ERROR,*999)
                                        CALL LIST_NUMBER_OF_ITEMS_GET(COLUMN_INDICES_LISTS(local_row)%PTR,NUMBER_OF_COLUMNS, &
                                          & ERR,ERROR,*999)
                                        NUMBER_OF_NON_ZEROS=NUMBER_OF_NON_ZEROS+NUMBER_OF_COLUMNS
                                        ROW_INDICES(local_row+1)=NUMBER_OF_NON_ZEROS+1
                                      ENDDO !local_row
                                      IF(CONSTRAINT_JACOBIAN%HAS_TRANSPOSE) THEN
                                        TRANSPOSE_NUMBER_OF_NON_ZEROS=0
                                        TRANSPOSE_ROW_INDICES(1)=1
                                        DO local_row=1,COLUMN_DOFS_DOMAIN_MAPPING%TOTAL_NUMBER_OF_LOCAL
                                          CALL LIST_REMOVE_DUPLICATES(TRANSPOSE_COLUMN_INDICES_LISTS(local_row)%PTR, &
                                            & ERR,ERROR,*999)
                                          CALL LIST_NUMBER_OF_ITEMS_GET(TRANSPOSE_COLUMN_INDICES_LISTS(local_row)%PTR, &
                                            & NUMBER_OF_COLUMNS,ERR,ERROR,*999)
                                          TRANSPOSE_NUMBER_OF_NON_ZEROS=TRANSPOSE_NUMBER_OF_NON_ZEROS+NUMBER_OF_COLUMNS
                                          TRANSPOSE_ROW_INDICES(local_row+1)=TRANSPOSE_NUMBER_OF_NON_ZEROS+1
                                        ENDDO !local_row
                                        !Sanity check - the number of non-zeros should be the same
                                        IF(TRANSPOSE_NUMBER_OF_NON_ZEROS/=NUMBER_OF_NON_ZEROS) THEN
                                          LOCAL_ERROR="Invalid number of non-zeros. The number of non-zeros in the "// &
                                            & "transposed Jacobian ("//TRIM(NUMBER_TO_VSTRING(TRANSPOSE_NUMBER_OF_NON_ZEROS, &
                                            & "*",ERR,ERROR))//") does not match the number of non-zeros in the constraint "// &
                                            & "Jacobian ("//TRIM(NUMBER_TO_VSTRING(TRANSPOSE_NUMBER_OF_NON_ZEROS,"*",ERR, &
                                            & ERROR))//")."
                                          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                                        ENDIF
                                      ENDIF
                                      !Allocate and setup the column locations
                                      ALLOCATE(COLUMN_INDICES(NUMBER_OF_NON_ZEROS),STAT=ERR)
                                      IF(ERR/=0) CALL FLAG_ERROR("Could not allocate row indices.",ERR,ERROR,*999)
                                      DO local_row=1,ROW_DOFS_DOMAIN_MAPPING%TOTAL_NUMBER_OF_LOCAL
                                        CALL LIST_DETACH_AND_DESTROY(COLUMN_INDICES_LISTS(local_row)%PTR,NUMBER_OF_COLUMNS, &
                                          & COLUMNS,ERR,ERROR,*999)
                                        DO column_idx=1,NUMBER_OF_COLUMNS
                                          COLUMN_INDICES(ROW_INDICES(local_row)+column_idx-1)=COLUMNS(column_idx)
                                        ENDDO !column_idx
                                        DEALLOCATE(COLUMNS)
                                      ENDDO !local_row
                                      IF(CONSTRAINT_JACOBIAN%HAS_TRANSPOSE) THEN
                                        !Allocate and setup the column locations
                                        ALLOCATE(TRANSPOSE_COLUMN_INDICES(TRANSPOSE_NUMBER_OF_NON_ZEROS),STAT=ERR)
                                        IF(ERR/=0) &
                                          & CALL FLAG_ERROR("Could not allocate transpose column indices.",ERR,ERROR,*999)
                                        DO local_row=1,COLUMN_DOFS_DOMAIN_MAPPING%TOTAL_NUMBER_OF_LOCAL
                                          CALL LIST_DETACH_AND_DESTROY(TRANSPOSE_COLUMN_INDICES_LISTS(local_row)%PTR, &
                                            & NUMBER_OF_COLUMNS,TRANSPOSE_COLUMNS,ERR,ERROR,*999)
                                          DO column_idx=1,NUMBER_OF_COLUMNS
                                            TRANSPOSE_COLUMN_INDICES(TRANSPOSE_ROW_INDICES(local_row)+column_idx-1)= &
                                              & TRANSPOSE_COLUMNS(column_idx)
                                          ENDDO !row_idx
                                          DEALLOCATE(TRANSPOSE_COLUMNS)
                                        ENDDO !local_column
                                      ENDIF
                                      IF(DIAGNOSTICS1) THEN
                                        CALL WRITE_STRING(DIAGNOSTIC_OUTPUT_TYPE,"Constraint Jacobian structure:",ERR,ERROR,*999)
                                        CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"Constraint Jacobian number : ", &
                                          & JACOBIAN_NUMBER,ERR,ERROR,*999)
                                        CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"  Number of rows = ", &
                                          & ROW_DOFS_DOMAIN_MAPPING%TOTAL_NUMBER_OF_LOCAL,ERR,ERROR,*999)
                                        CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"  Number of columns = ", &
                                          & COLUMN_DOFS_DOMAIN_MAPPING%NUMBER_OF_GLOBAL,ERR,ERROR,*999)
                                        CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"  Number of non zeros = ", &
                                          & NUMBER_OF_NON_ZEROS,ERR,ERROR,*999)
                                        IF(ROW_DOFS_DOMAIN_MAPPING%TOTAL_NUMBER_OF_LOCAL* &
                                          & COLUMN_DOFS_DOMAIN_MAPPING%NUMBER_OF_GLOBAL/=0) THEN
                                          SPARSITY=(1.0_DP-REAL(NUMBER_OF_NON_ZEROS,DP)/REAL(ROW_DOFS_DOMAIN_MAPPING% &
                                            & TOTAL_NUMBER_OF_LOCAL*COLUMN_DOFS_DOMAIN_MAPPING%NUMBER_OF_GLOBAL,DP))*100.0_DP
                                          CALL WRITE_STRING_FMT_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"  Sparsity (%) = ",SPARSITY, &
                                            & "F6.2",ERR,ERROR,*999)
                                        ENDIF
                                        CALL WRITE_STRING_VECTOR(DIAGNOSTIC_OUTPUT_TYPE,1,1,ROW_DOFS_DOMAIN_MAPPING% &
                                          & TOTAL_NUMBER_OF_LOCAL+1,5,5,ROW_INDICES, &
                                          & '("  Row indices              :",5(X,I13))','(28X,5(X,I13))',ERR,ERROR,*999)
                                        CALL WRITE_STRING_VECTOR(DIAGNOSTIC_OUTPUT_TYPE,1,1,NUMBER_OF_NON_ZEROS,8,8, &
                                          & COLUMN_INDICES,'("  Column indices           :",5(X,I13))','(28X,5(X,I13))', &
                                          & ERR,ERROR,*999)
                                        IF(CONSTRAINT_JACOBIAN%HAS_TRANSPOSE) THEN 
                                          CALL WRITE_STRING_VECTOR(DIAGNOSTIC_OUTPUT_TYPE,1,1,COLUMN_DOFS_DOMAIN_MAPPING% &
                                            & TOTAL_NUMBER_OF_LOCAL+1,5,5,TRANSPOSE_ROW_INDICES, &
                                            & '("  Transpose row indices    :",5(X,I13))','(28X,5(X,I13))',ERR,ERROR,*999)
                                          CALL WRITE_STRING_VECTOR(DIAGNOSTIC_OUTPUT_TYPE,1,1,NUMBER_OF_NON_ZEROS,8,8, &
                                            & TRANSPOSE_COLUMN_INDICES,'("  Transpose column indices :",5(X,I13))', &
                                            & '(28X,5(X,I13))',ERR,ERROR,*999)
                                        ENDIF
                                      ENDIF
                                    ELSE
                                      CALL FLAG_ERROR("Column dofs parameter mapping is not associated.",ERR,ERROR,*999)
                                    ENDIF
                                  ELSE
                                    CALL FLAG_ERROR("Row dofs parameter mapping is not associated.",ERR,ERROR,*999)
                                  ENDIF
                                ELSE
                                  CALL FLAG_ERROR("Column dofs domain mapping is not associated.",ERR,ERROR,*999)
                                ENDIF
                              ELSE
                                CALL FLAG_ERROR("Row dofs domain mapping is not associated.",ERR,ERROR,*999)
                              ENDIF
                            ELSE
                              CALL FLAG_ERROR("Column field variable is not associated.",ERR,ERROR,*999)
                            ENDIF
                          ELSE
                            CALL FLAG_ERROR("Row field variable is not associated.",ERR,ERROR,*999)
                          ENDIF
                        ELSE
                          CALL FLAG_ERROR("Constraint mapping is not associated.",ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FLAG_ERROR("Constraint equations is not associated.",ERR,ERROR,*999)
                      ENDIF
                    ELSE
                      CALL FLAG_ERROR("Constraint matrices is not associated.",ERR,ERROR,*999)
                    ENDIF
                  ELSE
                    CALL FLAG_ERROR("Nonlinear constraint matrices is not associated.",err,error,*999)
                  ENDIF
                CASE DEFAULT
                  LOCAL_ERROR="The Jacobian storage type of "// &
                    & TRIM(NUMBER_TO_VSTRING(CONSTRAINT_JACOBIAN%STORAGE_TYPE,"*",ERR,ERROR))//" is invalid."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                END SELECT
              CASE DEFAULT
                LOCAL_ERROR="The Jacobian structure type of "// &
                  & TRIM(NUMBER_TO_VSTRING(CONSTRAINT_JACOBIAN%STRUCTURE_TYPE,"*",ERR,ERROR))//" is invalid."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*998)
              END SELECT
            ELSE
              CALL FLAG_ERROR("Transpose column indices is already associated.",ERR,ERROR,*998)
            ENDIF
          ELSE
            CALL FLAG_ERROR("Transpose row indieces is already associated.",ERR,ERROR,*998)
          ENDIF
        ELSE
          CALL FLAG_ERROR("Column indices is already associated.",ERR,ERROR,*998)
        ENDIF
      ELSE
        CALL FLAG_ERROR("Row indieces is already associated.",ERR,ERROR,*998)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Constraint Jacobian is not associated.",ERR,ERROR,*998)
    ENDIF
     
    CALL EXITS("CONSTRAINT_JACOBIAN_STRUCTURE_CALCULATE")
    RETURN
999 IF(ASSOCIATED(ROW_INDICES)) DEALLOCATE(ROW_INDICES)
    IF(ASSOCIATED(COLUMN_INDICES)) DEALLOCATE(COLUMN_INDICES)
    IF(ASSOCIATED(TRANSPOSE_ROW_INDICES)) DEALLOCATE(TRANSPOSE_ROW_INDICES)
    IF(ASSOCIATED(TRANSPOSE_COLUMN_INDICES)) DEALLOCATE(TRANSPOSE_COLUMN_INDICES)
    IF(ALLOCATED(COLUMNS)) DEALLOCATE(COLUMNS)
    IF(ALLOCATED(TRANSPOSE_COLUMNS)) DEALLOCATE(TRANSPOSE_COLUMNS)
    IF(ALLOCATED(COLUMN_INDICES_LISTS)) THEN
      DO local_row=1,SIZE(COLUMN_INDICES_LISTS,1)
        IF(ASSOCIATED(COLUMN_INDICES_LISTS(local_row)%PTR)) &
          & CALL LIST_DESTROY(COLUMN_INDICES_LISTS(local_row)%PTR,DUMMY_ERR,DUMMY_ERROR,*998)
      ENDDO !local_row
      DEALLOCATE(COLUMN_INDICES_LISTS)
    ENDIF
    IF(ALLOCATED(TRANSPOSE_COLUMN_INDICES_LISTS)) THEN
      DO local_column=1,SIZE(TRANSPOSE_COLUMN_INDICES_LISTS,1)
        IF(ASSOCIATED(TRANSPOSE_COLUMN_INDICES_LISTS(local_column)%PTR)) &
          & CALL LIST_DESTROY(TRANSPOSE_COLUMN_INDICES_LISTS(local_column)%PTR,DUMMY_ERR,DUMMY_ERROR,*998)
      ENDDO !local_row
      DEALLOCATE(TRANSPOSE_COLUMN_INDICES_LISTS)
    ENDIF
998 CALL ERRORS("CONSTRAINT_JACOBIAN_STRUCTURE_CALCULATE",ERR,ERROR)
    CALL EXITS("CONSTRAINT_JACOBIAN_STRUCTURE_CALCULATE")
    RETURN 1
    
  END SUBROUTINE CONSTRAINT_JACOBIAN_STRUCTURE_CALCULATE

  !
  !================================================================================================================================
  !
 
END MODULE CONSTRAINT_MATRICES_ROUTINES
