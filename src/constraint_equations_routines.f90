!> \file
!> \author Chris Bradley
!> \brief This module handles all constraint equations routines.
!>
!> \section LICENSE
!>
!> Version: MPL 1.1/GPL 2.0/LGPL 2.1
!>
!> The contents of this file are subject to the Mozilla Public License
!> Version 1.1 (the "License"); you may not use this file except in
!> compliance with the License. You may obtain a copy of the License at
!> http://www.mozilla.org/MPL/
!>
!> Software distributed under the License is distributed on an "AS IS"
!> basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
!> License for the specific language governing rights and limitations
!> under the License.
!>
!> The Original Code is OpenCMISS
!>
!> The Initial Developer of the Original Code is University of Auckland,
!> Auckland, New Zealand, the University of Oxford, Oxford, United
!> Kingdom and King's College, London, United Kingdom. Portions created
!> by the University of Auckland, the University of Oxford and King's
!> College, London are Copyright (C) 2007-2010 by the University of
!> Auckland, the University of Oxford and King's College, London.
!> All Rights Reserved.
!>
!> Contributor(s):
!>
!> Alternatively, the contents of this file may be used under the terms of
!> either the GNU General Public License Version 2 or later (the "GPL"), or
!> the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
!> in which case the provisions of the GPL or the LGPL are applicable instead
!> of those above. If you wish to allow use of your version of this file only
!> under the terms of either the GPL or the LGPL, and not to allow others to
!> use your version of this file under the terms of the MPL, indicate your
!> decision by deleting the provisions above and replace them with the notice
!> and other provisions required by the GPL or the LGPL. If you do not delete
!> the provisions above, a recipient may use your version of this file under
!> the terms of any one of the MPL, the GPL or the LGPL.
!>

!> This module handles all constraint equations routines.
MODULE CONSTRAINT_EQUATIONS_ROUTINES

  USE BASE_ROUTINES
  USE CONSTRAINT_MAPPING_ROUTINES
  USE CONSTRAINT_MATRICES_CONSTANTS
  USE CONSTRAINT_MATRICES_ROUTINES
  USE CONSTRAINT_CONDITIONS_CONSTANTS
  USE FIELD_ROUTINES
  USE ISO_VARYING_STRING
  USE KINDS
  USE STRINGS
  USE TYPES

  IMPLICIT NONE

  PRIVATE


  !> \addtogroup CONSTRAINT_EQUATIONS_ROUTINES_OutputTypes CONSTRAINT_EQUATIONS_ROUTINES::OutputTypes
  !> \brief The constraint equations output types
  !> \see CONSTRAINT_EQUATIONS_ROUTINES,OPENCMISS_ConstraintEquationsConstants
  !>@{
  INTEGER(INTG), PARAMETER :: CONSTRAINT_EQUATIONS_NO_OUTPUT=0 !<No output. \see CONSTRAINT_EQUATIONS_ROUTINES_OutputTypes,CONSTRAINT_EQUATIONS_ROUTINES
  INTEGER(INTG), PARAMETER :: CONSTRAINT_EQUATIONS_TIMING_OUTPUT=1 !<Timing information output. \see CONSTRAINT_EQUATIONS_ROUTINES_OutputTypes,CONSTRAINT_EQUATIONS_ROUTINES
  INTEGER(INTG), PARAMETER :: CONSTRAINT_MATRIX_OUTPUT=2 !<All below and constraint equation matrices output. \see CONSTRAINT_EQUATIONS_ROUTINES_OutputTypes,CONSTRAINT_EQUATIONS_ROUTINES
  INTEGER(INTG), PARAMETER :: CONSTRAINT_EQUATIONS_ELEMENT_MATRIX_OUTPUT=3 !<All below and element matrices output. \see CONSTRAINT_EQUATIONS_ROUTINES_OutputTypes,CONSTRAINT_EQUATIONS_ROUTINES
  !>@}

  !> \addtogroup CONSTRAINT_EQUATIONS_ROUTINES_SparsityTypes CONSTRAINT_EQUATIONS_ROUTINES::SparsityTypes
  !> \brief Constraint equations matrices sparsity types
  !> \see CONSTRAINT_EQUATIONS_ROUTINES,OPENCMISS_ConstraintEquationsSparsityTypes
  !>@{
  INTEGER(INTG), PARAMETER :: CONSTRAINT_EQUATIONS_SPARSE_MATRICES=1 !<Use sparse matrices for the constraint equations. \see CONSTRAINT_EQUATIONS_ROUTINES_SparsityTypes,CONSTRAINT_EQUATIONS_ROUTINES
  INTEGER(INTG), PARAMETER :: CONSTRAINT_EQUATIONS_FULL_MATRICES=2 !<Use fully populated matrices for the constraint equations. \see CONSTRAINT_EQUATIONS_ROUTINES_SparsityTypes,CONSTRAINT_EQUATIONS_ROUTINES
 !>@}
 
  !Module types

  !Module variables

  !Interfaces

  PUBLIC CONSTRAINT_EQUATIONS_NO_OUTPUT,CONSTRAINT_EQUATIONS_TIMING_OUTPUT,CONSTRAINT_MATRIX_OUTPUT, &
    & CONSTRAINT_EQUATIONS_ELEMENT_MATRIX_OUTPUT

  PUBLIC CONSTRAINT_EQUATIONS_SPARSE_MATRICES,CONSTRAINT_EQUATIONS_FULL_MATRICES

  PUBLIC CONSTRAINT_EQUATIONS_CREATE_START,CONSTRAINT_EQUATIONS_CREATE_FINISH

  PUBLIC CONSTRAINT_EQUATIONS_DESTROY

  PUBLIC CONSTRAINT_EQUATIONS_INITIALISE,CONSTRAINT_EQUATIONS_FINALISE

  PUBLIC CONSTRAINT_EQUATIONS_LINEARITY_TYPE_GET,CONSTRAINT_EQUATIONS_LINEARITY_TYPE_SET

  PUBLIC CONSTRAINT_EQUATIONS_OUTPUT_TYPE_GET,CONSTRAINT_EQUATIONS_OUTPUT_TYPE_SET

  PUBLIC CONSTRAINT_EQUATIONS_SPARSITY_TYPE_GET,CONSTRAINT_EQUATIONS_SPARSITY_TYPE_SET

  PUBLIC CONSTRAINT_EQUATIONS_TIME_DEPENDENCE_TYPE_GET,CONSTRAINT_EQUATIONS_TIME_DEPENDENCE_TYPE_SET

  PUBLIC CONSTRAINT_CONDITION_CONSTRAINT_EQUATIONS_GET

  PUBLIC ConstraintEquations_NumberOfLinearMatricesGet

  PUBLIC ConstraintEquations_NumberOfJacobianMatricesGet

  PUBLIC ConstraintEquations_NumberOfDynamicMatricesGet

  PUBLIC ConstraintEquations_LinearMatrixGet

  PUBLIC ConstraintEquations_JacobianMatrixGet

  PUBLIC ConstraintEquations_DynamicMatrixGet

  PUBLIC ConstraintEquations_DynamicMatrixGetByType

  PUBLIC ConstraintEquations_DynamicMatrixTypeGet

  PUBLIC ConstraintEquations_RhsVectorGet

  PUBLIC ConstraintEquations_ResidualVectorGet

CONTAINS

  !
  !================================================================================================================================
  !

  !>Finish the creation of constraint equations.
  SUBROUTINE CONSTRAINT_EQUATIONS_CREATE_FINISH(CONSTRAINT_EQUATIONS,ERR,ERROR,*)

    !Argument variables
    TYPE(CONSTRAINT_EQUATIONS_TYPE), POINTER :: CONSTRAINT_EQUATIONS !<A pointer to the constraint equations to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables

    CALL ENTERS("CONSTRAINT_EQUATIONS_CREATE_FINISH",ERR,ERROR,*999)

    IF(ASSOCIATED(CONSTRAINT_EQUATIONS)) THEN
      IF(CONSTRAINT_EQUATIONS%CONSTRAINT_EQUATIONS_FINISHED) THEN
        CALL FLAG_ERROR("Constraint equations have already been finished.",ERR,ERROR,*999)        
      ELSE
        !Set the finished flag
        CONSTRAINT_EQUATIONS%CONSTRAINT_EQUATIONS_FINISHED=.TRUE.
      ENDIF
    ELSE
      CALL FLAG_ERROR("Constraint equations is not associated.",ERR,ERROR,*999)
    ENDIF
       
    CALL EXITS("CONSTRAINT_EQUATIONS_CREATE_FINISH")
    RETURN
999 CALL ERRORS("CONSTRAINT_EQUATIONS_CREATE_FINISH",ERR,ERROR)
    CALL EXITS("CONSTRAINT_EQUATIONS_CREATE_FINISH")
    RETURN 1
    
  END SUBROUTINE CONSTRAINT_EQUATIONS_CREATE_FINISH

  !
  !================================================================================================================================
  !

  !>Start the creation of constraint equations for the constraint condition.
  SUBROUTINE CONSTRAINT_EQUATIONS_CREATE_START(CONSTRAINT_CONDITION,CONSTRAINT_EQUATIONS,ERR,ERROR,*)

    !Argument variables
    TYPE(CONSTRAINT_CONDITION_TYPE), POINTER :: CONSTRAINT_CONDITION !<A pointer to the constraint condition to create constraint equations for
    TYPE(CONSTRAINT_EQUATIONS_TYPE), POINTER :: CONSTRAINT_EQUATIONS !<On exit, a pointer to the created constraint equations. Must not be associated on entry.
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables

    CALL ENTERS("CONSTRAINT_EQUATIONS_CREATE_START",ERR,ERROR,*999)

    IF(ASSOCIATED(CONSTRAINT_CONDITION)) THEN
      IF(ASSOCIATED(CONSTRAINT_CONDITION%CONSTRAINT_EQUATIONS)) THEN
        CALL FLAG_ERROR("Constraint equations are already associated for the constraint condition.",ERR,ERROR,*999)        
      ELSE
        IF(ASSOCIATED(CONSTRAINT_EQUATIONS)) THEN
          CALL FLAG_ERROR("Constraint equations is already associated.",ERR,ERROR,*999)
        ELSE
          !Initialise the constraint equations
          CALL CONSTRAINT_EQUATIONS_INITIALISE(CONSTRAINT_CONDITION,ERR,ERROR,*999)
          !Return the pointer
          CONSTRAINT_EQUATIONS=>CONSTRAINT_CONDITION%CONSTRAINT_EQUATIONS
        ENDIF
      ENDIF
    ELSE
      CALL FLAG_ERROR("Constraint condition is not associated.",ERR,ERROR,*999)
    ENDIF
       
    CALL EXITS("CONSTRAINT_EQUATIONS_CREATE_START")
    RETURN
999 CALL ERRORS("CONSTRAINT_EQUATIONS_CREATE_START",ERR,ERROR)
    CALL EXITS("CONSTRAINT_EQUATIONS_CREATE_START")
    RETURN 1
    
  END SUBROUTINE CONSTRAINT_EQUATIONS_CREATE_START

  !
  !================================================================================================================================
  !

  !>Destroys constraint equations
  SUBROUTINE CONSTRAINT_EQUATIONS_DESTROY(CONSTRAINT_EQUATIONS,ERR,ERROR,*)

    !Argument variables
    TYPE(CONSTRAINT_EQUATIONS_TYPE), POINTER :: CONSTRAINT_EQUATIONS !<A pointer to the constraint equations to destroy
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables

    CALL ENTERS("CONSTRAINT_EQUATIONS_DESTROY",ERR,ERROR,*999)

    IF(ASSOCIATED(CONSTRAINT_EQUATIONS)) THEN
      CALL CONSTRAINT_EQUATIONS_FINALISE(CONSTRAINT_EQUATIONS,ERR,ERROR,*999)
    ELSE
      CALL FLAG_ERROR("Constraint equations is not associated.",ERR,ERROR,*999)
    ENDIF
       
    CALL EXITS("CONSTRAINT_EQUATIONS_DESTROY")
    RETURN
999 CALL ERRORS("CONSTRAINT_EQUATIONS_DESTROY",ERR,ERROR)
    CALL EXITS("CONSTRAINT_EQUATIONS_DESTROY")
    RETURN 1
    
  END SUBROUTINE CONSTRAINT_EQUATIONS_DESTROY

  !
  !================================================================================================================================
  !

  !>Finalise the constraint equations and deallocate all memory.
  SUBROUTINE CONSTRAINT_EQUATIONS_FINALISE(CONSTRAINT_EQUATIONS,ERR,ERROR,*)

    !Argument variables
    TYPE(CONSTRAINT_EQUATIONS_TYPE), POINTER :: CONSTRAINT_EQUATIONS !<A pointer to the constraint equations to finalise
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables

    CALL ENTERS("CONSTRAINT_EQUATIONS_FINALISE",ERR,ERROR,*999)

    IF(ASSOCIATED(CONSTRAINT_EQUATIONS)) THEN
      CALL CONSTRAINT_EQUATIONS_INTERPOLATION_FINALISE(CONSTRAINT_EQUATIONS%INTERPOLATION,ERR,ERROR,*999)
      IF(ASSOCIATED(CONSTRAINT_EQUATIONS%CONSTRAINT_MAPPING)) &
        & CALL CONSTRAINT_MAPPING_DESTROY(CONSTRAINT_EQUATIONS%CONSTRAINT_MAPPING,ERR,ERROR,*999)
      IF(ASSOCIATED(CONSTRAINT_EQUATIONS%CONSTRAINT_MATRICES)) &
        & CALL CONSTRAINT_MATRICES_DESTROY(CONSTRAINT_EQUATIONS%CONSTRAINT_MATRICES,ERR,ERROR,*999)
      DEALLOCATE(CONSTRAINT_EQUATIONS)
    ENDIF
       
    CALL EXITS("CONSTRAINT_EQUATIONS_FINALISE")
    RETURN
999 CALL ERRORS("CONSTRAINT_EQUATIONS_FINALISE",ERR,ERROR)
    CALL EXITS("CONSTRAINT_EQUATIONS_FINALISE")
    RETURN 1
  END SUBROUTINE CONSTRAINT_EQUATIONS_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialises the constraint equations for an constraint condition.
  SUBROUTINE CONSTRAINT_EQUATIONS_INITIALISE(CONSTRAINT_CONDITION,ERR,ERROR,*)

    !Argument variables
    TYPE(CONSTRAINT_CONDITION_TYPE), POINTER :: CONSTRAINT_CONDITION !<A pointer to the constraint condition to initialise the constraint equations for
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DUMMY_ERR
    TYPE(VARYING_STRING) :: DUMMY_ERROR
 
    CALL ENTERS("CONSTRAINT_EQUATIONS_INITIALISE",ERR,ERROR,*998)

    IF(ASSOCIATED(CONSTRAINT_CONDITION)) THEN
      IF(ASSOCIATED(CONSTRAINT_CONDITION%CONSTRAINT_EQUATIONS)) THEN
        CALL FLAG_ERROR("Constraint equations is already associated for this constraint condition.",ERR,ERROR,*998)
      ELSE
        ALLOCATE(CONSTRAINT_CONDITION%CONSTRAINT_EQUATIONS,STAT=ERR)
        IF(ERR/=0) CALL FLAG_ERROR("Could not allocate constraint equations.",ERR,ERROR,*999)
        CONSTRAINT_CONDITION%CONSTRAINT_EQUATIONS%CONSTRAINT_CONDITION=>CONSTRAINT_CONDITION
        CONSTRAINT_CONDITION%CONSTRAINT_EQUATIONS%LINEARITY=CONSTRAINT_CONDITION_LINEAR
        CONSTRAINT_CONDITION%CONSTRAINT_EQUATIONS%TIME_DEPENDENCE=CONSTRAINT_CONDITION_STATIC
        CONSTRAINT_CONDITION%CONSTRAINT_EQUATIONS%OUTPUT_TYPE=CONSTRAINT_EQUATIONS_NO_OUTPUT
        CONSTRAINT_CONDITION%CONSTRAINT_EQUATIONS%SPARSITY_TYPE=CONSTRAINT_EQUATIONS_SPARSE_MATRICES
        NULLIFY(CONSTRAINT_CONDITION%CONSTRAINT_EQUATIONS%INTERPOLATION)
        NULLIFY(CONSTRAINT_CONDITION%CONSTRAINT_EQUATIONS%CONSTRAINT_MAPPING)
        NULLIFY(CONSTRAINT_CONDITION%CONSTRAINT_EQUATIONS%CONSTRAINT_MATRICES)
        CONSTRAINT_CONDITION%CONSTRAINT_EQUATIONS%CONSTRAINT_EQUATIONS_FINISHED=.FALSE.
        CALL CONSTRAINT_EQUATIONS_INTERPOLATION_INITIALISE(CONSTRAINT_CONDITION%CONSTRAINT_EQUATIONS,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Constraint condition is not associated.",ERR,ERROR,*998)
    ENDIF
       
    CALL EXITS("CONSTRAINT_EQUATIONS_INITIALISE")
    RETURN
999 CALL CONSTRAINT_EQUATIONS_FINALISE(CONSTRAINT_CONDITION%CONSTRAINT_EQUATIONS,DUMMY_ERR,DUMMY_ERROR,*998)
998 CALL ERRORS("CONSTRAINT_EQUATIONS_INITIALISE",ERR,ERROR)
    CALL EXITS("CONSTRAINT_EQUATIONS_INITIALISE")
    RETURN 1
    
  END SUBROUTINE CONSTRAINT_EQUATIONS_INITIALISE
  
  !
  !================================================================================================================================
  !
  
  !>Finalises the interpolation information for constraint equations and deallocates all memory
  SUBROUTINE CONSTRAINT_EQUATIONS_INTERPOLATION_FINALISE(CONSTRAINT_EQUATIONS_INTERPOLATION,ERR,ERROR,*)

    !Argument variables
    TYPE(CONSTRAINT_EQUATIONS_INTERPOLATION_TYPE), POINTER :: CONSTRAINT_EQUATIONS_INTERPOLATION !<A pointer to the constraint equations interpolation to finalise
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables

    CALL ENTERS("CONSTRAINT_EQUATIONS_INTERPOLATION_FINALISE",ERR,ERROR,*999)

    IF(ASSOCIATED(CONSTRAINT_EQUATIONS_INTERPOLATION)) THEN
      CALL FIELD_INTERPOLATION_PARAMETERS_FINALISE(CONSTRAINT_EQUATIONS_INTERPOLATION%GEOMETRIC_INTERP_PARAMETERS,ERR,ERROR,*999)
      CALL FIELD_INTERPOLATION_PARAMETERS_FINALISE(CONSTRAINT_EQUATIONS_INTERPOLATION%DEPENDENT_INTERP_PARAMETERS,ERR,ERROR,*999)
      CALL FIELD_INTERPOLATION_PARAMETERS_FINALISE(CONSTRAINT_EQUATIONS_INTERPOLATION%LAGRANGE_INTERP_PARAMETERS,ERR,ERROR,*999)
      CALL FIELD_INTERPOLATION_PARAMETERS_FINALISE(CONSTRAINT_EQUATIONS_INTERPOLATION%PENALTY_INTERP_PARAMETERS,ERR,ERROR,*999)
      CALL FIELD_INTERPOLATED_POINTS_FINALISE(CONSTRAINT_EQUATIONS_INTERPOLATION%GEOMETRIC_INTERP_POINT,ERR,ERROR,*999)
      CALL FIELD_INTERPOLATED_POINTS_FINALISE(CONSTRAINT_EQUATIONS_INTERPOLATION%DEPENDENT_INTERP_POINT,ERR,ERROR,*999)
      CALL FIELD_INTERPOLATED_POINTS_FINALISE(CONSTRAINT_EQUATIONS_INTERPOLATION%LAGRANGE_INTERP_POINT,ERR,ERROR,*999)
      CALL FIELD_INTERPOLATED_POINTS_FINALISE(CONSTRAINT_EQUATIONS_INTERPOLATION%PENALTY_INTERP_POINT,ERR,ERROR,*999)
      CALL Field_InterpolatedPointsMetricsFinalise(CONSTRAINT_EQUATIONS_INTERPOLATION% &
        & DEPENDENT_INTERP_POINT_METRICS,ERR,ERROR,*999)
      CALL Field_InterpolatedPointsMetricsFinalise(CONSTRAINT_EQUATIONS_INTERPOLATION% &
        & GEOMETRIC_INTERP_POINT_METRICS,ERR,ERROR,*999)
      DEALLOCATE(CONSTRAINT_EQUATIONS_INTERPOLATION)
    ENDIF
       
    CALL EXITS("CONSTRAINT_EQUATIONS_INTERPOLATION_FINALISE")
    RETURN
999 CALL ERRORS("CONSTRAINT_EQUATIONS_INTERPOLATION_FINALISE",ERR,ERROR)
    CALL EXITS("CONSTRAINT_EQUATIONS_INTERPOLATION_FINALISE")
    RETURN 1
  END SUBROUTINE CONSTRAINT_EQUATIONS_INTERPOLATION_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialises the interpolation information for constraint equations
  SUBROUTINE CONSTRAINT_EQUATIONS_INTERPOLATION_INITIALISE(CONSTRAINT_EQUATIONS,ERR,ERROR,*)

    !Argument variables
    TYPE(CONSTRAINT_EQUATIONS_TYPE), POINTER :: CONSTRAINT_EQUATIONS !<The pointer to the constraint equations to initialise the interpolation for
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DUMMY_ERR
    TYPE(CONSTRAINT_CONDITION_TYPE), POINTER :: CONSTRAINT_CONDITION
    TYPE(VARYING_STRING) :: DUMMY_ERROR
    
    CALL ENTERS("CONSTRAINT_EQUATIONS_INTERPOLATION_INITIALISE",ERR,ERROR,*998)

    IF(ASSOCIATED(CONSTRAINT_EQUATIONS)) THEN
      CONSTRAINT_CONDITION=>CONSTRAINT_EQUATIONS%CONSTRAINT_CONDITION
      IF(ASSOCIATED(CONSTRAINT_CONDITION)) THEN
        IF(ASSOCIATED(CONSTRAINT_EQUATIONS%INTERPOLATION)) THEN
          CALL FLAG_ERROR("Interpolation is already associated for these constraint equations.",ERR,ERROR,*998)
        ELSE
          ALLOCATE(CONSTRAINT_EQUATIONS%INTERPOLATION,STAT=ERR)
          IF(ERR/=0) CALL FLAG_ERROR("Could not allocate constraint equations interpolation",ERR,ERROR,*999)
          CONSTRAINT_EQUATIONS%INTERPOLATION%CONSTRAINT_EQUATIONS=>CONSTRAINT_EQUATIONS
          NULLIFY(CONSTRAINT_EQUATIONS%INTERPOLATION%GEOMETRIC_INTERP_PARAMETERS)
          NULLIFY(CONSTRAINT_EQUATIONS%INTERPOLATION%DEPENDENT_INTERP_PARAMETERS)
          NULLIFY(CONSTRAINT_EQUATIONS%INTERPOLATION%LAGRANGE_INTERP_PARAMETERS)
          NULLIFY(CONSTRAINT_EQUATIONS%INTERPOLATION%PENALTY_INTERP_PARAMETERS)
          NULLIFY(CONSTRAINT_EQUATIONS%INTERPOLATION%GEOMETRIC_INTERP_POINT)
          NULLIFY(CONSTRAINT_EQUATIONS%INTERPOLATION%DEPENDENT_INTERP_POINT)
          NULLIFY(CONSTRAINT_EQUATIONS%INTERPOLATION%LAGRANGE_INTERP_POINT)
          NULLIFY(CONSTRAINT_EQUATIONS%INTERPOLATION%PENALTY_INTERP_POINT)
          NULLIFY(CONSTRAINT_EQUATIONS%INTERPOLATION%DEPENDENT_INTERP_POINT_METRICS)
          NULLIFY(CONSTRAINT_EQUATIONS%INTERPOLATION%GEOMETRIC_INTERP_POINT_METRICS)
          
          CONSTRAINT_EQUATIONS%INTERPOLATION%GEOMETRIC_FIELD=>CONSTRAINT_CONDITION%GEOMETRY%GEOMETRIC_FIELD
          CONSTRAINT_EQUATIONS%INTERPOLATION%DEPENDENT_FIELD=>CONSTRAINT_CONDITION%DEPENDENT%DEPENDENT_FIELD
          CONSTRAINT_EQUATIONS%INTERPOLATION%LAGRANGE_FIELD=>CONSTRAINT_CONDITION%LAGRANGE%LAGRANGE_FIELD
          IF(ASSOCIATED(CONSTRAINT_CONDITION%PENALTY)) THEN
            CONSTRAINT_EQUATIONS%INTERPOLATION%PENALTY_FIELD=>CONSTRAINT_CONDITION%PENALTY%PENALTY_FIELD
          ELSE
            NULLIFY(CONSTRAINT_EQUATIONS%INTERPOLATION%PENALTY_FIELD)
          ENDIF

          CALL FIELD_INTERPOLATION_PARAMETERS_INITIALISE(CONSTRAINT_EQUATIONS%INTERPOLATION%GEOMETRIC_FIELD, &
            & CONSTRAINT_EQUATIONS%INTERPOLATION%GEOMETRIC_INTERP_PARAMETERS,ERR,ERROR,*999)
          CALL FIELD_INTERPOLATED_POINTS_INITIALISE(CONSTRAINT_EQUATIONS%INTERPOLATION%GEOMETRIC_INTERP_PARAMETERS, &
            & CONSTRAINT_EQUATIONS%INTERPOLATION%GEOMETRIC_INTERP_POINT,ERR,ERROR,*999)
          CALL Field_InterpolatedPointsMetricsInitialise(CONSTRAINT_EQUATIONS%INTERPOLATION%GEOMETRIC_INTERP_POINT, &
            & CONSTRAINT_EQUATIONS%INTERPOLATION%GEOMETRIC_INTERP_POINT_METRICS,ERR,ERROR,*999)
          CALL FIELD_INTERPOLATION_PARAMETERS_INITIALISE(CONSTRAINT_EQUATIONS%INTERPOLATION%DEPENDENT_FIELD, &
            & CONSTRAINT_EQUATIONS%INTERPOLATION%DEPENDENT_INTERP_PARAMETERS,ERR,ERROR,*999)
          CALL FIELD_INTERPOLATED_POINTS_INITIALISE(CONSTRAINT_EQUATIONS%INTERPOLATION%DEPENDENT_INTERP_PARAMETERS, &
            & CONSTRAINT_EQUATIONS%INTERPOLATION%DEPENDENT_INTERP_POINT,ERR,ERROR,*999)
          IF(CONSTRAINT_EQUATIONS%INTERPOLATION%DEPENDENT_FIELD%TYPE==FIELD_GEOMETRIC_TYPE.OR. &
            & CONSTRAINT_EQUATIONS%INTERPOLATION%DEPENDENT_FIELD%TYPE==FIELD_GEOMETRIC_GENERAL_TYPE) THEN
            CALL Field_InterpolatedPointsMetricsInitialise(CONSTRAINT_EQUATIONS%INTERPOLATION%DEPENDENT_INTERP_POINT, &
              & CONSTRAINT_EQUATIONS%INTERPOLATION%DEPENDENT_INTERP_POINT_METRICS,ERR,ERROR,*999)
          ENDIF
          CALL FIELD_INTERPOLATION_PARAMETERS_INITIALISE(CONSTRAINT_EQUATIONS%INTERPOLATION%LAGRANGE_FIELD, &
            & CONSTRAINT_EQUATIONS%INTERPOLATION%LAGRANGE_INTERP_PARAMETERS,ERR,ERROR,*999)
          CALL FIELD_INTERPOLATED_POINTS_INITIALISE(CONSTRAINT_EQUATIONS%INTERPOLATION%LAGRANGE_INTERP_PARAMETERS, &
            & CONSTRAINT_EQUATIONS%INTERPOLATION%LAGRANGE_INTERP_POINT,ERR,ERROR,*999)
          IF(ASSOCIATED(CONSTRAINT_EQUATIONS%INTERPOLATION%PENALTY_FIELD)) THEN
            CALL FIELD_INTERPOLATION_PARAMETERS_INITIALISE(CONSTRAINT_EQUATIONS%INTERPOLATION%PENALTY_FIELD, &
              & CONSTRAINT_EQUATIONS%INTERPOLATION%PENALTY_INTERP_PARAMETERS,ERR,ERROR,*999)
            CALL FIELD_INTERPOLATED_POINTS_INITIALISE(CONSTRAINT_EQUATIONS%INTERPOLATION%PENALTY_INTERP_PARAMETERS, &
              & CONSTRAINT_EQUATIONS%INTERPOLATION%PENALTY_INTERP_POINT,ERR,ERROR,*999)
          ENDIF
        ENDIF
      ELSE
        CALL FLAG_ERROR("Constraint equations constraint condition is not associated",ERR,ERROR,*998)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Constraint equations is not associated",ERR,ERROR,*998)
    ENDIF
       
    CALL EXITS("CONSTRAINT_EQUATIONS_INTERPOLATION_INITIALISE")
    RETURN
999 CALL CONSTRAINT_EQUATIONS_INTERPOLATION_FINALISE(CONSTRAINT_EQUATIONS%INTERPOLATION,DUMMY_ERR,DUMMY_ERROR,*998)
998 CALL ERRORS("CONSTRAINT_EQUATIONS_INTERPOLATION_INITIALISE",ERR,ERROR)
    CALL EXITS("CONSTRAINT_EQUATIONS_INTERPOLATION_INITIALISE")
    RETURN 1
  END SUBROUTINE CONSTRAINT_EQUATIONS_INTERPOLATION_INITIALISE

  !
  !================================================================================================================================
  !

  !>Gets the linearity type for constraint equations.
  SUBROUTINE CONSTRAINT_EQUATIONS_LINEARITY_TYPE_GET(CONSTRAINT_EQUATIONS,LINEARITY_TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(CONSTRAINT_EQUATIONS_TYPE), POINTER :: CONSTRAINT_EQUATIONS !<A pointer to the constraint equations to get the linearity for
    INTEGER(INTG), INTENT(OUT) :: LINEARITY_TYPE !<On exit, the linearity type of the constraint equations. \see CONSTRAINT_CONDITION_CONSTANTS_LinearityTypes,CONSTRAINT_CONDITION_CONSTANTS
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
 
    CALL ENTERS("CONSTRAINT_EQUATIONS_LINEARITY_TYPE_GET",ERR,ERROR,*999)

    IF(ASSOCIATED(CONSTRAINT_EQUATIONS)) THEN
      IF(CONSTRAINT_EQUATIONS%CONSTRAINT_EQUATIONS_FINISHED) THEN
        LINEARITY_TYPE=CONSTRAINT_EQUATIONS%LINEARITY
      ELSE
        CALL FLAG_ERROR("Constraint equations has not been finished.",ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Constraint equations is not associated.",ERR,ERROR,*999)
    ENDIF
       
    CALL EXITS("CONSTRAINT_EQUATIONS_LINEARITY_TYPE_GET")
    RETURN
999 CALL ERRORS("CONSTRAINT_EQUATIONS_LINEARITY_TYPE_GET",ERR,ERROR)
    CALL EXITS("CONSTRAINT_EQUATIONS_LINEARITY_TYPE_GET")
    RETURN 1
  END SUBROUTINE CONSTRAINT_EQUATIONS_LINEARITY_TYPE_GET
  
  !
  !================================================================================================================================
  !

  !>Sets/changes the linearity type for constraint equations.
  SUBROUTINE CONSTRAINT_EQUATIONS_LINEARITY_TYPE_SET(CONSTRAINT_EQUATIONS,LINEARITY_TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(CONSTRAINT_EQUATIONS_TYPE), POINTER :: CONSTRAINT_EQUATIONS !<A pointer to the constraint equations to set the linearity for
    INTEGER(INTG), INTENT(IN) :: LINEARITY_TYPE !<The linearity type to set \see CONSTRAINT_CONDITION_CONSTANTS_LinearityTypes,CONSTRAINT_CONDITION_CONSTANTS
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR
 
    CALL ENTERS("CONSTRAINT_EQUATIONS_LINEARITY_TYPE_SET",ERR,ERROR,*999)

    IF(ASSOCIATED(CONSTRAINT_EQUATIONS)) THEN
      IF(CONSTRAINT_EQUATIONS%CONSTRAINT_EQUATIONS_FINISHED) THEN
        CALL FLAG_ERROR("Constraint equations has already been finished.",ERR,ERROR,*999)
      ELSE
        SELECT CASE(LINEARITY_TYPE)
        CASE(CONSTRAINT_CONDITION_LINEAR)
          CONSTRAINT_EQUATIONS%LINEARITY=CONSTRAINT_CONDITION_LINEAR
        CASE(CONSTRAINT_CONDITION_NONLINEAR)
          CONSTRAINT_EQUATIONS%LINEARITY=CONSTRAINT_CONDITION_NONLINEAR
        CASE(CONSTRAINT_CONDITION_NONLINEAR_BCS)
          CONSTRAINT_EQUATIONS%LINEARITY=CONSTRAINT_CONDITION_NONLINEAR_BCS
        CASE DEFAULT
          LOCAL_ERROR="The specified linearity type of "//TRIM(NUMBER_TO_VSTRING(LINEARITY_TYPE,"*",ERR,ERROR))// &
            & " is invalid."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        END SELECT
      ENDIF
    ELSE
      CALL FLAG_ERROR("Constraint equations is not associated.",ERR,ERROR,*999)
    ENDIF
       
    CALL EXITS("CONSTRAINT_EQUATIONS_LINEARITY_TYPE_SET")
    RETURN
999 CALL ERRORS("CONSTRAINT_EQUATIONS_LINEARITY_TYPE_SET",ERR,ERROR)
    CALL EXITS("CONSTRAINT_EQUATIONS_LINEARITY_TYPE_SET")
    RETURN 1
  END SUBROUTINE CONSTRAINT_EQUATIONS_LINEARITY_TYPE_SET
  
  !
  !================================================================================================================================
  !

  !>Gets the output type for constraint equations.
  SUBROUTINE CONSTRAINT_EQUATIONS_OUTPUT_TYPE_GET(CONSTRAINT_EQUATIONS,OUTPUT_TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(CONSTRAINT_EQUATIONS_TYPE), POINTER :: CONSTRAINT_EQUATIONS !<A pointer to the constraint equations to get the output type for
    INTEGER(INTG), INTENT(OUT) :: OUTPUT_TYPE !<On exit, the output type of the constraint equations
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
 
    CALL ENTERS("CONSTRAINT_EQUATIONS_OUTPUT_TYPE_GET",ERR,ERROR,*999)

    IF(ASSOCIATED(CONSTRAINT_EQUATIONS)) THEN
      IF(CONSTRAINT_EQUATIONS%CONSTRAINT_EQUATIONS_FINISHED) THEN
        OUTPUT_TYPE=CONSTRAINT_EQUATIONS%OUTPUT_TYPE
      ELSE
        CALL FLAG_ERROR("Constraint equations has not been finished.",ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Constraint equations is not associated.",ERR,ERROR,*999)
    ENDIF
       
    CALL EXITS("CONSTRAINT_EQUATIONS_OUTPUT_TYPE_GET")
    RETURN
999 CALL ERRORS("CONSTRAINT_EQUATIONS_OUTPUT_TYPE_GET",ERR,ERROR)
    CALL EXITS("CONSTRAINT_EQUATIONS_OUTPUT_TYPE_GET")
    RETURN 1
  END SUBROUTINE CONSTRAINT_EQUATIONS_OUTPUT_TYPE_GET
  
  !
  !================================================================================================================================
  !

  !>Sets/changes the output type for the constraint equations.
  SUBROUTINE CONSTRAINT_EQUATIONS_OUTPUT_TYPE_SET(CONSTRAINT_EQUATIONS,OUTPUT_TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(CONSTRAINT_EQUATIONS_TYPE), POINTER :: CONSTRAINT_EQUATIONS !<A pointer to the constraint equations to set the output type for
    INTEGER(INTG), INTENT(IN) :: OUTPUT_TYPE !<The output type to set \see CONSTRAINT_EQUATIONS_ROUTINES_OutputTypes,CONSTRAINT_EQUATIONS_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR
 
    CALL ENTERS("CONSTRAINT_EQUATIONS_OUTPUT_TYPE_SET",ERR,ERROR,*999)

    IF(ASSOCIATED(CONSTRAINT_EQUATIONS)) THEN
      IF(CONSTRAINT_EQUATIONS%CONSTRAINT_EQUATIONS_FINISHED) THEN
        CALL FLAG_ERROR("Constraint equations has already been finished.",ERR,ERROR,*999)
      ELSE
        SELECT CASE(OUTPUT_TYPE)
        CASE(CONSTRAINT_EQUATIONS_NO_OUTPUT)
          CONSTRAINT_EQUATIONS%OUTPUT_TYPE=CONSTRAINT_EQUATIONS_NO_OUTPUT
        CASE(CONSTRAINT_EQUATIONS_TIMING_OUTPUT)
          CONSTRAINT_EQUATIONS%OUTPUT_TYPE=CONSTRAINT_EQUATIONS_TIMING_OUTPUT
        CASE(CONSTRAINT_MATRIX_OUTPUT)
          CONSTRAINT_EQUATIONS%OUTPUT_TYPE=CONSTRAINT_MATRIX_OUTPUT
        CASE(CONSTRAINT_EQUATIONS_ELEMENT_MATRIX_OUTPUT)
          CONSTRAINT_EQUATIONS%OUTPUT_TYPE=CONSTRAINT_EQUATIONS_ELEMENT_MATRIX_OUTPUT
        CASE DEFAULT
          LOCAL_ERROR="The specified output type of "//TRIM(NUMBER_TO_VSTRING(OUTPUT_TYPE,"*",ERR,ERROR))//" is invalid"
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        END SELECT
      ENDIF
    ELSE
      CALL FLAG_ERROR("Constraint equations is not associated.",ERR,ERROR,*999)
    ENDIF
       
    CALL EXITS("CONSTRAINT_EQUATIONS_OUTPUT_TYPE_SET")
    RETURN
999 CALL ERRORS("CONSTRAINT_EQUATIONS_OUTPUT_TYPE_SET",ERR,ERROR)
    CALL EXITS("CONSTRAINT_EQUATIONS_OUTPUT_TYPE_SET")
    RETURN 1
    
  END SUBROUTINE CONSTRAINT_EQUATIONS_OUTPUT_TYPE_SET

  !
  !================================================================================================================================
  !

  !>Gets the sparsity type for constraint equations.
  SUBROUTINE CONSTRAINT_EQUATIONS_SPARSITY_TYPE_GET(CONSTRAINT_EQUATIONS,SPARSITY_TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(CONSTRAINT_EQUATIONS_TYPE), POINTER :: CONSTRAINT_EQUATIONS !<A pointer to the constraint equations to get the output type for
    INTEGER(INTG), INTENT(OUT) :: SPARSITY_TYPE !<On exit, the sparsity type of the constraint equations
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
 
    CALL ENTERS("CONSTRAINT_EQUATIONS_SPARSITY_TYPE_GET",ERR,ERROR,*999)

    IF(ASSOCIATED(CONSTRAINT_EQUATIONS)) THEN
      IF(CONSTRAINT_EQUATIONS%CONSTRAINT_EQUATIONS_FINISHED) THEN
        SPARSITY_TYPE=CONSTRAINT_EQUATIONS%SPARSITY_TYPE
      ELSE
        CALL FLAG_ERROR("Constraint equations has not been finished.",ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Constraint equations is not associated.",ERR,ERROR,*999)
    ENDIF
       
    CALL EXITS("CONSTRAINT_EQUATIONS_SPARSITY_TYPE_GET")
    RETURN
999 CALL ERRORS("CONSTRAINT_EQUATIONS_SPARSITY_TYPE_GET",ERR,ERROR)
    CALL EXITS("CONSTRAINT_EQUATIONS_SPARSITY_TYPE_GET")
    RETURN 1
  END SUBROUTINE CONSTRAINT_EQUATIONS_SPARSITY_TYPE_GET
  
  !
  !================================================================================================================================
  !

  !>Sets/changes the sparsity type for the constraint equations.
  SUBROUTINE CONSTRAINT_EQUATIONS_SPARSITY_TYPE_SET(CONSTRAINT_EQUATIONS,SPARSITY_TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(CONSTRAINT_EQUATIONS_TYPE), POINTER :: CONSTRAINT_EQUATIONS !<A pointer to the constraint equations to set the sparsity type for
    INTEGER(INTG), INTENT(IN) :: SPARSITY_TYPE !<The sparsity type to set \see CONSTRAINT_EQUATIONS_ROUTINES_SparsityTypes,CONSTRAINT_EQUATIONS_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR
 
    CALL ENTERS("CONSTRAINT_EQUATIONS_SPARSITY_TYPE_SET",ERR,ERROR,*999)

    IF(ASSOCIATED(CONSTRAINT_EQUATIONS)) THEN
      IF(CONSTRAINT_EQUATIONS%CONSTRAINT_EQUATIONS_FINISHED) THEN
        CALL FLAG_ERROR("Constraint equations has already been finished.",ERR,ERROR,*999)
      ELSE
        SELECT CASE(SPARSITY_TYPE)
        CASE(CONSTRAINT_EQUATIONS_SPARSE_MATRICES)
          CONSTRAINT_EQUATIONS%SPARSITY_TYPE=CONSTRAINT_EQUATIONS_SPARSE_MATRICES
        CASE(CONSTRAINT_EQUATIONS_FULL_MATRICES)
          CONSTRAINT_EQUATIONS%SPARSITY_TYPE=CONSTRAINT_EQUATIONS_FULL_MATRICES
        CASE DEFAULT
          LOCAL_ERROR="The specified sparsity type of "//TRIM(NUMBER_TO_VSTRING(SPARSITY_TYPE,"*",ERR,ERROR))// &
            & " is invalid."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        END SELECT
      ENDIF
    ELSE
      CALL FLAG_ERROR("Constraint equations is not associated.",ERR,ERROR,*999)
    ENDIF
       
    CALL EXITS("CONSTRAINT_EQUATIONS_SPARSITY_TYPE_SET")
    RETURN
999 CALL ERRORS("CONSTRAINT_EQUATIONS_SPARSITY_TYPE_SET",ERR,ERROR)
    CALL EXITS("CONSTRAINT_EQUATIONS_SPARSITY_TYPE_SET")
    RETURN 1
  END SUBROUTINE CONSTRAINT_EQUATIONS_SPARSITY_TYPE_SET
  
  !
  !================================================================================================================================
  !

  !>Gets the time dependence type for constraint equations.
  SUBROUTINE CONSTRAINT_EQUATIONS_TIME_DEPENDENCE_TYPE_GET(CONSTRAINT_EQUATIONS,TIME_DEPENDENCE_TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(CONSTRAINT_EQUATIONS_TYPE), POINTER :: CONSTRAINT_EQUATIONS !<A pointer to the constraint equations to get the output type for
    INTEGER(INTG), INTENT(OUT) :: TIME_DEPENDENCE_TYPE !<On exit, the time dependence type of the constraint equations
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
 
    CALL ENTERS("CONSTRAINT_EQUATIONS_TIME_DEPENDENCE_TYPE_GET",ERR,ERROR,*999)

    IF(ASSOCIATED(CONSTRAINT_EQUATIONS)) THEN
      IF(CONSTRAINT_EQUATIONS%CONSTRAINT_EQUATIONS_FINISHED) THEN
        TIME_DEPENDENCE_TYPE=CONSTRAINT_EQUATIONS%TIME_DEPENDENCE
      ELSE
        CALL FLAG_ERROR("Constraint equations has not been finished.",ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Constraint equations is not associated.",ERR,ERROR,*999)
    ENDIF
       
    CALL EXITS("CONSTRAINT_EQUATIONS_TIME_DEPENDENCE_TYPE_GET")
    RETURN
999 CALL ERRORS("CONSTRAINT_EQUATIONS_TIME_DEPENDENCE_TYPE_GET",ERR,ERROR)
    CALL EXITS("CONSTRAINT_EQUATIONS_TIME_DEPENDENCE_TYPE_GET")
    RETURN 1
  END SUBROUTINE CONSTRAINT_EQUATIONS_TIME_DEPENDENCE_TYPE_GET
  
  !
  !================================================================================================================================
  !

  !>Sets/changes the time dependence type for constraint equations.
  SUBROUTINE CONSTRAINT_EQUATIONS_TIME_DEPENDENCE_TYPE_SET(CONSTRAINT_EQUATIONS,TIME_DEPENDENCE_TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(CONSTRAINT_EQUATIONS_TYPE), POINTER :: CONSTRAINT_EQUATIONS !<A pointer to the constraint equations to set the linearity for
    INTEGER(INTG), INTENT(IN) :: TIME_DEPENDENCE_TYPE !<The time dependence type to set \see CONSTRAINT_EQUATIONS_ROUTINES_TimeDependenceTypes,CONSTRAINT_EQUATIONS_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR
 
    CALL ENTERS("CONSTRAINT_EQUATIONS_TIME_DEPENDENCE_TYPE_SET",ERR,ERROR,*999)

    IF(ASSOCIATED(CONSTRAINT_EQUATIONS)) THEN
      IF(CONSTRAINT_EQUATIONS%CONSTRAINT_EQUATIONS_FINISHED) THEN
        CALL FLAG_ERROR("Constraint equations has already been finished.",ERR,ERROR,*999)
      ELSE
        SELECT CASE(TIME_DEPENDENCE_TYPE)
        CASE(CONSTRAINT_CONDITION_STATIC)
          CONSTRAINT_EQUATIONS%TIME_DEPENDENCE=CONSTRAINT_CONDITION_STATIC
        CASE(CONSTRAINT_CONDITION_FIRST_ORDER_DYNAMIC)
          CONSTRAINT_EQUATIONS%TIME_DEPENDENCE=CONSTRAINT_CONDITION_FIRST_ORDER_DYNAMIC
        CASE(CONSTRAINT_CONDITION_SECOND_ORDER_DYNAMIC)
          CONSTRAINT_EQUATIONS%TIME_DEPENDENCE=CONSTRAINT_CONDITION_SECOND_ORDER_DYNAMIC
        CASE DEFAULT
          LOCAL_ERROR="The specified time dependence type of "//TRIM(NUMBER_TO_VSTRING(TIME_DEPENDENCE_TYPE,"*",ERR,ERROR))// &
            & " is invalid."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        END SELECT
      ENDIF
    ELSE
      CALL FLAG_ERROR("Constraint equations is not associated.",ERR,ERROR,*999)
    ENDIF
       
    CALL EXITS("CONSTRAINT_EQUATIONS_TIME_DEPENDENCE_TYPE_SET")
    RETURN
999 CALL ERRORS("CONSTRAINT_EQUATIONS_TIME_DEPENDENCE_TYPE_SET",ERR,ERROR)
    CALL EXITS("CONSTRAINT_EQUATIONS_TIME_DEPENDENCE_TYPE_SET")
    RETURN 1
  END SUBROUTINE CONSTRAINT_EQUATIONS_TIME_DEPENDENCE_TYPE_SET

  !
  !================================================================================================================================
  !

  !>Gets the constraint equations for an constraint condition.
  SUBROUTINE CONSTRAINT_CONDITION_CONSTRAINT_EQUATIONS_GET(CONSTRAINT_CONDITION,CONSTRAINT_EQUATIONS,ERR,ERROR,*)

    !Argument variables
    TYPE(CONSTRAINT_CONDITION_TYPE), POINTER :: CONSTRAINT_CONDITION !<A pointer to the constraint condition to get the constraint equations for
    TYPE(CONSTRAINT_EQUATIONS_TYPE), POINTER :: CONSTRAINT_EQUATIONS !<On exit, a pointer to the constraint equations in the specified constraint condition. Must not be associated on entry
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
 
    CALL ENTERS("CONSTRAINT_CONDITION_CONSTRAINT_EQUATIONS_GET",ERR,ERROR,*999)

    IF(ASSOCIATED(CONSTRAINT_CONDITION)) THEN
      IF(CONSTRAINT_CONDITION%CONSTRAINT_CONDITION_FINISHED) THEN
        IF(ASSOCIATED(CONSTRAINT_EQUATIONS)) THEN
          CALL FLAG_ERROR("Constraint equations is already associated.",ERR,ERROR,*999)
        ELSE
          CONSTRAINT_EQUATIONS=>CONSTRAINT_CONDITION%CONSTRAINT_EQUATIONS
          IF(.NOT.ASSOCIATED(CONSTRAINT_EQUATIONS)) &
            & CALL FLAG_ERROR("Constraint condition constraint equations is not associated.",ERR,ERROR,*999)
        ENDIF
      ELSE
        CALL FLAG_ERROR("Constraint condition has not been finished.",ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Constraint condition is not associated.",ERR,ERROR,*999)
    ENDIF
       
    CALL EXITS("CONSTRAINT_CONDITION_CONSTRAINT_EQUATIONS_GET")
    RETURN
999 CALL ERRORS("CONSTRAINT_CONDITION_CONSTRAINT_EQUATIONS_GET",ERR,ERROR)
    CALL EXITS("CONSTRAINT_CONDITION_CONSTRAINT_EQUATIONS_GET")
    RETURN 1
    
  END SUBROUTINE CONSTRAINT_CONDITION_CONSTRAINT_EQUATIONS_GET

  !
  !================================================================================================================================
  !

  !>Get the number of linear matrices in the constraint equations
  SUBROUTINE ConstraintEquations_NumberOfLinearMatricesGet(constraintEquations,numberOfMatrices,err,error,*)

    !Argument variables
    TYPE(CONSTRAINT_EQUATIONS_TYPE), POINTER, INTENT(IN) :: constraintEquations !<The constraint equations to get the number of linear matrices for
    INTEGER(INTG), INTENT(OUT) :: numberOfMatrices !<On return, the number of linear matrices
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error message
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    TYPE(CONSTRAINT_MATRICES_TYPE), POINTER :: constraintMatrices
    TYPE(CONSTRAINT_MATRICES_LINEAR_TYPE), POINTER :: linearMatrices

    CALL Enters("ConstraintEquations_NumberOfLinearMatricesGet",err,error,*999)

    IF(ASSOCIATED(constraintEquations)) THEN
      constraintMatrices=>constraintEquations%constraint_matrices
      IF(ASSOCIATED(constraintMatrices)) THEN
        linearMatrices=>constraintMatrices%linear_matrices
        IF(ASSOCIATED(linearMatrices)) THEN
          numberOfMatrices=linearMatrices%number_of_linear_matrices
        ELSE
          numberOfMatrices=0
        END IF
      ELSE
        CALL FlagError("The constraint equations matrices are not associated.",err,error,*999)
      END IF
    ELSE
      CALL FlagError("The constraint equations constraint equations are not associated.",err,error,*999)
    END IF

    CALL Exits("ConstraintEquations_NumberOfLinearMatricesGet")
    RETURN
999 CALL Errors("ConstraintEquations_NumberOfLinearMatricesGet",err,error)
    CALL Exits("ConstraintEquations_NumberOfLinearMatricesGet")
    RETURN 1

  END SUBROUTINE ConstraintEquations_NumberOfLinearMatricesGet

  !
  !================================================================================================================================
  !

  !>Get the number of Jacobian matrices in the constraint equations
  SUBROUTINE ConstraintEquations_NumberOfJacobianMatricesGet(constraintEquations,numberOfMatrices,err,error,*)

    !Argument variables
    TYPE(CONSTRAINT_EQUATIONS_TYPE), POINTER, INTENT(IN) :: constraintEquations !<The constraint equations to get the number of Jacobian matrices for
    INTEGER(INTG), INTENT(OUT) :: numberOfMatrices !<On return, the number of Jacobian matrices
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error message
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    TYPE(CONSTRAINT_MATRICES_TYPE), POINTER :: constraintMatrices
    TYPE(CONSTRAINT_MATRICES_NONLINEAR_TYPE), POINTER :: nonlinearMatrices

    CALL Enters("ConstraintEquations_NumberOfJacobianMatricesGet",err,error,*999)

    IF(ASSOCIATED(constraintEquations)) THEN
      constraintMatrices=>constraintEquations%constraint_matrices
      IF(ASSOCIATED(constraintMatrices)) THEN
        nonlinearMatrices=>constraintMatrices%nonlinear_matrices
        IF(ASSOCIATED(nonlinearMatrices)) THEN
          numberOfMatrices=nonlinearMatrices%number_of_jacobians
        ELSE
          numberOfMatrices=0
        END IF
      ELSE
        CALL FlagError("The constraint equations matrices are not associated.",err,error,*999)
      END IF
    ELSE
      CALL FlagError("The constraint equations are not associated.",err,error,*999)
    END IF

    CALL Exits("ConstraintEquations_NumberOfJacobianMatricesGet")
    RETURN
999 CALL Errors("ConstraintEquations_NumberOfJacobianMatricesGet",err,error)
    CALL Exits("ConstraintEquations_NumberOfJacobianMatricesGet")
    RETURN 1

  END SUBROUTINE ConstraintEquations_NumberOfJacobianMatricesGet

  !
  !================================================================================================================================
  !

  !>Get the number of dynamic matrices in the constraint equations
  SUBROUTINE ConstraintEquations_NumberOfDynamicMatricesGet(constraintEquations,numberOfMatrices,err,error,*)

    !Argument variables
    TYPE(CONSTRAINT_EQUATIONS_TYPE), POINTER, INTENT(IN) :: constraintEquations !<The constraint equations to get the number of dynamic matrices for
    INTEGER(INTG), INTENT(OUT) :: numberOfMatrices !<On return, the number of dynamic matrices
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error message
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    TYPE(CONSTRAINT_MATRICES_TYPE), POINTER :: constraintMatrices
    TYPE(CONSTRAINT_MATRICES_DYNAMIC_TYPE), POINTER :: dynamicMatrices

    CALL Enters("ConstraintEquations_NumberOfDynamicMatricesGet",err,error,*999)

    IF(ASSOCIATED(constraintEquations)) THEN
      constraintMatrices=>constraintEquations%constraint_matrices
      IF(ASSOCIATED(constraintMatrices)) THEN
        dynamicMatrices=>constraintMatrices%dynamic_matrices
        IF(ASSOCIATED(dynamicMatrices)) THEN
          numberOfMatrices=dynamicMatrices%number_of_dynamic_matrices
        ELSE
          numberOfMatrices=0
        END IF
      ELSE
        CALL FlagError("The constraint equations matrices are not associated.",err,error,*999)
      END IF
    ELSE
      CALL FlagError("The constraint equations are not associated.",err,error,*999)
    END IF

    CALL Exits("ConstraintEquations_NumberOfDynamicMatricesGet")
    RETURN
999 CALL Errors("ConstraintEquations_NumberOfDynamicMatricesGet",err,error)
    CALL Exits("ConstraintEquations_NumberOfDynamicMatricesGet")
    RETURN 1

  END SUBROUTINE ConstraintEquations_NumberOfDynamicMatricesGet

  !
  !================================================================================================================================
  !

  !>Get a linear constraint equations matrix from constraint equations
  SUBROUTINE ConstraintEquations_LinearMatrixGet(constraintEquations,matrixIndex,matrix,err,error,*)

    !Argument variables
    TYPE(CONSTRAINT_EQUATIONS_TYPE), POINTER, INTENT(IN) :: constraintEquations !<The constraint equations to get the linear matrix for
    INTEGER(INTG), INTENT(IN) :: matrixIndex !<The index of the linear matrix to get
    TYPE(DISTRIBUTED_MATRIX_TYPE), POINTER, INTENT(INOUT) :: matrix !<On return, the linear matrix requested
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error message
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    TYPE(CONSTRAINT_MATRIX_TYPE), POINTER :: constraintMatrix
    TYPE(CONSTRAINT_MATRICES_TYPE), POINTER :: constraintMatrices
    TYPE(CONSTRAINT_MATRICES_LINEAR_TYPE), POINTER :: linearMatrices

    CALL Enters("ConstraintEquations_LinearMatrixGet",err,error,*999)

    IF(ASSOCIATED(constraintEquations)) THEN
      constraintMatrices=>constraintEquations%constraint_matrices
      IF(ASSOCIATED(constraintMatrices)) THEN
        linearMatrices=>constraintMatrices%linear_matrices
        IF(ASSOCIATED(linearMatrices)) THEN
          IF(matrixIndex>0.AND.matrixIndex<=linearMatrices%number_of_linear_matrices) THEN
            IF(.NOT.ASSOCIATED(matrix)) THEN
              constraintMatrix=>linearMatrices%matrices(matrixIndex)%ptr
              IF(ASSOCIATED(constraintMatrix)) THEN
                matrix=>constraintMatrix%matrix
              ELSE
                CALL FlagError("The constraint equations matrix is not associated.",err,error,*999)
              END IF
            ELSE
              CALL FlagError("The matrix is already associated.",err,error,*999)
            END IF
          ELSE
            CALL FlagError("Invalid matrix index. The matrix index must be greater than zero and less than or equal to "// &
              & TRIM(NumberToVstring(linearMatrices%number_of_linear_matrices,"*",err,error))//".",err,error,*999)
          END IF
        ELSE
          CALL FlagError("The constraint equations linear matrices are not associated.",err,error,*999)
        END IF
      ELSE
        CALL FlagError("The constraint equations matrices are not associated.",err,error,*999)
      END IF
    ELSE
      CALL FlagError("The constraint equations are not associated.",err,error,*999)
    END IF

    CALL Exits("ConstraintEquations_LinearMatrixGet")
    RETURN
999 CALL Errors("ConstraintEquations_LinearMatrixGet",err,error)
    CALL Exits("ConstraintEquations_LinearMatrixGet")
    RETURN 1

  END SUBROUTINE ConstraintEquations_LinearMatrixGet

  !
  !================================================================================================================================
  !

  !>Get a Jacobian matrix from constraint equations
  SUBROUTINE ConstraintEquations_JacobianMatrixGet(constraintEquations,matrixIndex,matrix,err,error,*)

    !Argument variables
    TYPE(CONSTRAINT_EQUATIONS_TYPE), POINTER, INTENT(IN) :: constraintEquations !<The constraint equations to get the Jacobian matrix for
    INTEGER(INTG), INTENT(IN) :: matrixIndex !<The index of the Jacobian matrix to get
    TYPE(DISTRIBUTED_MATRIX_TYPE), POINTER, INTENT(INOUT) :: matrix !<On return, the requested Jacobian matrix
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error message
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    TYPE(CONSTRAINT_MATRICES_TYPE), POINTER :: constraintMatrices
    TYPE(CONSTRAINT_MATRICES_NONLINEAR_TYPE), POINTER :: nonlinearMatrices
    TYPE(CONSTRAINT_JACOBIAN_TYPE), POINTER :: constraintJacobian

    CALL Enters("ConstraintEquations_JacobianMatrixGet",err,error,*999)

    IF(ASSOCIATED(constraintEquations)) THEN
      constraintMatrices=>constraintEquations%constraint_matrices
      IF(ASSOCIATED(constraintMatrices)) THEN
        nonLinearMatrices=>constraintMatrices%nonlinear_matrices
        IF(ASSOCIATED(nonLinearMatrices)) THEN
          IF(matrixIndex>0.AND.matrixIndex<=nonLinearMatrices%number_of_jacobians) THEN
            IF(.NOT.ASSOCIATED(matrix)) THEN
              constraintJacobian=>nonlinearMatrices%jacobians(matrixIndex)%ptr
              IF(ASSOCIATED(constraintJacobian)) THEN
                matrix=>constraintJacobian%jacobian
              ELSE
                CALL FlagError("The constraint Jacobian is not associated.",err,error,*999)
              END IF
            ELSE
              CALL FlagError("The matrix is already associated.",err,error,*999)
            END IF
          ELSE
            CALL FlagError("Invalid matrix index. The matrix index must be greater than zero and less than or equal to "// &
              & TRIM(NumberToVstring(nonlinearMatrices%number_of_jacobians,"*",err,error))//".",err,error,*999)
          END IF
        ELSE
          CALL FlagError("The constraint equations nonlinear matrices are not associated.",err,error,*999)
        END IF
      ELSE
        CALL FlagError("The constraint equations matrices are not associated.",err,error,*999)
      END IF
    ELSE
      CALL FlagError("The constraint equations are not associated.",err,error,*999)
    END IF

    CALL Exits("ConstraintEquations_JacobianMatrixGet")
    RETURN
999 CALL Errors("ConstraintEquations_JacobianMatrixGet",err,error)
    CALL Exits("ConstraintEquations_JacobianMatrixGet")
    RETURN 1

  END SUBROUTINE ConstraintEquations_JacobianMatrixGet

  !
  !================================================================================================================================
  !

  !>Get a dynamic constraint equations matrix from constraint equations using the dynamic matrix index
  SUBROUTINE ConstraintEquations_DynamicMatrixGet(constraintEquations,matrixIndex,matrix,err,error,*)

    !Argument variables
    TYPE(CONSTRAINT_EQUATIONS_TYPE), POINTER, INTENT(IN) :: constraintEquations !<The constraint equations to get the dynamic matrix for
    INTEGER(INTG), INTENT(IN) :: matrixIndex !<The number of the dynamic matrix to get
    TYPE(DISTRIBUTED_MATRIX_TYPE), POINTER, INTENT(INOUT) :: matrix !<On return, the requested dynamic matrix
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error message
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    TYPE(CONSTRAINT_MATRIX_TYPE), POINTER :: constraintMatrix
    TYPE(CONSTRAINT_MATRICES_TYPE), POINTER :: constraintMatrices
    TYPE(CONSTRAINT_MATRICES_DYNAMIC_TYPE), POINTER :: dynamicMatrices

    CALL Enters("ConstraintEquations_DynamicMatrixGet",err,error,*999)

    IF(ASSOCIATED(constraintEquations)) THEN
      constraintMatrices=>constraintEquations%constraint_matrices
      IF(ASSOCIATED(constraintMatrices)) THEN
        dynamicMatrices=>constraintMatrices%dynamic_matrices
        IF(ASSOCIATED(dynamicMatrices)) THEN
          IF(matrixIndex>0.AND.matrixIndex<=dynamicMatrices%number_of_dynamic_matrices) THEN
            IF(.NOT.ASSOCIATED(matrix)) THEN
              constraintMatrix=>dynamicMatrices%matrices(matrixIndex)%ptr
              IF(ASSOCIATED(constraintMatrix)) THEN
                matrix=>constraintMatrix%matrix
              ELSE
                CALL FlagError("The constraint equations matrix is not associated.",err,error,*999)
              END IF
            ELSE
              CALL FlagError("The matrix is already associated.",err,error,*999)
            END IF
          ELSE
            CALL FlagError("Invalid matrix index. The matrix index must be greater than zero and less than or equal to "// &
              & TRIM(NumberToVstring(dynamicMatrices%number_of_dynamic_matrices,"*",err,error))//".",err,error,*999)
          END IF
        ELSE
          CALL FlagError("The constraint equations dynamic matrices are not associated.",err,error,*999)
        END IF
      ELSE
        CALL FlagError("The constraint equations matrices are not associated.",err,error,*999)
      END IF
    ELSE
      CALL FlagError("The constraint equations are not associated.",err,error,*999)
    END IF

    CALL Exits("ConstraintEquations_DynamicMatrixGet")
    RETURN
999 CALL Errors("ConstraintEquations_DynamicMatrixGet",err,error)
    CALL Exits("ConstraintEquations_DynamicMatrixGet")
    RETURN 1

  END SUBROUTINE ConstraintEquations_DynamicMatrixGet

  !
  !================================================================================================================================
  !

  !>Get a dynamic constraint equations matrix from constraint equations using the dynamic matrix type
  SUBROUTINE ConstraintEquations_DynamicMatrixGetByType(constraintEquations,matrixType,matrix,err,error,*)

    !Argument variables
    TYPE(CONSTRAINT_EQUATIONS_TYPE), POINTER, INTENT(IN) :: constraintEquations !<The constraint equations to get the dynamic matrix for
    INTEGER(INTG), INTENT(IN) :: matrixType !<The type of the dynamic matrix to get. \see CONSTRAINT_CONDITION_CONSTANTS_DynamicMatrixTypes,CONSTRAINT_CONDITION_CONSTANTS
    TYPE(DISTRIBUTED_MATRIX_TYPE), POINTER, INTENT(INOUT) :: matrix !<On return, the requested dynamic matrix
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error message
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    INTEGER(INTG) :: matrixIndex
    TYPE(CONSTRAINT_MATRIX_TYPE), POINTER :: constraintMatrix
    TYPE(CONSTRAINT_MATRICES_TYPE), POINTER :: constraintMatrices
    TYPE(CONSTRAINT_MATRICES_DYNAMIC_TYPE), POINTER :: dynamicMatrices
    TYPE(CONSTRAINT_MAPPING_TYPE), POINTER :: constraintEquationsMapping
    TYPE(CONSTRAINT_MAPPING_DYNAMIC_TYPE), POINTER :: dynamicMapping

    CALL Enters("ConstraintEquations_DynamicMatrixGetByType",err,error,*999)

    !Check all pointer associations
    IF(ASSOCIATED(constraintEquations)) THEN
      constraintMatrices=>constraintEquations%constraint_matrices
      IF(ASSOCIATED(constraintMatrices)) THEN
        dynamicMatrices=>constraintMatrices%dynamic_matrices
        IF(.NOT.ASSOCIATED(dynamicMatrices)) THEN
          CALL FlagError("The constraint equations dynamic matrices are not associated.",err,error,*999)
        END IF
      ELSE
        CALL FlagError("The constraint equations matrices are not associated.",err,error,*999)
      END IF
      constraintEquationsMapping=>constraintEquations%constraint_mapping
      IF(ASSOCIATED(constraintEquationsMapping)) THEN
        dynamicMapping=>constraintEquationsMapping%DYNAMIC_MAPPING
        IF(.NOT.ASSOCIATED(dynamicMapping)) THEN
          CALL FlagError("The constraint equations dynamic mapping is not associated.",err,error,*999)
        END IF
      ELSE
        CALL FlagError("The constraint equations mapping is not associated.",err,error,*999)
      END IF
    ELSE
      CALL FlagError("The constraint equations are not associated.",err,error,*999)
    END IF
    IF(ASSOCIATED(matrix)) THEN
      CALL FlagError("The matrix is already associated.",err,error,*999)
    END IF

    !Now get the dynamic matrix
    !Find matrix index using the constraint equations mapping
    SELECT CASE(matrixType)
    CASE(CONSTRAINT_MATRIX_STIFFNESS)
      matrixIndex=dynamicMapping%stiffness_matrix_number
    CASE(CONSTRAINT_MATRIX_DAMPING)
      matrixIndex=dynamicMapping%damping_matrix_number
    CASE(CONSTRAINT_MATRIX_MASS)
      matrixIndex=dynamicMapping%mass_matrix_number
    CASE DEFAULT
      CALL FlagError("Invalid dynamic matrix type "//TRIM(NumberToVstring(matrixType,"*",err,error))// &
        & " specified.",err,error,*999)
    END SELECT
    IF(matrixIndex==0) THEN
      CALL FlagError("The constraint equations dynamic matrices do not have a matrix with the specified type of "// &
        & TRIM(NumberToVstring(matrixType,"*",err,error))//".",err,error,*999)
    ELSE
      constraintMatrix=>dynamicMatrices%matrices(matrixIndex)%ptr
      IF(ASSOCIATED(constraintMatrix)) THEN
        matrix=>constraintMatrix%matrix
      ELSE
        CALL FlagError("The constraint equations dynamic matrix for index "// &
          & TRIM(NumberToVstring(matrixIndex,"*",err,error))//" is not associated.",err,error,*999)
      END IF
    END IF

    CALL Exits("ConstraintEquations_DynamicMatrixGetByType")
    RETURN
999 CALL Errors("ConstraintEquations_DynamicMatrixGetByType",err,error)
    CALL Exits("ConstraintEquations_DynamicMatrixGetByType")
    RETURN 1

  END SUBROUTINE ConstraintEquations_DynamicMatrixGetByType

  !
  !================================================================================================================================
  !

  !>Get the type of a dynamic matrix, eg. stiffness, damping or mass
  SUBROUTINE ConstraintEquations_DynamicMatrixTypeGet(constraintEquations,matrixIndex,matrixType,err,error,*)

    !Argument variables
    TYPE(CONSTRAINT_EQUATIONS_TYPE), POINTER, INTENT(IN) :: constraintEquations !<The constraint equations to get the dynamic matrix for
    INTEGER(INTG), INTENT(IN) :: matrixIndex !<The number of the dynamic matrix to get
    INTEGER(INTG), INTENT(INOUT) :: matrixType !<On return, the type of the dynamic matrix. \see CONSTRAINT_MATRICES_ROUTINES_DynamicMatrixTypes,CONSTRAINT_MATRICES_ROUTINES
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error message
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    TYPE(CONSTRAINT_MAPPING_TYPE), POINTER :: constraintEquationsMapping
    TYPE(CONSTRAINT_MAPPING_DYNAMIC_TYPE), POINTER :: dynamicMapping

    CALL Enters("ConstraintEquations_DynamicMatrixTypeGet",err,error,*999)

    IF(ASSOCIATED(constraintEquations)) THEN
      constraintEquationsMapping=>constraintEquations%constraint_mapping
      IF(ASSOCIATED(constraintEquationsMapping)) THEN
        dynamicMapping=>constraintEquationsMapping%DYNAMIC_MAPPING
        IF(ASSOCIATED(dynamicMapping)) THEN
          IF(matrixIndex>0.AND.matrixIndex<=dynamicMapping%number_of_dynamic_constraint_matrices) THEN
            IF(matrixIndex==dynamicMapping%stiffness_matrix_number) THEN
              matrixType=CONSTRAINT_MATRIX_STIFFNESS
            ELSE IF(matrixIndex==dynamicMapping%damping_matrix_number) THEN
              matrixType=CONSTRAINT_MATRIX_DAMPING
            ELSE IF(matrixIndex==dynamicMapping%mass_matrix_number) THEN
              matrixType=CONSTRAINT_MATRIX_MASS
            ELSE
              CALL FlagError("Could not find dynamic matrix type.",err,error,*999)
            END IF
          ELSE
            CALL FlagError("Invalid matrix index. The matrix index must be greater than zero and less than or equal to "// &
              & TRIM(NumberToVstring(dynamicMapping%number_of_dynamic_constraint_matrices,"*",err,error))//".",err,error,*999)
          END IF
        ELSE
          CALL FlagError("The constraint equations dynamic mapping is not associated.",err,error,*999)
        END IF
      ELSE
        CALL FlagError("The constraint equations mapping is not associated.",err,error,*999)
      END IF
    ELSE
      CALL FlagError("The constraint equations are not associated.",err,error,*999)
    END IF

    CALL Exits("ConstraintEquations_DynamicMatrixTypeGet")
    RETURN
999 CALL Errors("ConstraintEquations_DynamicMatrixTypeGet",err,error)
    CALL Exits("ConstraintEquations_DynamicMatrixTypeGet")
    RETURN 1

  END SUBROUTINE ConstraintEquations_DynamicMatrixTypeGet

  !
  !================================================================================================================================
  !

  !>Get the right hand side vector for constraint equations
  SUBROUTINE ConstraintEquations_RhsVectorGet(constraintEquations,vector,err,error,*)

    !Argument variables
    TYPE(CONSTRAINT_EQUATIONS_TYPE), POINTER, INTENT(IN) :: constraintEquations !<The constraint equations to get the right hand side vector for
    TYPE(DISTRIBUTED_VECTOR_TYPE), POINTER, INTENT(INOUT) :: vector !<On return, the right hand side vector for the constraint equations
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error message
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    TYPE(CONSTRAINT_RHS_TYPE), POINTER :: rhsVector
    TYPE(CONSTRAINT_MATRICES_TYPE), POINTER :: constraintMatrices

    CALL Enters("ConstraintEquations_RhsVectorGet",err,error,*999)

    IF(ASSOCIATED(constraintEquations)) THEN
      constraintMatrices=>constraintEquations%constraint_matrices
      IF(ASSOCIATED(constraintMatrices)) THEN
        rhsVector=>constraintMatrices%rhs_vector
        IF(ASSOCIATED(rhsVector)) THEN
          IF(.NOT.ASSOCIATED(vector)) THEN
            vector=>rhsVector%rhs_vector
          ELSE
            CALL FlagError("The vector is already associated.",err,error,*999)
          END IF
        ELSE
          CALL FlagError("The constraint equations matrices right hand side vector is not associated.",err,error,*999)
        END IF
      ELSE
        CALL FlagError("The constraint equations matrices are not associated.",err,error,*999)
      END IF
    ELSE
      CALL FlagError("The constraint equations are not associated.",err,error,*999)
    END IF

    CALL Exits("ConstraintEquations_RhsVectorGet")
    RETURN
999 CALL Errors("ConstraintEquations_RhsVectorGet",err,error)
    CALL Exits("ConstraintEquations_RhsVectorGet")
    RETURN 1

  END SUBROUTINE ConstraintEquations_RhsVectorGet

  !
  !================================================================================================================================
  !

  !>Get a residual vector for nonlinear constraint equations
  SUBROUTINE ConstraintEquations_ResidualVectorGet(constraintEquations,vector,err,error,*)

    !Argument variables
    TYPE(CONSTRAINT_EQUATIONS_TYPE), POINTER, INTENT(IN) :: constraintEquations !<The constraint equations to get the residual vector for
    TYPE(DISTRIBUTED_VECTOR_TYPE), POINTER, INTENT(INOUT) :: vector !<On return, the residual vector for the constraint equations
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error message
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    TYPE(CONSTRAINT_MATRICES_NONLINEAR_TYPE), POINTER :: nonlinearMatrices
    TYPE(CONSTRAINT_MATRICES_TYPE), POINTER :: constraintMatrices

    CALL Enters("ConstraintEquations_ResidualVectorGet",err,error,*999)

    IF(ASSOCIATED(constraintEquations)) THEN
      constraintMatrices=>constraintEquations%constraint_matrices
      IF(ASSOCIATED(constraintMatrices)) THEN
        nonlinearMatrices=>constraintMatrices%nonlinear_matrices
        IF(ASSOCIATED(nonlinearMatrices)) THEN
          IF(.NOT.ASSOCIATED(vector)) THEN
            vector=>nonlinearMatrices%residual
          ELSE
            CALL FlagError("The vector is already associated.",err,error,*999)
          END IF
        ELSE
          CALL FlagError("The constraint equations matrices nonlinear matrices are not associated.",err,error,*999)
        END IF
      ELSE
        CALL FlagError("The constraint equations matrices are not associated.",err,error,*999)
      END IF
    ELSE
      CALL FlagError("The constraint equations are not associated.",err,error,*999)
    END IF

    CALL Exits("ConstraintEquations_ResidualVectorGet")
    RETURN
999 CALL Errors("ConstraintEquations_ResidualVectorGet",err,error)
    CALL Exits("ConstraintEquations_ResidualVectorGet")
    RETURN 1

  END SUBROUTINE ConstraintEquations_ResidualVectorGet

  !
  !================================================================================================================================
  !

END MODULE CONSTRAINT_EQUATIONS_ROUTINES
